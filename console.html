<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>XUXUBISTATION XS | Bixin Explorador</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root { --ps-blue: #003791; --ps-glow: #0072ce; --glass: rgba(255, 255, 255, 0.1); --bg-gradient: radial-gradient(circle at top right, #0044aa, #000a1a); }
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { background: #000; font-family: 'Segoe UI', sans-serif; color: white; overflow: hidden; height: 100vh; width: 100vw; }

        #brightness-layer { position: fixed; inset: 0; background: black; pointer-events: none; z-index: 20000; opacity: 0; transition: opacity 0.1s; }

        /* --- INTROS --- */
        #intro-layer { position: fixed; inset: 0; background: #000; z-index: 10000; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 1s; }
        
        .intro-titanium .xs-logo { font-size: clamp(5rem, 15vw, 10rem); font-weight: 900; animation: xsStartup 4s forwards; opacity: 0; color: white; }
        .intro-titanium .powered-by { font-size: 0.9rem; letter-spacing: 3px; opacity: 0; animation: subFade 3s 1s forwards; margin-top: -10px; color: #aaa; text-transform: lowercase; }
        
        .intro-retro { align-items: flex-start !important; padding: 50px; font-family: 'Courier New', monospace; color: #0f0; }
        .intro-retro .xs-logo { font-size: 1.5rem; animation: typeBios 0.5s steps(20, end); white-space: nowrap; overflow: hidden; border-right: 2px solid #0f0; }
        .intro-retro .powered-by { margin-top: 10px; font-size: 1rem; color: #0f0; opacity: 0; animation: subFade 0.5s 2s forwards; }
        
        .intro-cyber {
            background: radial-gradient(circle at top right, rgba(0, 255, 255, 0.16), rgba(255, 0, 255, 0.08), #000 60%);
            overflow: hidden;
            padding: max(24px, env(safe-area-inset-top)) 18px max(24px, env(safe-area-inset-bottom));
            text-align: center;
        }
        .intro-cyber::before {
            content: "";
            position: absolute; inset: 0;
            background: repeating-linear-gradient(to bottom, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 1px, rgba(0,0,0,0) 3px, rgba(0,0,0,0) 6px);
            opacity: 0.12;
            pointer-events: none;
            animation: scanMove 3.5s linear infinite;
        }
        .intro-cyber::after {
            content: "";
            position: absolute; inset: -40px;
            background: radial-gradient(circle, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0) 55%);
            opacity: 0.55;
            filter: blur(18px);
            pointer-events: none;
        }
        .intro-cyber .xs-logo {
            position: relative;
            font-size: clamp(4.2rem, 18vw, 9rem);
            font-weight: 900;
            letter-spacing: 0.02em;
            color: #eaffff;
            text-shadow: 0 0 28px rgba(0, 255, 255, 0.35);
            line-height: 1;
            margin-bottom: 6px;
        }
        .intro-cyber .xs-logo::before,
        .intro-cyber .xs-logo::after {
            content: attr(data-text);
            position: absolute; left: 0; right: 0; top: 0;
            opacity: 0.8;
            mix-blend-mode: screen;
        }
        .intro-cyber .xs-logo::before {
            color: #00ffff;
            transform: translate(2px, 0);
            animation: cyberGlitchA 0.9s infinite;
        }
        .intro-cyber .xs-logo::after {
            color: #ff00ff;
            transform: translate(-2px, 0);
            animation: cyberGlitchB 1.1s infinite;
        }
        .intro-cyber .cyber-tag {
            font-size: clamp(1.1rem, 4.2vw, 2.0rem);
            font-weight: 700;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: rgba(255,255,255,0.92);
            text-shadow: 0 0 16px rgba(0, 114, 206, 0.28);
            margin-bottom: 12px;
        }
        .intro-cyber .cyber-console {
            width: min(620px, 92vw);
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.26);
            border-radius: 18px;
            padding: 14px 16px;
            text-align: left;
            font-family: 'Courier New', monospace;
            font-size: clamp(0.78rem, 2.8vw, 0.92rem);
            color: rgba(210, 255, 255, 0.88);
            box-shadow: 0 18px 45px rgba(0,0,0,0.55) inset;
            margin: 0 auto 14px auto;
        }
        .intro-cyber .cyber-console .ok {
            color: #00ffb3;
            font-weight: 700;
        }
        .intro-cyber .cyber-bar {
            width: min(520px, 88vw);
            height: 10px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.06);
            overflow: hidden;
            margin: 0 auto 12px auto;
        }
        .intro-cyber .cyber-bar .fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(0,255,255,0.9), rgba(0,114,206,0.95), rgba(255,0,255,0.85));
            box-shadow: 0 0 22px rgba(0,255,255,0.35);
            animation: cyberLoad 3.6s ease forwards;
        }
        .intro-cyber .powered-by {
            color: rgba(255,255,255,0.9);
            letter-spacing: 0.32em;
            text-transform: uppercase;
            font-size: 0.9rem;
            margin-top: 4px;
            opacity: 0.85;
        }
        @keyframes cyberLoad {
            0% { width: 0%; }
            35% { width: 52%; }
            68% { width: 86%; }
            100% { width: 100%; }
        }
        @keyframes scanMove {
            0% { transform: translateY(-12px); }
            100% { transform: translateY(12px); }
        }
        @keyframes cyberGlitchA {
            0% { clip-path: inset(0 0 85% 0); }
            20% { clip-path: inset(12% 0 60% 0); }
            40% { clip-path: inset(40% 0 30% 0); }
            60% { clip-path: inset(70% 0 10% 0); }
            80% { clip-path: inset(10% 0 72% 0); }
            100% { clip-path: inset(0 0 85% 0); }
        }
        @keyframes cyberGlitchB {
            0% { clip-path: inset(80% 0 0 0); }
            20% { clip-path: inset(55% 0 20% 0); }
            40% { clip-path: inset(30% 0 45% 0); }
            60% { clip-path: inset(8% 0 70% 0); }
            80% { clip-path: inset(65% 0 18% 0); }
            100% { clip-path: inset(80% 0 0 0); }
        }
        
        /* Novas Intros */
        .intro-static { background: url('https://media.giphy.com/media/oEI9uBYOzzkKTyc9A4/giphy.gif'); background-size: cover; }
        .intro-static .xs-logo { font-size: 8rem; font-weight: 900; color: white; mix-blend-mode: overlay; }
        
        .intro-dvd .xs-logo { font-size: 3rem; font-weight: bold; animation: dvdBounce 3s linear infinite alternate; color: var(--ps-glow); }

        .intro-pulse { background: radial-gradient(circle at center, rgba(0,114,206,0.35), #000); }
        .intro-pulse .xs-logo { font-size: 4rem; font-weight: 900; letter-spacing: 8px; color: white; text-shadow: 0 0 25px rgba(0,229,255,0.45); animation: pulseBoot 2.4s ease-in-out infinite; }
        .intro-pulse .powered-by { margin-top: 10px; color: #9aa; letter-spacing: 3px; opacity: 0.85; }
        @keyframes pulseBoot { 0%,100%{ transform: scale(1); opacity:0.85;} 50%{ transform: scale(1.08); opacity:1;} }

        .intro-grid { background: #000; overflow: hidden; }
        .intro-grid::before { content:''; position:absolute; inset:-200px; background: repeating-linear-gradient(90deg, rgba(0,229,255,0.08) 0 2px, transparent 2px 40px), repeating-linear-gradient(0deg, rgba(255,59,212,0.06) 0 2px, transparent 2px 40px); transform: rotate(18deg); animation: gridMove 3.5s linear infinite; }
        .intro-grid::after { content:''; position:absolute; left:-20%; right:-20%; top:50%; height:3px; background: rgba(0,229,255,0.8); box-shadow: 0 0 25px rgba(0,229,255,0.6); animation: scanLine 2.2s ease-in-out infinite; }
        .intro-grid .xs-logo { position: relative; z-index: 1; font-size: 4.5rem; font-weight: 900; color: white; letter-spacing: 10px; text-shadow: 0 0 24px rgba(255,59,212,0.35); }
        .intro-grid .powered-by { position: relative; z-index: 1; margin-top: 12px; color: #8aa; letter-spacing: 4px; }
        @keyframes gridMove { 0%{ transform: rotate(18deg) translateY(0);} 100%{ transform: rotate(18deg) translateY(120px);} }
        @keyframes scanLine { 0%{ transform: translateY(-120px); opacity:0;} 25%{opacity:1;} 50%{ transform: translateY(120px); opacity:1;} 100%{opacity:0;} }

        .intro-holo { background: radial-gradient(circle at top, rgba(255,59,212,0.18), rgba(0,229,255,0.10), #000 60%); }
        .intro-holo .xs-logo { font-size: 5rem; font-weight: 900; color: rgba(255,255,255,0.92); letter-spacing: 12px; position: relative; }
        .intro-holo .xs-logo::after { content:''; position:absolute; inset:-6px; background: linear-gradient(90deg, rgba(0,229,255,0.0), rgba(0,229,255,0.35), rgba(255,59,212,0.0)); filter: blur(10px); mix-blend-mode: screen; animation: holoSweep 2.8s ease-in-out infinite; }
        .intro-holo .powered-by { margin-top: 14px; color: #b9b9ff; letter-spacing: 3px; }
        @keyframes holoSweep { 0%{ transform: translateX(-40%); opacity:0.2;} 50%{ transform: translateX(40%); opacity:0.7;} 100%{ transform: translateX(-40%); opacity:0.2;} }
        @keyframes dvdBounce { 0% { transform: translate(-100px, -100px); color: red; } 25% { transform: translate(100px, -50px); color: blue; } 50% { transform: translate(-50px, 100px); color: green; } 75% { transform: translate(50px, 50px); color: yellow; } 100% { transform: translate(0, 0); color: purple; } }

        /* --- EXTRA INTROS (LOJA EXPANDIDA) --- */
        .intro-x360{
            background: radial-gradient(circle at 50% 40%, #f7f7f7, #d9d9d9 55%, #bcbcbc 100%);
            color: #0a0a0a;
            overflow: hidden;
        }
        .intro-x360::before{
            content:"";
            position:absolute; inset:-40%;
            background: radial-gradient(circle at center, rgba(0,0,0,0.08), rgba(0,0,0,0.35) 70%);
            transform: rotate(8deg);
        }
        .intro-x360 .x360-orb{
            position:absolute;
            width: 42px; height: 42px;
            border-radius: 50%;
            filter: blur(0.2px);
            opacity: 0.0;
            mix-blend-mode: multiply;
        }
        .intro-x360 .x360-orb::after{
            content:"";
            position:absolute; inset:-18px;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(255,255,255,0.85), rgba(255,255,255,0) 55%);
            opacity: 0.55;
        }
        .intro-x360 .x360-orb.o1{ background:#64ff5a; box-shadow: 0 0 18px rgba(100,255,90,0.7); top: 48%; left: -10%; animation: x360Orb1 1.35s cubic-bezier(.2,.9,.2,1) forwards; }
        .intro-x360 .x360-orb.o2{ background:#9bff5a; box-shadow: 0 0 18px rgba(155,255,90,0.7); top: -10%; left: 55%; animation: x360Orb2 1.35s cubic-bezier(.2,.9,.2,1) .06s forwards; }
        .intro-x360 .x360-orb.o3{ background:#4de6ff; box-shadow: 0 0 18px rgba(77,230,255,0.6); top: 52%; right: -10%; animation: x360Orb3 1.35s cubic-bezier(.2,.9,.2,1) .12s forwards; }
        .intro-x360 .x360-orb.o4{ background:#64ff5a; box-shadow: 0 0 18px rgba(100,255,90,0.7); bottom: -10%; left: 45%; animation: x360Orb4 1.35s cubic-bezier(.2,.9,.2,1) .18s forwards; }

        .intro-x360 .x360-core{
            position:absolute; left:50%; top:50%;
            width: 220px; height: 220px;
            transform: translate(-50%,-50%) scale(0.88);
            border-radius: 50%;
            background: radial-gradient(circle at 35% 30%, rgba(255,255,255,0.85), rgba(255,255,255,0.2) 35%, rgba(0,0,0,0.08) 70%, rgba(0,0,0,0.16) 100%);
            box-shadow: inset 0 0 30px rgba(0,0,0,0.22), 0 0 40px rgba(0,0,0,0.08);
            opacity: 0;
            animation: x360Core 1.1s ease .55s forwards;
        }
        .intro-x360 .xs-logo{
            position:relative;
            font-size: clamp(4rem, 14vw, 7rem);
            font-weight: 900;
            letter-spacing: 10px;
            color: #2a2a2a;
            text-shadow: 0 0 14px rgba(100,255,90,0.22);
            opacity: 0;
            transform: translateY(8px) scale(0.98);
            animation: x360Logo 0.9s cubic-bezier(.2,.9,.2,1) .9s forwards;
        }
        .intro-x360 .powered-by{
            position:relative;
            margin-top: 6px;
            letter-spacing: 4px;
            text-transform: uppercase;
            font-size: .85rem;
            color: rgba(0,0,0,0.55);
            opacity: 0;
            animation: x360Sub 0.8s ease 1.05s forwards;
        }
        @keyframes x360Orb1{ 0%{ opacity:0; transform: translate(0,-50%) scale(1);} 35%{opacity:1;} 100%{ opacity:0.15; transform: translate(580%, -50%) scale(0.25);} }
        @keyframes x360Orb2{ 0%{ opacity:0; transform: translate(-50%,0) scale(1);} 35%{opacity:1;} 100%{ opacity:0.15; transform: translate(-50%, 520%) scale(0.25);} }
        @keyframes x360Orb3{ 0%{ opacity:0; transform: translate(0,-50%) scale(1);} 35%{opacity:1;} 100%{ opacity:0.15; transform: translate(-580%, -50%) scale(0.25);} }
        @keyframes x360Orb4{ 0%{ opacity:0; transform: translate(-50%,0) scale(1);} 35%{opacity:1;} 100%{ opacity:0.15; transform: translate(-50%, -520%) scale(0.25);} }
        @keyframes x360Core{ to{ opacity: 1; transform: translate(-50%,-50%) scale(1);} }
        @keyframes x360Logo{ to{ opacity: 1; transform: translateY(0) scale(1);} }
        @keyframes x360Sub{ to{ opacity: 1;} }

        .intro-matrixrain{
            background: radial-gradient(circle at 50% 20%, rgba(0,255,100,0.10), #000 60%);
            overflow:hidden;
        }
        .intro-matrixrain .matrix{
            position:absolute; inset:0;
            background: repeating-linear-gradient(90deg, rgba(0,255,120,0.12) 0 2px, transparent 2px 22px);
            mask-image: linear-gradient(to bottom, transparent, rgba(0,0,0,1) 15%, rgba(0,0,0,1) 85%, transparent);
            opacity: .55;
            animation: matrixScroll 1.9s linear infinite;
        }
        .intro-matrixrain .matrix::after{
            content:"101001 XS 0110 1101 0101  XS  001 010 111  XS  1101 0010";
            position:absolute; left:0; right:0; top:-120px;
            font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
            font-size: 14px;
            letter-spacing: 8px;
            color: rgba(120,255,160,0.45);
            text-align:center;
        }
        @keyframes matrixScroll { from{ transform: translateY(-90px);} to{ transform: translateY(90px);} }

        .intro-glitchv2{
            background: radial-gradient(circle at top, rgba(255,0,80,0.16), rgba(0,229,255,0.10), #000 65%);
            overflow:hidden;
        }
        .intro-glitchv2 .xs-logo{
            font-size: clamp(5rem, 18vw, 10rem);
            font-weight: 900;
            letter-spacing: 14px;
            text-shadow: 2px 0 rgba(0,229,255,0.7), -2px 0 rgba(255,0,80,0.7);
            animation: glitch2 1.05s infinite;
        }
        .intro-glitchv2 .powered-by{ margin-top: 6px; color: rgba(255,255,255,0.85); letter-spacing: 4px; text-transform: uppercase; opacity: .85;}
        @keyframes glitch2{
            0%{ transform: translate(0,0) skew(0deg); filter:none;}
            20%{ transform: translate(-2px,1px) skew(-2deg); }
            40%{ transform: translate(2px,-1px) skew(2deg); }
            60%{ transform: translate(-1px,-2px) skew(-1deg); }
            80%{ transform: translate(1px,2px) skew(1deg); }
            100%{ transform: translate(0,0) skew(0deg); }
        }

        .intro-starfield{
            background: radial-gradient(circle at 50% 20%, rgba(100,180,255,0.18), #000 62%);
            overflow:hidden;
        }
        .intro-starfield::before{
            content:"";
            position:absolute; inset:-50%;
            background:
              radial-gradient(circle, rgba(255,255,255,0.9) 0 1px, transparent 2px) 0 0/120px 120px,
              radial-gradient(circle, rgba(255,255,255,0.7) 0 1px, transparent 2px) 40px 60px/160px 160px,
              radial-gradient(circle, rgba(255,255,255,0.5) 0 1px, transparent 2px) 80px 20px/220px 220px;
            opacity: .55;
            animation: starDrift 3.6s linear infinite;
        }
        @keyframes starDrift{ from{ transform: translateY(-40px);} to{ transform: translateY(40px);} }

        .intro-biohazard{
            background: radial-gradient(circle at top, rgba(255,80,80,0.20), #000 70%);
            overflow:hidden;
        }
        .intro-biohazard::before{
            content:"";
            position:absolute; inset:0;
            background: repeating-linear-gradient(135deg, rgba(255,200,0,0.08) 0 18px, rgba(0,0,0,0.0) 18px 36px);
            opacity: .75;
        }
        .intro-biohazard .powered-by{ color: rgba(255,210,120,0.92); letter-spacing: 5px; text-transform: uppercase; }
        .intro-biohazard .haz-ring{
            position:absolute; left:50%; top:50%;
            width: 260px; height: 260px;
            transform: translate(-50%,-50%);
            border-radius: 50%;
            border: 2px solid rgba(255,80,80,0.55);
            box-shadow: 0 0 28px rgba(255,80,80,0.28), inset 0 0 28px rgba(0,0,0,0.55);
            animation: hazPulse 1.4s ease-in-out infinite;
            opacity: .85;
        }
        @keyframes hazPulse{ 0%,100%{ transform: translate(-50%,-50%) scale(0.98);} 50%{ transform: translate(-50%,-50%) scale(1.03);} }

        .intro-aurora{
            background: radial-gradient(circle at 50% 0%, rgba(0,229,255,0.15), rgba(255,59,212,0.10), #000 65%);
            overflow:hidden;
        }
        .intro-aurora::before{
            content:"";
            position:absolute; inset:-30%;
            background: conic-gradient(from 180deg, rgba(0,229,255,0.0), rgba(0,229,255,0.18), rgba(255,59,212,0.16), rgba(0,255,179,0.12), rgba(0,229,255,0.0));
            filter: blur(24px);
            animation: auroraSpin 5s ease-in-out infinite;
            opacity: .75;
        }
        @keyframes auroraSpin{ 0%,100%{ transform: rotate(-10deg) translateY(0);} 50%{ transform: rotate(12deg) translateY(14px);} }

        .intro-scanline{
            background: #000;
            overflow:hidden;
        }
        .intro-scanline::before{
            content:"";
            position:absolute; inset:0;
            background: repeating-linear-gradient(0deg, rgba(255,255,255,0.06) 0 1px, transparent 1px 4px);
            opacity: .35;
        }
        .intro-scanline::after{
            content:"";
            position:absolute; left:-20%; right:-20%;
            top:50%; height:3px;
            background: rgba(0,229,255,0.8);
            box-shadow: 0 0 26px rgba(0,229,255,0.55);
            animation: scanSweep 2.2s ease-in-out infinite;
            opacity: .9;
        }
        @keyframes scanSweep{ 0%{ transform: translateY(-140px); opacity:0;} 20%{opacity:1;} 50%{ transform: translateY(140px); opacity:1;} 100%{ opacity:0;} }

        .intro-quantum{
            background: radial-gradient(circle at center, rgba(255,255,255,0.07), #000 58%);
            overflow:hidden;
        }
        .intro-quantum::before{
            content:"";
            position:absolute; inset:-40%;
            background: repeating-radial-gradient(circle at center, rgba(0,229,255,0.14) 0 2px, transparent 2px 14px);
            opacity:.55;
            animation: quantumZoom 1.9s ease-in-out infinite;
        }
        @keyframes quantumZoom{ 0%,100%{ transform: scale(0.9);} 50%{ transform: scale(1.05);} }

        .intro-vhs{
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.70)), #000;
            overflow:hidden;
        }
        .intro-vhs::before{
            content:"";
            position:absolute; inset:0;
            background: linear-gradient(90deg, rgba(255,0,0,0.10), rgba(0,255,0,0.10), rgba(0,0,255,0.10));
            opacity:.45;
            mix-blend-mode: screen;
            animation: vhsShift 0.9s steps(2,end) infinite;
        }
        .intro-vhs::after{
            content:"";
            position:absolute; inset:0;
            background: repeating-linear-gradient(0deg, rgba(255,255,255,0.06) 0 1px, transparent 1px 3px);
            opacity:.25;
        }
        @keyframes vhsShift{ 0%{ transform: translateX(0);} 50%{ transform: translateX(-8px);} 100%{ transform: translateX(0);} }

        .intro-bloom{
            background: radial-gradient(circle at 50% 20%, rgba(0,229,255,0.18), rgba(255,59,212,0.12), #000 62%);
            overflow:hidden;
        }
        .intro-bloom::before{
            content:"";
            position:absolute; inset:-30%;
            background: radial-gradient(circle at center, rgba(255,255,255,0.18), rgba(255,255,255,0) 60%);
            filter: blur(26px);
            opacity:.55;
            animation: bloomPulse 2.2s ease-in-out infinite;
        }
        @keyframes bloomPulse{ 0%,100%{ transform: scale(0.95); opacity:.45;} 50%{ transform: scale(1.06); opacity:.70;} }

        @keyframes xsStartup { 0% { opacity: 0; transform: scale(0.8); filter: blur(10px); } 50% { opacity: 1; transform: scale(1); filter: blur(0px); text-shadow: 0 0 30px var(--ps-glow); } 100% { opacity: 0; transform: scale(1.1); } }
        @keyframes typeBios { from { width: 0; } to { width: 100%; border-color: transparent; } }
        @keyframes glitch { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0); } }
        @keyframes subFade { from { opacity: 0; } to { opacity: 0.6; } }

        #user-select-layer { position: fixed; inset: 0; background: radial-gradient(circle at center, #003791 0%, #000a1a 100%); z-index: 9000; display: none; flex-direction: column; justify-content: center; align-items: center; }
        .user-grid { display: flex; gap: 40px; justify-content: center; margin-bottom: 50px; }
        .user-card { text-align: center; cursor: pointer; transition: 0.4s; opacity: 0.5; }
        .user-card.selected { opacity: 1; transform: translateY(-15px) scale(1.1); }
        .avatar { width: clamp(100px, 18vw, 150px); height: clamp(100px, 18vw, 150px); background: #111; border-radius: 20px; border: 4px solid transparent; margin-bottom: 15px; overflow: hidden; }
        .user-card.selected .avatar { border-color: white; box-shadow: 0 0 40px var(--ps-glow); }

        #main-ui { display: none; width: 100vw; height: 100vh; min-width: 100vw; min-height: 100vh; background: var(--bg-gradient); background-size: cover; background-position: center; transition: background 0.5s ease; overflow: hidden; }
        .top-bar { display: flex; justify-content: space-between; align-items: center; padding: 20px 60px; background: rgba(0,0,0,0.3); }
        .xs-brand { font-weight: 900; font-size: 1.2rem; cursor: pointer; }
        .user-section { display: flex; gap: 15px; align-items: center; }
        .coin-display { background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px; border: 1px solid #ffd700; color: #ffd700; font-weight: bold; display: flex; align-items: center; gap: 5px; box-shadow: 0 0 10px rgba(255, 215, 0, 0.2); }
        #user-display { cursor: pointer; transition: 0.3s; padding: 5px 15px; border-radius: 20px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; gap: 10px; }
        
        .dashboard-content { padding-top: 40px; }
        .game-info { padding: 0 100px; margin-bottom: 20px; height: 80px;}
        #game-title { font-size: clamp(1.2rem, 3.5vw, 2.5rem); font-weight: 100; text-transform: uppercase; letter-spacing: 4px; }
        
        .carousel-container {  --card-size: clamp(180px, 25vw, 260px); padding-left: max(18px, env(safe-area-inset-left)); padding-right: max(18px, env(safe-area-inset-right)); overflow-x: auto; overflow-y: hidden; display: block; scroll-padding: 20px; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; overscroll-behavior-x: contain; }
        .carousel-track { display: inline-flex; gap: 25px; padding: 8px 0 18px; transition: none; transform: none !important; will-change: auto; }
        .game-card { 
            --r: 16px;
            flex: 0 0 var(--card-size);
            width: var(--card-size);
            height: var(--card-size);
            min-width: var(--card-size);
            aspect-ratio: 1 / 1;
            box-sizing: border-box;
            padding: 10px;
            background: var(--glass);
            border: 4px solid transparent;
            border-radius: var(--r);
            transition: transform 0.35s, box-shadow 0.35s, border-color 0.35s;
            overflow: hidden;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Destaque chamativo: Guia do Console (brilho/reflexo animado) */
        .game-card.guide-highlight{
            border-color: rgba(0,229,255,0.65);
            box-shadow: 0 22px 55px rgba(0,0,0,0.55), 0 0 26px rgba(0,229,255,0.14);
        }
        .game-card.guide-highlight::before{
            content:"";
            position:absolute;
            inset:-40%;
            background: linear-gradient(120deg,
                transparent 0%,
                rgba(255,255,255,0.00) 35%,
                rgba(255,255,255,0.28) 48%,
                rgba(255,255,255,0.00) 62%,
                transparent 100%);
            transform: translateX(-60%) rotate(10deg);
            animation: xsGuideShine 2.2s cubic-bezier(0.4,0,0.2,1) infinite;
            pointer-events:none;
            mix-blend-mode: screen;
        }
        .game-card.guide-highlight::after{
            content:"";
            position:absolute;
            inset:0;
            border-radius: var(--r);
            box-shadow: 0 0 0 1px rgba(0,229,255,0.20) inset, 0 0 28px rgba(0,229,255,0.10) inset;
            pointer-events:none;
        }
        @keyframes xsGuideShine{
            0%   { transform: translateX(-70%) rotate(10deg); opacity: 0.0; }
            10%  { opacity: 1; }
            50%  { transform: translateX(70%) rotate(10deg); opacity: 1; }
            70%  { opacity: 0.0; }
            100% { transform: translateX(70%) rotate(10deg); opacity: 0.0; }
        }
.game-card.active { border-color: white; transform: scale(1.08); box-shadow: 0 20px 50px rgba(0,0,0,0.5); z-index: 10; }
        .game-card img { width: 100%; height: 100%; object-fit: contain; object-position: center; }
        
        /* CARD STYLES */
        .game-card.style-glass { border-radius: 10px; }
        .game-card.style-bubble { border-radius: 50%; width: clamp(180px, 25vw, 260px); }
        .game-card.style-sharp { border-radius: 0px; border-width: 6px; }
        .game-card.style-poster { aspect-ratio: 2/3 !important; min-width: clamp(140px, 20vw, 200px); border-radius: 5px; }
        .game-card.style-neon { border-radius: 15px; box-shadow: 0 0 10px var(--ps-glow), inset 0 0 10px var(--ps-glow); border: 2px solid white; }
        .game-card.style-holo { border-radius: 18px; border: 2px solid rgba(255,255,255,0.6); background: linear-gradient(135deg, rgba(0,229,255,0.18), rgba(255,59,212,0.14), rgba(0,255,179,0.12)); box-shadow: 0 0 18px rgba(0,229,255,0.35), inset 0 0 18px rgba(255,59,212,0.25); }
        .game-card.style-pixel { border-radius: 12px; border: 4px solid rgba(255,255,255,0.35); image-rendering: pixelated; filter: contrast(1.05) saturate(1.1); box-shadow: 0 10px 30px rgba(0,0,0,0.35) inset; }
        .game-card.style-chrome { border-radius: 14px; border: 2px solid rgba(255,255,255,0.55); background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.03)); box-shadow: 0 0 14px rgba(255,255,255,0.25), inset 0 0 22px rgba(0,0,0,0.35); }

        .game-card.style-retrocartridge { border-radius: 16px; border: 3px solid rgba(255,255,255,0.22); background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(0,0,0,0.25)); box-shadow: 0 18px 50px rgba(0,0,0,0.40), inset 0 0 0 2px rgba(0,0,0,0.55); }
        .game-card.style-retrocartridge::after { content:''; position:absolute; inset:auto 12% 10% 12%; height:10px; border-radius:999px; background: rgba(255,255,255,0.22); box-shadow: inset 0 0 0 1px rgba(0,0,0,0.35); }

        .game-card.style-scifiborder { border-radius: 18px; border: 2px solid rgba(0,229,255,0.45); background: linear-gradient(135deg, rgba(0,229,255,0.10), rgba(255,255,255,0.03)); box-shadow: 0 0 18px rgba(0,229,255,0.25), inset 0 0 30px rgba(0,0,0,0.35); }
        .game-card.style-scifiborder::before { content:''; position:absolute; inset:10px; border-radius:14px; border: 1px dashed rgba(255,255,255,0.18); opacity:0.9; }

        .game-card.style-glowedge { border-radius: 16px; border: 2px solid rgba(255,255,255,0.22); box-shadow: 0 0 18px rgba(0,229,255,0.35), 0 0 42px rgba(255,59,212,0.18), inset 0 0 18px rgba(0,229,255,0.25); background: rgba(255,255,255,0.06); }

        .game-card.style-metallic { border-radius: 14px; border: 2px solid rgba(255,255,255,0.45); background: linear-gradient(135deg, rgba(255,255,255,0.18), rgba(255,255,255,0.04), rgba(0,0,0,0.35)); box-shadow: 0 0 18px rgba(255,255,255,0.18), inset 0 0 26px rgba(0,0,0,0.45); }

        .game-card.style-minimalist { border-radius: 12px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.05); box-shadow: 0 14px 40px rgba(0,0,0,0.35); }

        .game-card.style-holov2 { border-radius: 20px; border: 2px solid rgba(255,255,255,0.40); background: linear-gradient(135deg, rgba(255,59,212,0.14), rgba(0,229,255,0.12), rgba(0,255,179,0.10)); box-shadow: 0 0 24px rgba(255,59,212,0.22), 0 0 24px rgba(0,229,255,0.22), inset 0 0 26px rgba(255,255,255,0.10); }
        .game-card.style-holov2::after { content:''; position:absolute; inset:-40%; background: linear-gradient(90deg, rgba(255,255,255,0.0), rgba(255,255,255,0.20), rgba(255,255,255,0.0)); transform: rotate(25deg); animation: holov2Sweep 2.8s ease-in-out infinite; }
        @keyframes holov2Sweep { 0%{ transform: translateX(-35%) rotate(25deg); opacity:0.25;} 50%{ transform: translateX(35%) rotate(25deg); opacity:0.65;} 100%{ transform: translateX(-35%) rotate(25deg); opacity:0.25;} }

        .game-card.style-parchment { border-radius: 14px; border: 2px solid rgba(205,180,130,0.55); background: linear-gradient(135deg, rgba(250,240,220,0.10), rgba(160,120,60,0.08)); box-shadow: 0 14px 40px rgba(0,0,0,0.35), inset 0 0 0 2px rgba(0,0,0,0.25); filter: saturate(0.95); }

        .game-card.style-carbonfiber { border-radius: 16px; border: 2px solid rgba(255,255,255,0.16); background: repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0 6px, rgba(0,0,0,0.18) 6px 12px); box-shadow: 0 0 18px rgba(0,0,0,0.65), inset 0 0 24px rgba(0,0,0,0.45); }

        .game-card.style-velvet { border-radius: 18px; border: 2px solid rgba(255,255,255,0.18); background: radial-gradient(circle at 30% 25%, rgba(255,255,255,0.12), rgba(0,0,0,0.28)), linear-gradient(135deg, rgba(130,0,160,0.12), rgba(0,0,0,0.28)); box-shadow: 0 0 22px rgba(130,0,160,0.20), inset 0 0 26px rgba(0,0,0,0.40); }

        .game-card.style-prism { border-radius: 18px; border: 2px solid rgba(255,255,255,0.35); background: linear-gradient(135deg, rgba(0,229,255,0.10), rgba(255,255,255,0.03), rgba(255,59,212,0.10)); box-shadow: 0 0 24px rgba(0,229,255,0.20), 0 0 24px rgba(255,59,212,0.18), inset 0 0 26px rgba(255,255,255,0.08); }

        .sys-icon { font-size: 100px !important; color: white; text-shadow: 0 0 20px var(--ps-glow); }

        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 15000; display: none; flex-direction: column; justify-content: center; align-items: center; backdrop-filter: blur(20px); padding: 18px; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        .modal-box { background: #050505; padding: 25px 40px; border-radius: 30px; border: 1px solid rgba(255,255,255,0.1); width: 85%; max-width: 800px; box-shadow: 0 0 100px rgba(0,0,0,1); max-height: calc(100vh - 36px); overflow-y: auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        
        .store-scroll { max-height: 55vh; overflow-y: auto; padding-right: 10px; padding-bottom: 20px; }
        .store-section-title { color: #ffd700; font-size: 0.8rem; margin: 20px 0 10px 0; text-transform: uppercase; letter-spacing: 2px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .custom-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; }
        .shop-btn { height: 90px; border-radius: 10px; border: 2px solid #333; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.3s; background: #111; position: relative; overflow: hidden; }
        .shop-btn:hover { background: #222; }
        .shop-btn.active { border-color: var(--ps-glow); background: rgba(0, 55, 145, 0.3); box-shadow: 0 0 15px var(--ps-glow); }
        .shop-btn h4 { font-size: 0.8rem; margin-bottom: 5px; text-align: center;}
        .shop-btn p { font-size: 0.7rem; color: #aaa; text-align: center;}
        .shop-lock { position: absolute; inset: 0; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 5; color: #ffd700; font-size: 0.8rem; font-weight: bold; }

        .settings-list { max-height: 55vh; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; padding-right: 10px; padding-bottom: 30px; }
        .st-group-title { color: var(--ps-glow); font-size: 0.75rem; margin-top: 15px; margin-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        .st-item { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); padding: 12px 15px; border-radius: 10px; flex-shrink: 0; }
        .st-item h4 { font-size: 0.9rem; margin-bottom: 2px; }
        .btn-action { background: var(--ps-blue); color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 0.8rem; }
        .btn-danger { background: #8b0000; }
        .btn-whatsapp { background: #25D366; }
        .select-box { background: #111; color: white; border: 1px solid #333; padding: 5px; border-radius: 5px; }

        .tutorial-container { position: relative; height: min(420px, 55vh); min-height: 280px; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .tutorial-slide { display: none; text-align: center; animation: fadeSlide 0.5s; width: 100%; padding: 20px; max-height: 100%; overflow-y: auto; }
        .tutorial-slide.active { display: block; }
        @keyframes fadeSlide { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
        .tut-icon { font-size: 5rem; color: var(--ps-glow); margin-bottom: 20px; text-shadow: 0 0 20px var(--ps-glow); }
        .tut-title { font-size: 1.5rem; margin-bottom: 15px; color: white; text-transform: uppercase; letter-spacing: 2px; }
        .tut-desc { color: #ccc; font-size: 1rem; line-height: 1.6; max-width: 600px; margin: 0 auto; }
        .tut-nav { position: absolute; top: 50%; width: 100%; display: flex; justify-content: space-between; padding: 0 10px; transform: translateY(-50%); pointer-events: none; }
        .tut-btn { pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; width: 50px; height: 50px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.3s; backdrop-filter: blur(5px); }
        .tut-btn:hover { background: var(--ps-glow); transform: scale(1.1); }

        #achievement-toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%) translateY(-100px); background: rgba(0,0,0,0.9); border: 2px solid #ffd700; padding: 15px 30px; border-radius: 50px; display: flex; align-items: center; gap: 15px; z-index: 20000; transition: 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); box-shadow: 0 0 30px rgba(255,215,0,0.3); }
        #achievement-toast.show { transform: translateX(-50%) translateY(0); }

        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; inset: 0; background-color: #333; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--ps-blue); }
        input:checked + .slider:before { transform: translateX(20px); }

        #mobile-controls { position: fixed; bottom: 30px; left: 0; width: 100%; display: flex; justify-content: space-between; padding: 0 30px; z-index: 9500; pointer-events: none; }
        .btn-group { display: flex; gap: 15px; pointer-events: auto; }
        .m-btn { width: 65px; height: 65px; background: rgba(255,255,255,0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(10px); color: white; font-size: 1.2rem; }
        .m-btn:active { background: var(--ps-glow); }
        #game-runtime { position: fixed; inset: 0; background: #000; z-index: 10000; display: none; }
        .ui-overlay { position: absolute; top: calc(env(safe-area-inset-top, 0px) + 12px); right: calc(env(safe-area-inset-right, 0px) + 12px); z-index: 10001; }
        .game-btn { background: #ff3b3b; color: white; border: none; padding: 10px 25px; border-radius: 30px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        iframe { width: 100%; height: 100%; border: none; background: #000; }
        .sideload-list { max-height: 250px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
        .sideload-item { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 12px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: 0.3s; border: 1px solid rgba(255,255,255,0.1); }
        .sideload-item:hover { background: var(--ps-glow); }
        
        .profile-editor-layout { display: flex; gap: 30px; align-items: center; }
        .profile-preview { flex: 1; text-align: center; }
        .profile-preview img { width: 130px; height: 130px; border-radius: 20px; border: 3px solid var(--ps-glow); background: #111; }
        .profile-controls { flex: 2; text-align: left; }
        .avatar-grid-7 { display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px; margin-bottom: 15px; }
        .avatar-grid-7 img { width: 100%; aspect-ratio: 1; border-radius: 10px; cursor: pointer; border: 2px solid transparent; transition: 0.2s; background: #222; }
        .avatar-grid-7 img.active { border-color: var(--ps-glow); transform: scale(1.1); }
        .name-input { width: 100%; padding: 12px; border-radius: 10px; border: 1px solid #333; background: #111; color: white; margin-bottom: 15px; font-size: 1rem; text-align: center; }
        .achievements-list { max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
        .achievement-item { background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; border-left: 5px solid #444; display: flex; justify-content: space-between; align-items: center; }
        .achievement-item.unlocked { border-left-color: #ffd700; background: rgba(255,215,0,0.1); }

        
        /* UNIFORM SQUARE TILES (no crop) */
        .carousel-track .game-card,
        .carousel-track .game-card[class*="style-"] {
            width: var(--card-size) !important;
            height: var(--card-size) !important;
            min-width: var(--card-size) !important;
            aspect-ratio: 1 / 1 !important;
        }
        .carousel-track .game-card.style-bubble,
        .carousel-track .game-card.style-poster {
            border-radius: 16px !important;
        }
/* THEME CLASSES */
        .tp-default { background: radial-gradient(circle at top right, #0044aa, #000a1a); }
        .tp-midnight { background: radial-gradient(circle at top right, #2a004a, #0a001a); }
        .tp-emerald { background: radial-gradient(circle at top right, #004a2a, #001a0a); }
        .tp-ruby { background: radial-gradient(circle at top right, #4a0000, #1a0000); }
        .tp-gold { background: radial-gradient(circle at top right, #aa8800, #1a1a00); }
        .tp-cyber { background: linear-gradient(45deg, #00ffff, #ff00ff); }
        .tp-monolith { background: radial-gradient(circle at top right, #444, #000); }
        .tp-vaporwave { background: linear-gradient(135deg, #ff4fd8, #6b5bff, #00e5ff); }
        .tp-deepsea { background: radial-gradient(circle at top right, #003b5c, #000814); }
        .tp-marsrover { background: radial-gradient(circle at top right, #6b1e10, #120402); }
        .tp-forest { background: radial-gradient(circle at top right, #0a5b2b, #02150a); }
        .tp-sakura { background: linear-gradient(135deg, #ffb7d5, #ffdfe9, #a6c1ee); }
        .tp-cyberred { background: linear-gradient(135deg, #ff0033, #2b0006, #00e5ff); }
        .tp-monogold { background: linear-gradient(135deg, #d6b45a, #3a2a05); }
        .tp-arctic { background: radial-gradient(circle at top right, #c8f1ff, #001018); }
        .tp-ultraviolet { background: radial-gradient(circle at top right, #7b2cff, #0b0016); }
        .tp-desertstorm { background: radial-gradient(circle at top right, #caa46a, #1a1206); }
        .tp-sunset { background: linear-gradient(to bottom, #ff4e50, #f9d423); }
        .tp-matrix { background: linear-gradient(0deg, #000, #003300); border: 1px solid #0f0; }
        .tp-cotton { background: linear-gradient(to right, #fbc2eb, #a6c1ee); }
        .tp-dracula { background: linear-gradient(to bottom, #282a36, #44475a); border: 1px solid #bd93f9; }
        .tp-white { background: #ccc; color: black !important; } 

        /* --- ROULETA XC (CS GO STYLE) --- */
        .roulette-stage { position: relative; width: 100%; padding: 8px 0; }
        .roulette-viewport { width: 100%; height: 128px; overflow: hidden; border-radius: 18px; border: 1px solid rgba(255,255,255,0.14); background: rgba(0,0,0,0.22); box-shadow: 0 14px 30px rgba(0,0,0,0.35) inset; }
        .roulette-track { display: flex; align-items: stretch; height: 100%; transform: translateX(0px); will-change: transform; }
        .roulette-item { width: 120px; min-width: 120px; height: 100%; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:6px; border-right: 1px solid rgba(255,255,255,0.06); position: relative; }
        .roulette-item::after { content:""; position:absolute; inset: 8px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.10); pointer-events:none; }
        .roulette-item img { width: 56px; height: 56px; }
        .roulette-item .ri-name { font-size:0.72rem; color:#eaeaea; text-align:center; padding: 0 6px; line-height: 1.1; }
        .roulette-item .ri-rarity { font-size:0.68rem; letter-spacing:2px; opacity:0.95; }
        .roulette-indicator { position:absolute; left:50%; top: 4px; bottom:4px; width:0; transform: translateX(-50%); pointer-events:none; }
        .roulette-indicator::before { content:""; position:absolute; top: -2px; left:-10px; border-left:10px solid transparent; border-right:10px solid transparent; border-top:12px solid rgba(255,255,255,0.92); filter: drop-shadow(0 6px 10px rgba(0,0,0,0.5)); }
        .roulette-indicator::after { content:""; position:absolute; top: 8px; left:-1px; width:2px; height: calc(100% - 16px); background: rgba(255,255,255,0.12); box-shadow: 0 0 18px rgba(0,114,206,0.25); }
        .rr-common { color:#cfcfcf; }
        .rr-rare { color:#00e5ff; }
        .rr-epic { color:#c878ff; }
        .rr-legendary { color:#ffd700; }
        .rr-mythic { color:#ff3bd4; }
        .roulette-item.r-rare::after { border-color: rgba(0,229,255,0.35); box-shadow: 0 0 18px rgba(0,229,255,0.18); }
        .roulette-item.r-epic::after { border-color: rgba(200,120,255,0.38); box-shadow: 0 0 20px rgba(200,120,255,0.18); }
        .roulette-item.r-legendary::after { border-color: rgba(255,215,0,0.42); box-shadow: 0 0 22px rgba(255,215,0,0.18); }
        .roulette-item.r-mythic::after { border-color: rgba(255,59,212,0.45); box-shadow: 0 0 26px rgba(255,59,212,0.20); animation: rouletteMythicPulse 1.8s infinite; }
        @keyframes rouletteMythicPulse { 0%{ filter: saturate(1) brightness(1); } 50%{ filter: saturate(1.4) brightness(1.15);} 100%{ filter: saturate(1) brightness(1);} }

        /* MÍTICO: efeito arco-íris retroativo */
        .roulette-item.r-mythic::after {
            border-color: transparent;
            background: conic-gradient(from 0deg, #ff004c, #ffea00, #00ff99, #00e5ff, #7c4dff, #ff3bd4, #ff004c);
            -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            padding: 1px;
            animation: mythicHue 2.2s linear infinite;
        }
        .roulette-item.r-mythic img {
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.25));
            animation: mythicHue 2.2s linear infinite;
        }
        
        /* ===========================
           ROULETTE INVENTORY (PREMIUM)
           Escopo: somente #roulette-modal
           =========================== */
        #roulette-modal #roulette-inventory{ margin-top:12px; }
        #roulette-modal .ri-head{ display:flex; justify-content:space-between; align-items:flex-end; gap:12px; margin-bottom:10px; }
        #roulette-modal .ri-title{ font-size:0.82rem; color:var(--ps-glow); letter-spacing:2.5px; font-weight:800; }
        #roulette-modal .ri-sub{ font-size:0.78rem; color:#8aa; letter-spacing:1px; }
        #roulette-modal .ri-filters{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; }
        #roulette-modal .ri-filter{
            padding:10px 12px;
            border-radius: 14px;
            border:1px solid rgba(255,255,255,0.16);
            background: rgba(0,0,0,0.20);
            color:#ddd;
            cursor:pointer;
            font-weight:800;
            letter-spacing:1px;
            transition: transform .12s cubic-bezier(0.4,0,0.2,1), border-color .18s cubic-bezier(0.4,0,0.2,1), box-shadow .18s cubic-bezier(0.4,0,0.2,1), background .18s cubic-bezier(0.4,0,0.2,1);
        }
        #roulette-modal .ri-filter:hover{ transform: translateY(-1px); border-color: rgba(0,229,255,0.35); }
        #roulette-modal .ri-filter.active{
            background: rgba(0,229,255,0.10);
            border-color: rgba(0,229,255,0.50);
            box-shadow: 0 0 18px rgba(0,229,255,0.18);
            color:#fff;
        }

        #roulette-modal .ri-layout{ display:grid; grid-template-columns: 1fr 240px; gap:12px; align-items:start; }
        #roulette-modal .ri-gallery{
            display:grid;
            grid-template-columns: repeat(auto-fill, minmax(148px, 1fr));
            gap:12px;
        }
        #roulette-modal .ri-card{
            position:relative;
            aspect-ratio: 4 / 5;
            border-radius: 18px;
            border:1px solid rgba(255,255,255,0.14);
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22));
            overflow:hidden;
            cursor:pointer;
            transform: translateZ(0);
            transition: transform .14s cubic-bezier(0.4,0,0.2,1), box-shadow .18s cubic-bezier(0.4,0,0.2,1), border-color .18s cubic-bezier(0.4,0,0.2,1);
            box-shadow: 0 16px 34px rgba(0,0,0,0.35);
        }
        #roulette-modal .ri-card::before{
            content:"";
            position:absolute;
            inset:10px;
            border-radius: 14px;
            border:1px solid rgba(255,255,255,0.10);
            pointer-events:none;
        }
        #roulette-modal .ri-card::after{
            content:"";
            position:absolute;
            inset:0;
            background: radial-gradient(circle at 30% 20%, rgba(255,255,255,0.10), transparent 55%);
            pointer-events:none;
            opacity: .9;
        }
        #roulette-modal .ri-card:hover{ transform: translateY(-2px) scale(1.01); }
        #roulette-modal .ri-card.selected{
            transform: translateY(-3px) scale(1.03);
            box-shadow: 0 0 0 1px rgba(255,255,255,0.10), 0 22px 46px rgba(0,0,0,0.48), 0 0 28px var(--ri-glow);
            border-color: color-mix(in srgb, var(--ri-glow) 55%, rgba(255,255,255,0.20));
        }

        /* Glow por raridade (usa --ri-glow) */
        #roulette-modal .ri-card.r-common{ --ri-glow: rgba(150,170,190,0.22); }
        #roulette-modal .ri-card.r-rare{ --ri-glow: rgba(0,229,255,0.24); }
        #roulette-modal .ri-card.r-epic{ --ri-glow: rgba(200,120,255,0.26); }
        #roulette-modal .ri-card.r-legendary{ --ri-glow: rgba(255,215,0,0.26); }
        #roulette-modal .ri-card.r-mythic{ --ri-glow: rgba(255,59,212,0.30); }

        #roulette-modal .ri-card.r-mythic.selected{ animation: riMythicHue 2.6s linear infinite; }
        @keyframes riMythicHue { 0%{ filter:hue-rotate(0deg) saturate(1.2);} 100%{ filter:hue-rotate(360deg) saturate(1.2);} }

        #roulette-modal .ri-card .ri-media{
            height: 46%;
            display:flex;
            align-items:center;
            justify-content:center;
            padding: 12px;
            position:relative;
        }
        #roulette-modal .ri-card img{
            width: 72px;
            height: 72px;
            object-fit: contain;
            opacity: 0;
            transform: translateY(6px) scale(0.98);
            transition: opacity .22s cubic-bezier(0.4,0,0.2,1), transform .22s cubic-bezier(0.4,0,0.2,1);
            filter: drop-shadow(0 12px 18px rgba(0,0,0,0.45));
        }
        #roulette-modal .ri-card img.loaded{ opacity:1; transform: translateY(0) scale(1); }

        #roulette-modal .ri-card .ri-body{
            height: 54%;
            padding: 10px 12px 12px;
            display:flex;
            flex-direction:column;
            gap:8px;
        }
        #roulette-modal .ri-name{
            font-size: 0.92rem;
            font-weight: 900;
            letter-spacing: .4px;
            line-height: 1.1;
            color: #fff;
            text-shadow: 0 10px 22px rgba(0,0,0,0.55);
            display:-webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow:hidden;
        }
        #roulette-modal .ri-meta{
            display:flex;
            justify-content:space-between;
            align-items:center;
            gap:10px;
            margin-top:auto;
        }
        #roulette-modal .ri-rarity{
            font-size: 0.70rem;
            letter-spacing: 2px;
            color: #8aa;
            opacity: .95;
            white-space:nowrap;
        }
        #roulette-modal .ri-rarity b{ color:#eaeaea; font-weight:900; }
        #roulette-modal .ri-type{
            font-size: 0.70rem;
            letter-spacing: 1.5px;
            color:#8aa;
            opacity:.9;
            white-space:nowrap;
        }

        /* Selo exclusivo */
        #roulette-modal .ri-seal{
            position:absolute;
            top:10px;
            right:10px;
            display:flex;
            align-items:center;
            gap:6px;
            padding:6px 8px;
            border-radius: 12px;
            background: rgba(255,215,0,0.14);
            border: 1px solid rgba(255,215,0,0.30);
            color: #ffd166;
            font-size: 0.64rem;
            letter-spacing: 1.5px;
            font-weight: 900;
            text-transform: uppercase;
        }
        #roulette-modal .ri-seal .material-icons{ font-size: 16px; }

        /* Equip button: aparece no selecionado ou hover */
        #roulette-modal .ri-equip{
            margin-top: 6px;
            padding: 10px 10px;
            width: 100%;
            border-radius: 14px;
            background: rgba(0,114,206,0.95);
            border: 1px solid rgba(255,255,255,0.18);
            color: #fff;
            font-weight: 900;
            letter-spacing: 1px;
            box-shadow: 0 16px 30px rgba(0,0,0,0.35);
            opacity: 0;
            transform: translateY(6px);
            transition: opacity .14s cubic-bezier(0.4,0,0.2,1), transform .14s cubic-bezier(0.4,0,0.2,1);
        }
        #roulette-modal .ri-card:hover .ri-equip{ opacity: .85; transform: translateY(0); }
        #roulette-modal .ri-card.selected .ri-equip{ opacity: 1; transform: translateY(0); }
        #roulette-modal .ri-card .ri-equip.ghost{
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.18);
            color:#fff;
        }

        /* Preview lateral */
        #roulette-modal .ri-preview{
            position:sticky;
            top: 0;
            border-radius: 18px;
            border:1px solid rgba(255,255,255,0.14);
            background: rgba(0,0,0,0.18);
            box-shadow: 0 16px 34px rgba(0,0,0,0.35) inset;
            overflow:hidden;
        }
        #roulette-modal .ri-preview-podium{
            padding: 14px 10px 6px;
            display:flex;
            justify-content:center;
            align-items:center;
            background: radial-gradient(circle at 50% 40%, rgba(255,255,255,0.14), transparent 65%);
        }
        #roulette-modal .ri-preview-podium img{
            width: 116px;
            height: 116px;
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.18);
            background: rgba(0,0,0,0.22);
        }
        #roulette-modal .ri-preview-meta{ padding: 10px 12px 12px; display:flex; flex-direction:column; gap:8px; }
        #roulette-modal .ri-preview-name{ font-weight: 900; letter-spacing: .6px; color:#fff; }
        #roulette-modal .ri-preview-rarity{ font-size:0.72rem; letter-spacing:2px; color:#8aa; }
        #roulette-modal .ri-preview-desc{ font-size:0.78rem; line-height:1.35; color:#aaa; }

        @media (max-width: 760px){
            #roulette-modal .ri-layout{ grid-template-columns: 1fr; }
            #roulette-modal .ri-preview{ position:relative; }
        }
@keyframes mythicHue {
            0% { filter: hue-rotate(0deg) saturate(1.2) brightness(1.05); }
            100% { filter: hue-rotate(360deg) saturate(1.2) brightness(1.05); }
        }

        /* Moldura Mítica (avatar): borda arco-íris animada sem mudar o avatar */
        .xs-frame-mythic {
            border: 3px solid #ff3bd4 !important;
            animation: xsRainbowBorder 2.6s linear infinite;
        }
        @keyframes xsRainbowBorder {
            0%   { border-color:#ff004c; box-shadow: 0 0 26px rgba(255,0,76,0.22), 0 0 0 2px rgba(0,0,0,0.35) inset; }
            16%  { border-color:#ffea00; box-shadow: 0 0 26px rgba(255,234,0,0.20), 0 0 0 2px rgba(0,0,0,0.35) inset; }
            33%  { border-color:#00ff99; box-shadow: 0 0 26px rgba(0,255,153,0.20), 0 0 0 2px rgba(0,0,0,0.35) inset; }
            50%  { border-color:#00e5ff; box-shadow: 0 0 26px rgba(0,229,255,0.20), 0 0 0 2px rgba(0,0,0,0.35) inset; }
            66%  { border-color:#7c4dff; box-shadow: 0 0 26px rgba(124,77,255,0.20), 0 0 0 2px rgba(0,0,0,0.35) inset; }
            83%  { border-color:#ff3bd4; box-shadow: 0 0 26px rgba(255,59,212,0.20), 0 0 0 2px rgba(0,0,0,0.35) inset; }
            100% { border-color:#ff004c; box-shadow: 0 0 26px rgba(255,0,76,0.22), 0 0 0 2px rgba(0,0,0,0.35) inset; }
        }


        


    

        

        /* === GUIA DO CONSOLE (HUB) === */
        .guide-modal .modal-header h2{ letter-spacing: 4px; text-transform: uppercase; }
        .guide-wrap{ padding: 10px 8px 18px; }
        .guide-hub{ padding: 6px 6px 14px; }
        .guide-hero{ padding: 12px 12px 16px; border-radius: 18px;
            background: linear-gradient(180deg, rgba(40,100,255,0.18), rgba(0,0,0,0.10));
            border: 1px solid rgba(255,255,255,0.10);
            box-shadow: 0 0 30px rgba(0,210,255,0.10);
        }
        .guide-hero-title{
            font-size: clamp(26px, 4vw, 44px);
            letter-spacing: 12px;
            color: rgba(255,255,255,0.92);
            text-transform: uppercase;
            margin: 4px 0 10px;
        }
        .guide-hero-sub{
            color: rgba(230,245,255,0.80);
            font-size: 0.98rem;
            line-height: 1.35rem;
        }

        .guide-carousel{
            margin-top: 14px;
            display: grid;
            grid-template-columns: 56px 1fr 56px 88px;
            gap: 10px;
            align-items: center;
        }
        .guide-track{
            display: grid;
            grid-auto-flow: column;
            grid-auto-columns: minmax(210px, 1fr);
            gap: 14px;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            padding: 12px 6px;
            border-radius: 18px;
            background: rgba(0,0,0,0.12);
            border: 1px solid rgba(255,255,255,0.08);
        }
        .guide-track::-webkit-scrollbar{ height: 10px; }
        .guide-track::-webkit-scrollbar-thumb{ background: rgba(255,255,255,0.16); border-radius: 99px; }
        .guide-card{
            scroll-snap-align: center;
            position: relative;
            height: min(310px, 40vh);
            min-height: 220px;
            border-radius: 22px;
            background: radial-gradient(circle at 30% 25%, rgba(0,210,255,0.18), rgba(0,0,0,0.10) 60%),
                        linear-gradient(180deg, rgba(20,60,140,0.28), rgba(0,0,0,0.10));
            border: 1px solid rgba(255,255,255,0.10);
            box-shadow: 0 0 30px rgba(0,210,255,0.10);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform .22s cubic-bezier(0.4,0,0.2,1), box-shadow .22s cubic-bezier(0.4,0,0.2,1), border-color .22s;
            cursor: pointer;
            overflow: hidden;
        }
        .guide-card:hover{ transform: translateY(-2px) scale(1.01); box-shadow: 0 0 40px rgba(0,210,255,0.18); }
        .guide-card.selected{
            border-color: rgba(0,210,255,0.55);
            box-shadow: 0 0 55px rgba(0,210,255,0.25);
        }
        .guide-card .gicon{
            width: 58%;
            aspect-ratio: 1 / 1;
            border-radius: 18px;
            background: rgba(0,0,0,0.08);
            border: 1px solid rgba(255,255,255,0.10);
            display:flex; align-items:center; justify-content:center;
            box-shadow: 0 0 40px rgba(0,210,255,0.12);
        }
        .guide-card .gicon span.material-icons{ font-size: clamp(66px, 8vw, 120px); color: rgba(255,255,255,0.92); text-shadow: 0 0 18px rgba(0,210,255,0.35); }
        .guide-card .gicon img{ width: 78%; height: auto; filter: drop-shadow(0 0 16px rgba(0,210,255,0.25)); opacity: 0.92; }
        .guide-card .glabel{
            position: absolute;
            left: 14px; right: 14px; bottom: 12px;
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(0,0,0,0.28);
            border: 1px solid rgba(255,255,255,0.10);
            color: rgba(255,255,255,0.92);
            text-align: center;
            letter-spacing: 2px;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.9rem;
        }
        .guide-nav-btn, .guide-play-btn{
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.18);
            color: rgba(255,255,255,0.92);
            border-radius: 999px;
            height: 60px;
            display:flex; align-items:center; justify-content:center;
            box-shadow: 0 0 25px rgba(0,210,255,0.10);
            transition: transform .18s cubic-bezier(0.4,0,0.2,1), box-shadow .18s, border-color .18s;
        }
        .guide-play-btn{ height: 70px; width: 88px; border-radius: 22px; }
        .guide-nav-btn:hover, .guide-play-btn:hover{ transform: translateY(-1px); border-color: rgba(0,210,255,0.45); box-shadow: 0 0 40px rgba(0,210,255,0.18); }
        .guide-hint{ margin-top: 10px; text-align:center; color: rgba(230,245,255,0.70); font-size: 0.9rem; letter-spacing: 0.6px; }

        /* Reader */
        .guide-reader{ padding: 8px 6px 10px; }
        .guide-reader-top{
            display:grid;
            grid-template-columns: 54px 1fr 54px;
            align-items:center;
            gap: 10px;
            padding: 6px 6px 10px;
        }
        .guide-back-btn, .guide-close-btn, .guide-btn{
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.18);
            color: rgba(255,255,255,0.92);
            border-radius: 16px;
            height: 48px;
            display:flex; align-items:center; justify-content:center;
            box-shadow: 0 0 25px rgba(0,210,255,0.10);
        }
        .guide-reader-title{ text-align:center; }
        .guide-chapter-title{
            font-size: 1.25rem;
            letter-spacing: 3px;
            font-weight: 800;
            color: rgba(255,255,255,0.95);
            text-transform: uppercase;
        }
        .guide-chapter-sub{
            margin-top: 4px;
            font-size: 0.92rem;
            color: rgba(230,245,255,0.72);
        }
        .guide-page{
            margin: 0 6px;
            padding: 14px 14px 10px;
            border-radius: 18px;
            background: rgba(0,0,0,0.12);
            border: 1px solid rgba(255,255,255,0.10);
            max-height: min(58vh, 540px);
            overflow: auto;
        }
        .guide-page h4{
            margin: 0 0 10px;
            color: rgba(255,255,255,0.95);
            letter-spacing: 2px;
            text-transform: uppercase;
            font-size: 1.05rem;
        }
        .guide-page p, .guide-page li{
            color: rgba(230,245,255,0.82);
            line-height: 1.35rem;
            font-size: 0.98rem;
        }
        .guide-page ul{ padding-left: 18px; margin: 10px 0; }
        .guide-callout{
            margin: 12px 0;
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(0,210,255,0.10);
            border: 1px solid rgba(0,210,255,0.20);
            color: rgba(235,250,255,0.92);
        }
        .guide-grid{
            display:grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .guide-figure{
            border-radius: 16px;
            overflow:hidden;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.18);
        }
        .guide-figure img{ width: 100%; height: auto; display:block; }
        .guide-figcap{
            padding: 8px 10px;
            color: rgba(230,245,255,0.78);
            font-size: 0.86rem;
            letter-spacing: 0.4px;
        }
        .guide-reader-nav{
            display:flex;
            align-items:center;
            justify-content:center;
            gap: 12px;
            margin-top: 10px;
        }
        .guide-page-ind{
            padding: 10px 14px;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.16);
            color: rgba(255,255,255,0.92);
            letter-spacing: 2px;
        }

        @media (max-width: 520px){
            .guide-carousel{ grid-template-columns: 52px 1fr 52px 72px; }
            .guide-play-btn{ width: 72px; }
            .guide-hero-title{ letter-spacing: 9px; }
        }
/* === MINIGAME: BIXIN EXPLORADOR (NATIVO) === */
        #dino-game-container { width:100%; height:100%; }
        #dino-canvas { background: transparent; image-rendering: pixelated; touch-action: manipulation; }
        #dino-game-over { pointer-events: auto; }


/* =========================
   XS Responsive Kernel (Device Detection)
   - Classes on <html>: xs-mobile / xs-desktop / xs-gamepad
   ========================= */
html.xs-mobile body{ overflow:hidden; }

/* Top-bar compact on mobile */
html.xs-mobile .top-bar{
  padding: 12px 14px !important;
  gap: 10px;
}
html.xs-mobile .xs-brand{
  font-size: 0.95rem !important;
  letter-spacing: 1px;
  max-width: 52vw;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Secondary widgets hidden on mobile */
.xs-sysbar{ display:none; }
html.xs-desktop .xs-sysbar{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.22);
  box-shadow: 0 0 18px rgba(0,229,255,0.10);
  flex: 1 1 auto;
  min-width: 260px;
  max-width: 58vw;
}
.xs-sysbar .xs-chip{
  display:flex;
  align-items:center;
  gap:6px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.06);
  font-size: 0.78rem;
  color: rgba(255,255,255,0.92);
  white-space: nowrap;
}
.xs-sysbar .material-icons{ font-size: 18px; opacity: 0.95; }
.xs-sysbar .xs-chip strong{ font-weight: 900; letter-spacing: .02em; }

/* Dashboard spacing mobile */
html.xs-mobile .dashboard-content{ padding-top: 16px !important; }
html.xs-mobile .game-info{ padding: 0 18px !important; margin-bottom: 12px !important; height: auto !important; }
html.xs-mobile .carousel-container{ padding-left: 18px !important; }
html.xs-mobile .carousel-track{ gap: 16px !important; }

/* Cards larger + hover richer on desktop */
html.xs-desktop .game-card{
  min-width: clamp(220px, 22vw, 320px) !important;
  height: clamp(220px, 22vw, 320px) !important;
}
@media (hover:hover) and (pointer:fine){
  html.xs-desktop .game-card:hover{
    transform: translateY(-10px) scale(1.06);
    border-color: rgba(0,229,255,0.85);
    box-shadow: 0 26px 70px rgba(0,0,0,0.68), 0 0 24px rgba(0,229,255,0.12);
    z-index: 9;
  }
  html.xs-desktop .game-card.active:hover{
    transform: translateY(-8px) scale(1.12);
  }
}

/* Modals: 95% width on mobile */
html.xs-mobile .modal-overlay{
  align-items: stretch !important;
  justify-content: flex-start !important;
  padding: 10px !important;
}
html.xs-mobile .modal-box{
  width: 95vw !important;
  max-width: 95vw !important;
  padding: 18px 18px !important;
  border-radius: 24px !important;
}

/* Hide manual controls when a gamepad is connected */
html.xs-mobile.xs-gamepad #mobile-controls{ display:none !important; }
html.xs-mobile.xs-gamepad #dino-touch-ui{ display:none !important; }

/* Dino: mobile buttons at bottom extremes; desktop hint */
html.xs-mobile #dino-touch-ui .touch-btn{
  right: calc(10px + env(safe-area-inset-right)) !important;
  bottom: calc(10px + env(safe-area-inset-bottom)) !important;
}
html.xs-mobile #dino-touch-ui .touch-btn-left{
  left: calc(10px + env(safe-area-inset-left)) !important;
  right: auto !important;
}
html.xs-desktop #dino-touch-ui{ display:none !important; }

#dino-kbd-hint{
  position: fixed;
  left: 50%;
  bottom: calc(18px + env(safe-area-inset-bottom));
  transform: translateX(-50%);
  display: none;
  z-index: 2147483646;
  padding: 8px 12px;
  border-radius: 999px;
  border: 1px solid rgba(0,229,255,0.35);
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(8px);
  color: rgba(255,255,255,0.95);
  font-weight: 800;
  letter-spacing: 0.06em;
  font-size: 0.78rem;
  text-transform: uppercase;
  box-shadow: 0 0 18px rgba(0,229,255,0.16);
}
#dino-kbd-hint.show{ display:block; }

/* Device toast */
#device-toast{
  position: fixed;
  left: 18px;
  bottom: 18px;
  z-index: 2147483647;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 14px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(0,0,0,0.58);
  backdrop-filter: blur(10px);
  box-shadow: 0 18px 45px rgba(0,0,0,0.45), 0 0 24px rgba(0,229,255,0.12);
  transform: translateY(16px);
  opacity: 0;
  pointer-events: none;
  transition: opacity .25s ease, transform .25s ease;
}
#device-toast.show{
  opacity: 1;
  transform: translateY(0);
}
#device-toast .material-icons{
  font-size: 1.6rem;
  color: var(--ps-glow);
  text-shadow: 0 0 14px rgba(0,229,255,0.45);
}
#device-toast h4{
  margin: 0;
  font-size: 0.78rem;
  letter-spacing: 0.14em;
  opacity: 0.9;
}
#device-toast p{
  margin: 2px 0 0 0;
  font-size: 0.90rem;
  font-weight: 900;
  color: #eaffff;
}

/* =========================
   XS UI/UX HOTFIX (2026-01)
   - Full-bleed layout (remove black borders)
   - Native horizontal scroll + centered selection
   ========================= */
html, body{
  width:100%;
  height:100%;
  margin:0 !important;
  padding:0 !important;
  overflow:hidden;
  background:#000;
}
#main-ui, #intro-layer, #brightness-layer{
  width:100vw;
  height:100vh;
}

/* Carousel: snap + center friendly */
.carousel-container{
  scroll-padding: 20px;
  scroll-padding-inline: 20px;
  scrollbar-gutter: stable both-edges;
}
.carousel-container::-webkit-scrollbar{ height: 10px; }
.carousel-container::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,0.18);
  border-radius: 999px;
  border: 2px solid rgba(0,0,0,0.25);
}
.game-card{
  flex: 0 0 auto;
  scroll-snap-align: center;
}

/* XS PATCH: MOBILE MODAL FIX (texto/fechar sem cortar) */
        @media (max-width: 900px) {
            .modal-overlay { align-items: stretch; justify-content: flex-start; padding: 14px; }
            .modal-box { width: 100%; max-width: 100%; padding: 18px 18px; border-radius: 24px; }
            .modal-header h2 { font-size: 1.6rem; }
            .tut-icon { font-size: 3.6rem; margin-bottom: 12px; }
            .tut-title { font-size: 1.1rem; margin-bottom: 10px; }
            .tut-desc { font-size: 0.95rem; }
        }

/* === Dino Touch UI (aparece só no modo toque) === */
#dino-touch-ui{
  position:absolute; inset:0;
  pointer-events:none;
  display:none;
  z-index:2147483000;
}
#dino-touch-ui .touch-btn{
  pointer-events:auto !important;
  position:fixed;               /* FIX: eventos mais confiáveis no mobile */
  right:calc(18px + env(safe-area-inset-right));
  bottom:calc(18px + env(safe-area-inset-bottom));
  width:120px;
  height:84px;
  border-radius:18px;
  background:rgba(0,229,255,0.14);
  border:2px solid rgba(0,229,255,0.65);
  box-shadow:0 0 18px rgba(0,229,255,0.45), inset 0 0 18px rgba(0,229,255,0.18);
  display:grid;
  place-items:center;
  user-select:none; -webkit-user-select:none;
  -webkit-touch-callout:none;
  -webkit-tap-highlight-color: transparent;
  touch-action:none;            /* FIX: evita gestos/scroll interferirem */
  z-index:2147483647;           /* acima de tudo */
}
#dino-touch-ui .touch-btn-left{
  left:calc(18px + env(safe-area-inset-left)); right:auto;
  background:rgba(255,45,110,0.12);
  border-color:rgba(255,45,110,0.60);
  box-shadow:0 0 18px rgba(255,45,110,0.35), inset 0 0 18px rgba(255,45,110,0.14);
}
#dino-touch-ui .touch-btn:active{
  transform:scale(0.98);
  background:rgba(0,229,255,0.22);
  box-shadow:0 0 26px rgba(0,229,255,0.75), inset 0 0 18px rgba(0,229,255,0.22);
}
#dino-touch-ui .touch-btn-left:active{
  background:rgba(255,45,110,0.20);
  box-shadow:0 0 26px rgba(255,45,110,0.65), inset 0 0 18px rgba(255,45,110,0.22);
}
#dino-touch-ui .touch-btn span{
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  font-weight:900;
  font-size:18px;
  letter-spacing:0.08em;
  color:rgba(255,255,255,0.95);
  text-shadow:0 0 12px rgba(0,229,255,0.9);
}
#dino-touch-ui .touch-btn-left span{
  text-shadow:0 0 12px rgba(255,45,110,0.85);
}
@media (max-width:520px){
  #dino-touch-ui .touch-btn{
    width:108px; height:78px; border-radius:16px;
    right:14px; bottom:14px;
  }
  #dino-touch-ui .touch-btn-left{ left:14px; }
  #dino-touch-ui .touch-btn span{ font-size:16px; }
}
#dino-canvas{ touch-action:none; -webkit-user-select:none; user-select:none; }

    /* Coin fly animation (game over conversion) */
    .coinFly{
        position:absolute;
        width:14px; height:14px;
        border-radius:50%;
        background: radial-gradient(circle at 35% 30%, rgba(255,255,255,0.95), rgba(255,215,0,0.95) 35%, rgba(255,165,0,0.92) 70%, rgba(255,120,0,0.85));
        box-shadow: 0 0 16px rgba(255,215,0,0.70), 0 0 26px rgba(0,229,255,0.35);
        opacity:0;
        will-change: transform, opacity;
    }

        /* === JUKEBOX (loop) === */
        .jb2-wrap{ display:flex; flex-direction:column; gap:12px; }
        .jb2-top{ display:flex; gap:12px; flex-wrap:wrap; justify-content:space-between; align-items:flex-start; }
        .jb2-now{ flex:1; min-width:220px; padding:12px 14px; border-radius:18px;
            background:rgba(0,0,0,0.20); border:1px solid rgba(255,255,255,0.10);
            box-shadow:0 0 18px rgba(0,229,255,0.10); }
        .jb2-label{ font-size:0.72rem; color:#8aa; letter-spacing:0.08em; }
        .jb2-title{ margin-top:6px; font-size:1.08rem; color:var(--ps-glow); text-shadow:0 0 12px rgba(0,229,255,0.25); font-weight:900; }
        .jb2-sub{ margin-top:8px; font-size:0.80rem; color:#b9b9b9; line-height:1.25; }
        .jb2-controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
        .jb2-btn{ width:46px; height:46px; border-radius:16px; border:1px solid rgba(255,255,255,0.12);
            background:rgba(0,229,255,0.10); color:#fff; cursor:pointer; font-size:1.05rem;
            box-shadow:0 0 14px rgba(0,229,255,0.14); }
        .jb2-btn:hover{ background:rgba(0,229,255,0.16); }
        .jb2-btn.main{ width:58px; height:58px; border-radius:20px; background:rgba(0,229,255,0.18); border-color:rgba(0,229,255,0.65); }
        .jb2-vol{ display:flex; align-items:center; gap:10px; padding:10px 12px; border-radius:16px;
            background:rgba(0,0,0,0.18); border:1px solid rgba(255,255,255,0.10); }
        #jb2Vol{ width:140px; }
        .jb2-list{ margin-top:6px; max-height:280px; overflow:auto; border-radius:16px;
            border:1px solid rgba(255,255,255,0.10); background:rgba(0,0,0,0.18); }
        .jb2-row{ display:flex; justify-content:space-between; align-items:center; gap:10px;
            padding:10px 12px; cursor:pointer; border-bottom:1px solid rgba(255,255,255,0.06); }
        .jb2-row:last-child{ border-bottom:none; }
        .jb2-row:hover{ background:rgba(0,229,255,0.06); }
        .jb2-row.active{ background:rgba(0,229,255,0.10); outline:1px solid rgba(0,229,255,0.22); }
        .jb2-row .meta{ font-size:0.78rem; color:#9aa; opacity:0.9; }
        @media (max-width: 540px){
          .jb2-controls{ justify-content:flex-start; }
          #jb2Vol{ width:120px; }
        }
    


        /* === JUKEBOX YT SIDELOAD === */
        .jb2-section{ padding:10px 12px; background:rgba(255,255,255,0.04); border-bottom:1px solid rgba(255,255,255,0.08);
            font-size:0.72rem; color:#9aa; letter-spacing:0.12em; text-transform:uppercase; display:flex; justify-content:space-between; align-items:center; gap:10px; }
        .jb2-badge{ font-size:0.70rem; padding:2px 10px; border-radius:999px; border:1px solid rgba(0,229,255,0.35); background:rgba(0,229,255,0.10); color:#cfffff; white-space:nowrap; }
        .jb2-row-left{ display:flex; gap:10px; align-items:center; min-width:0; flex:1; }
        .jb2-thumb{ width:42px; height:42px; border-radius:12px; object-fit:cover; border:1px solid rgba(255,255,255,0.18);
            box-shadow:0 0 12px rgba(0,229,255,0.12); flex:0 0 auto; background:rgba(0,0,0,0.22); }
        .jb2-title2{ font-weight:900; color:#fff; font-size:0.92rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 520px; }
        .jb2-yt-input{ width:100%; padding:12px 14px; border-radius:16px; border:1px solid rgba(0,229,255,0.35);
            background:rgba(0,0,0,0.45); color:#fff; outline:none;
            box-shadow:0 0 18px rgba(0,229,255,0.10), inset 0 0 14px rgba(0,229,255,0.06); }
        .jb2-yt-input:focus{ border-color: rgba(0,229,255,0.75);
            box-shadow:0 0 24px rgba(0,229,255,0.18), inset 0 0 16px rgba(0,229,255,0.08); }
        .jb2-yt-actions{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
        .jb2-yt-actions .game-btn{ flex:1 1 220px; }


/* ===== CLOUD MEMORY (contas/vínculo) ===== */
.avatar-plus{
  width:56px; height:56px; border-radius:14px;
  display:flex; align-items:center; justify-content:center;
  border:1px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0.35);
  box-shadow: 0 0 18px rgba(0,255,255,0.18), inset 0 0 10px rgba(255,255,255,0.06);
  cursor:pointer;
  transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
}
.avatar-plus:hover{ transform: translateY(-2px); border-color: rgba(0,255,255,0.55); box-shadow: 0 0 22px rgba(0,255,255,0.28), inset 0 0 12px rgba(255,255,255,0.08); }
.avatar-plus .material-icons{ font-size: 30px; color: var(--ps-glow); text-shadow: 0 0 10px rgba(0,255,255,0.55); }

.cloud-tabs{ display:flex; gap:10px; margin: 10px 0 14px; }
.cloud-tab{
  flex:1;
  padding:10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(0,0,0,0.25);
  color:#ddd;
  cursor:pointer;
  font-weight:700;
  letter-spacing: .5px;
}
.cloud-tab.active{
  border-color: rgba(0,255,255,0.55);
  box-shadow: 0 0 18px rgba(0,255,255,0.18);
  color: #fff;
}
.cloud-form .row{ display:flex; gap:10px; flex-wrap:wrap; }
.cloud-form input{
  flex: 1 1 220px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0.35);
  color: #fff;
  outline:none;
}
.cloud-mini{
  font-size: 0.82rem;
  color: #9aa;
  margin: 8px 0 10px;
  line-height: 1.25rem;
}
.cloud-actions{ display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
.cloud-actions .game-btn{ flex: 1 1 220px; }


        /* YT Audio activation helper (WebView-friendly) */
        #jb2-yt-activator{
            position:fixed; inset:0; display:none; align-items:center; justify-content:center;
            background:rgba(0,0,0,0.78); z-index:999999;
        }
        #jb2-yt-activator .panel{
            width:min(92vw, 420px);
            border-radius:22px;
            border:1px solid rgba(0,229,255,0.35);
            background:rgba(0,0,0,0.65);
            box-shadow:0 0 30px rgba(0,229,255,0.20);
            padding:16px;
        }
        #jb2-yt-activator .title{
            font-weight:900; letter-spacing:.08em; text-transform:uppercase;
            color:#e8fbff; font-size:12px; opacity:.85;
        }
        #jb2-yt-activator .desc{ margin-top:8px; color:rgba(255,255,255,0.78); font-size:13px; line-height:1.35; }
        #jb2-yt-activator .frameWrap{
            margin-top:12px;
            border-radius:16px; overflow:hidden;
            border:1px solid rgba(255,255,255,0.10);
            background:rgba(0,0,0,0.35);
        }
        #jb2-yt-activator .actions{
            display:flex; gap:10px; justify-content:flex-end; margin-top:12px;
        }
        #jb2-yt-activator .btn{
            padding:10px 14px; border-radius:14px; cursor:pointer;
            border:1px solid rgba(255,255,255,0.12);
            background:rgba(0,0,0,0.35);
            color:#fff;
        }
        #jb2-yt-activator .btn.primary{
            border-color:rgba(0,229,255,0.55);
            background:rgba(0,229,255,0.12);
        }


/* =========================
   XS MUSIC BROWSER (Ouvirmusica)
   - Minimize keeps iframe alive for background music
   ========================= */
#xsOpenMusicBrowserBtn.xs-music-open{
  background:linear-gradient(90deg, rgba(0,229,255,0.22), rgba(155,89,255,0.18));
  border:1px solid rgba(0,229,255,0.35);
  box-shadow:0 0 18px rgba(0,229,255,0.18);
}
#xs-music-browser{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  padding:12px;
  z-index:999999;
  background:rgba(0,0,0,0.55);
  backdrop-filter: blur(6px);
}
#xs-music-browser .xs-music-window{
  width:min(96vw, 980px);
  height:min(78vh, 720px);
  border-radius:18px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,0.18);
  box-shadow:0 0 26px rgba(0,229,255,0.22);
  background:rgba(12,14,18,0.98);
  display:flex;
  flex-direction:column;
}
#xs-music-browser .xs-music-bar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:10px 12px;
  background:rgba(255,255,255,0.06);
  border-bottom:1px solid rgba(255,255,255,0.12);
}
#xs-music-browser .xs-music-title{
  display:flex;
  align-items:center;
  gap:8px;
  font-weight:900;
  letter-spacing:0.3px;
  color:#fff;
  font-size:0.95rem;
}
#xs-music-browser .xs-music-actions{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  justify-content:flex-end;
}
#xs-music-browser .xs-music-frameSlot{
  flex:1;
  min-height:0;
  background:#000;
}
#xs-music-browser iframe{
  width:100%;
  height:100%;
  border:0;
  display:block;
}

/* Fullscreen + portrait mode for XS Music Browser */
#xs-music-browser.is-fullscreen{
  padding:0;
  background:#000;
  backdrop-filter:none;
}
#xs-music-browser.is-fullscreen .xs-music-window{
  width:100vw;
  height:100vh;
  border-radius:0;
  border:0;
  box-shadow:none;
}
#xs-music-browser.is-fullscreen .xs-music-bar{
  padding: max(10px, env(safe-area-inset-top)) 12px 10px;
}
#xs-music-browser.is-fullscreen .xs-music-frameSlot{
  padding-bottom: env(safe-area-inset-bottom);
}

/* If device is landscape but we want a vertical (portrait) experience, rotate the window */
#xs-music-browser.is-fullscreen.force-portrait .xs-music-window{
  position:absolute;
  left:50%;
  top:50%;
  width:100vh;
  height:100vw;
  transform: translate(-50%, -50%) rotate(90deg);
  transform-origin:center;
}
#xs-music-browser.is-fullscreen.force-portrait .xs-music-bar{
  padding: 10px 12px;
}
/* Minimized: move off-screen but keep iframe alive (music keeps playing) */
#xs-music-browser.minimized{
  background:transparent;
  backdrop-filter:none;
  pointer-events:none;
}
#xs-music-browser.minimized .xs-music-window{
  transform:translateY(140vh);
  opacity:0;
  pointer-events:none;
}
@media (max-width: 520px){
  #xs-music-browser .xs-music-window{
    width:96vw;
    height:82vh;
    border-radius:16px;
  }
}

/* View toggle (Vertical / Horizontal) */
#xs-music-browser .xs-music-viewtoggle{
  display:flex;
  align-items:center;
  gap:6px;
  padding:4px;
  border-radius:999px;
  background:rgba(0,0,0,0.28);
  border:1px solid rgba(255,255,255,0.14);
}
#xs-music-browser .xs-music-viewtoggle button{
  border:0;
  background:transparent;
  color:rgba(255,255,255,0.82);
  font-weight:900;
  letter-spacing:0.2px;
  padding:6px 10px;
  border-radius:999px;
  cursor:pointer;
}
#xs-music-browser .xs-music-viewtoggle button.active{
  background:rgba(0,229,255,0.18);
  border:1px solid rgba(0,229,255,0.32);
  color:#fff;
  box-shadow:0 0 16px rgba(0,229,255,0.18);
}

/* If device is portrait but we want a horizontal (landscape) experience, rotate the window */
#xs-music-browser.is-fullscreen.force-landscape .xs-music-window{
  position:absolute;
  left:50%;
  top:50%;
  width:100vh;
  height:100vw;
  transform: translate(-50%, -50%) rotate(-90deg);
  transform-origin:center;
}
#xs-music-browser.is-fullscreen.force-landscape .xs-music-bar{
  padding: 10px 12px;
}

/* ===== XS AVATAR CUSTOMIZER (SCOPED) ===== */
/* Tudo aqui é escopado ao #profile-modal para NÃO afetar #intro-layer / #main-ui */
#profile-modal .profile-preview{ position:relative; }
#profile-modal .profile-preview::after{
  content:"";
  position:absolute;
  width:160px; height:160px;
  top:50%; left:50%;
  transform:translate(-50%,-50%);
  border-radius:50%;
  background: radial-gradient(circle at center, rgba(255,255,255,0.14) 0%, transparent 70%);
  pointer-events:none;
  z-index:0;
}
#profile-modal #current-avatar-edit{ position:relative; z-index:1; }

#profile-modal .xsav-tabs{
  display:flex;
  gap:8px;
  margin: 6px 0 12px;
}
#profile-modal .xsav-tab{
  flex:1;
  border-radius:14px;
  padding:10px 12px;
  border:1px solid rgba(255,255,255,0.16);
  background: rgba(255,255,255,0.06);
  color:#8aa;
  font-weight:800;
  letter-spacing:1px;
  cursor:pointer;
  transition: transform .18s cubic-bezier(0.4,0,0.2,1), background .18s cubic-bezier(0.4,0,0.2,1), color .18s cubic-bezier(0.4,0,0.2,1), border-color .18s cubic-bezier(0.4,0,0.2,1);
}
#profile-modal .xsav-tab:active{ transform: scale(0.98); }
#profile-modal .xsav-tab.is-active{
  color:#fff;
  background: rgba(0,229,255,0.12);
  border-color: rgba(0,229,255,0.45);
  box-shadow: 0 0 18px rgba(0,229,255,0.16);
}

#profile-modal .xsav-pane{ position:relative; min-height: 220px; }
#profile-modal .xsav-panel{
  display:none;
  opacity:0;
  transform: translateX(16px);
  transition: opacity .22s ease, transform .35s cubic-bezier(0.4,0,0.2,1);
}
#profile-modal .xsav-panel.is-active{
  display:block;
  opacity:1;
  transform: translateX(0);
}

#profile-modal .xsav-row{
  display:grid;
  grid-template-columns: 110px 44px minmax(0,1fr) 44px;
  align-items:center;
  gap:10px;
  padding:10px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  box-shadow: 0 12px 30px rgba(0,0,0,0.25);
  margin-bottom: 8px;
}
#profile-modal .xsav-label{
  font-size: .75rem;
  letter-spacing: 1px;
  color:#8aa;
  white-space: nowrap;
  overflow:hidden;
  text-overflow: ellipsis;
}
#profile-modal .xsav-pill{
  font-size: .82rem;
  color:#eaeaea;
  background: rgba(0,0,0,0.26);
  border:1px solid rgba(255,255,255,0.12);
  border-radius: 14px;
  padding:8px 10px;
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap:10px;
  min-width:0;
  white-space: nowrap;
  overflow:hidden;
  text-overflow: ellipsis;
}
#profile-modal .xsav-arrow{
  width:44px;
  height:40px;
  border-radius:16px;
  background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
  border:1px solid rgba(255,255,255,0.20);
  box-shadow: 0 6px 18px rgba(0,0,0,0.35);
  display:flex;
  align-items:center;
  justify-content:center;
}
#profile-modal .xsav-arrow .material-icons{ font-size:24px; }

#profile-modal .xsav-tip{
  font-size: .74rem;
  color:#8aa;
  margin: 0 0 10px;
  letter-spacing: .6px;
  text-align:right;
}

#profile-modal .xsav-toggle{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap:10px;
  padding:10px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.05);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  box-shadow: 0 12px 30px rgba(0,0,0,0.22);
  margin-bottom: 8px;
}
#profile-modal .xsav-toggle .xsav-label{ color:#cfcfcf; }

#profile-modal .xsav-toggle-btn{
  padding: 10px 16px;
  border-radius: 16px;
  background: rgba(0,55,145,0.38);
  border: 1px solid rgba(255,255,255,0.22);
  box-shadow: 0 10px 25px rgba(0,0,0,0.25) inset;
  font-weight: 800;
  letter-spacing: .8px;
}

#profile-modal .xsav-footer{ margin-top:10px; display:flex; flex-direction:column; gap:10px; }

@media (max-width: 420px){
  #profile-modal .xsav-row{
    grid-template-columns: 92px 40px minmax(0,1fr) 40px;
    gap:8px;
    padding:8px;
    border-radius:14px;
  }
  #profile-modal .xsav-arrow{ width:40px; height:38px; border-radius:14px; }
  #profile-modal .xsav-arrow .material-icons{ font-size:22px; }
  #profile-modal .xsav-pill{ font-size:.78rem; padding:7px 8px; border-radius:12px; }
  #profile-modal .xsav-tab{ padding:8px 10px; font-size:.8rem; }
}
/* ===== /XS AVATAR CUSTOMIZER (SCOPED) ===== */


/* =========================
   XS DRIVE (Virtual File System)
   - Neomorfismo / Glassmorphism friendly
   ========================= */
.xs-drive-box{ max-width: 980px; }
.xs-drive{
  margin-top: 12px;
  display: grid;
  grid-template-columns: 320px 1fr;
  gap: 14px;
  min-height: 520px;
}
@media (max-width: 900px){
  .xs-drive{ grid-template-columns: 1fr; min-height: 560px; }
}
.xs-drive-sidebar, .xs-drive-editor{
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
  border-radius: 22px;
  box-shadow: 0 10px 28px rgba(0,0,0,0.25), inset 0 0 24px rgba(255,255,255,0.05);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  overflow: hidden;
}
.xs-drive-bar{
  padding: 12px 12px 10px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
}
.xs-drive-crumb{
  display:flex; flex-wrap:wrap; gap:6px;
  align-items:center;
  font-size: 0.86rem;
  color: #cfd6e6;
}
.xs-drive-crumb .xs-crumb{
  cursor:pointer;
  padding: 4px 10px;
  border-radius: 999px;
  background: rgba(0,0,0,0.22);
  border: 1px solid rgba(255,255,255,0.10);
}
.xs-drive-crumb .xs-crumb:hover{ filter: brightness(1.08); }
.xs-drive-crumb .xs-sep{ opacity:0.6; padding: 0 2px; }
.xs-drive-actions{
  display:flex; flex-wrap:wrap;
  gap: 8px;
}
.xs-drive-actions .game-btn{
  padding: 9px 11px;
  font-size: 0.82rem;
  border-radius: 14px;
}
.xs-drive-list{
  padding: 10px 10px 14px;
  max-height: 420px;
  overflow:auto;
}
@media (max-width: 900px){
  .xs-drive-list{ max-height: 250px; }
}
.xs-drive-item{
  display:flex; align-items:center; gap:10px;
  padding: 10px 12px;
  margin: 7px 0;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.18);
  cursor:pointer;
  transition: transform .08s ease, filter .08s ease;
}
.xs-drive-item:hover{ filter: brightness(1.06); transform: translateY(-1px); }
.xs-drive-item.active{
  background: rgba(0,229,255,0.12);
  border-color: rgba(0,229,255,0.35);
  box-shadow: inset 0 0 18px rgba(0,229,255,0.08);
}
.xs-drive-item .material-icons{ opacity: 0.95; }
.xs-drive-item .meta{ margin-left:auto; display:flex; gap:8px; opacity:0.72; font-size: 0.78rem; }
.xs-drive-item .tag{
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.05);
}
.xs-drive-editor-top{
  padding: 12px 12px 10px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
  display:flex; align-items:center; justify-content: space-between; gap: 10px;
}
.xs-drive-title{
  display:flex; flex-direction:column;
  gap: 2px;
}
.xs-drive-title .t1{ font-size: 0.98rem; color: #e9f0ff; font-weight: 800; letter-spacing: .2px; }
.xs-drive-title .t2{ font-size: 0.78rem; color: #aab5cf; opacity: .95; }
.xs-drive-editor-actions{ display:flex; gap: 8px; flex-wrap:wrap; justify-content:flex-end; }
.xs-drive-editor-actions .game-btn{ padding: 9px 11px; font-size: 0.82rem; border-radius: 14px; }
.xs-drive-textarea{
  width:100%;
  min-height: 360px;
  resize: none;
  padding: 14px 14px;
  border: 0;
  outline: none;
  color: #e9f0ff;
  background: transparent;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.92rem;
  line-height: 1.35;
}
@media (max-width: 900px){
  .xs-drive-textarea{ min-height: 240px; }
}
.xs-drive-meta{
  padding: 10px 14px 14px;
  border-top: 1px solid rgba(255,255,255,0.10);
  font-size: 0.78rem;
  color: #aab5cf;
  display:flex;
  justify-content: space-between;
  gap: 10px;
  flex-wrap: wrap;
}
.xs-drive-meta .pill{
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.18);
}
.xs-drive-prompt{
  position: fixed;
  inset: 0;
  z-index: 2147483005;
  display:none;
  align-items:center;
  justify-content:center;
  padding: 18px;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}
.xs-drive-prompt .box{
  width: min(520px, 100%);
  border-radius: 22px;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.14);
  box-shadow: 0 16px 40px rgba(0,0,0,0.35), inset 0 0 26px rgba(255,255,255,0.06);
  padding: 14px;
}
.xs-drive-prompt .hdr{
  display:flex; align-items:center; justify-content:space-between;
  gap: 10px;
  padding: 4px 6px 10px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
}
.xs-drive-prompt .hdr .h{
  display:flex; gap:10px; align-items:center;
}
.xs-drive-prompt .hdr .h b{ color:#e9f0ff; }
.xs-drive-prompt .body{ padding: 12px 6px 6px; }
.xs-drive-prompt input, .xs-drive-prompt textarea{
  width: 100%;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(0,0,0,0.20);
  color: #e9f0ff;
  padding: 12px 12px;
  outline: none;
}
.xs-drive-prompt textarea{ min-height: 140px; resize: vertical; }
.xs-drive-prompt .btns{
  display:flex; gap: 10px; justify-content:flex-end;
  padding: 10px 6px 2px;
}
.xs-drive-prompt .btns .game-btn{ border-radius: 14px; padding: 10px 12px; }
</style>
</head>
<body onclick="startAudioEngine()">
    <div id="brightness-layer"></div>

    <div id="achievement-toast">
        <span class="material-icons" id="toast-icon" style="color: #ffd700; font-size: 2rem;">emoji_events</span>
        <div><h4 id="toast-title" style="margin:0; color: #ffd700;">CONQUISTA!</h4><p id="toast-msg" style="margin:0; font-size: 0.9rem;">Mensagem aqui</p></div>
        <div id="toast-reward" style="background: #333; padding: 5px 10px; border-radius: 10px; font-weight: bold; display:none;"></div>
    </div>


    <div id="device-toast" aria-live="polite" aria-atomic="true">
        <span class="material-icons" id="device-toast-icon">devices</span>
        <div>
            <h4 id="device-toast-title">RESPONSIVE KERNEL</h4>
            <p id="device-toast-msg">---</p>
        </div>
    </div>

    <div id="intro-layer"></div>

    <div id="user-select-layer">
        <h1 style="margin-bottom: 30px; font-weight: 100; letter-spacing: 5px;">XUXUBISTATION XS</h1>
        <div class="user-grid">
            <div class="user-card selected" onclick="confirmUser(0)" id="mu0"><div class="avatar" id="av0"></div><p id="name0">xuxubitus</p></div>
            <div class="user-card" onclick="confirmUser(1)" id="mu1"><div class="avatar" id="av1"></div><p id="name1">bububis</p></div>
        </div>
    
        <div style="margin-top:18px; display:flex; justify-content:center; gap:14px; flex-wrap:wrap;">
            <button class="game-btn" style="height:52px; padding:0 18px; border-radius:18px; background:rgba(0,229,255,0.14); border:1px solid rgba(0,229,255,0.45); box-shadow:0 14px 34px rgba(0,0,0,0.35) inset;"
                onclick="openModal('create-modal'); playSysSound(760,'square',0.12);">
                <span class="material-icons" style="font-size:1.15rem; vertical-align:middle; margin-right:8px;">add</span>CRIAR
            </button>
        </div>
</div>

    <div id="main-ui">
        <div class="top-bar">
            <div class="xs-brand" onclick="sideloadGame()">XUXUBISTATION XS <span style="color:var(--ps-glow)">| TITANIUM</span></div>
            <div class="xs-sysbar" id="xs-sysbar" aria-label="Dashboard">
                <div class="xs-chip" title="Relógio"><span class="material-icons">schedule</span><strong id="xsClock">--:--:--</strong></div>
                <div class="xs-chip" title="Bateria"><span class="material-icons" id="xsBatIcon">battery_full</span><strong id="xsBat">--%</strong></div>
                <div class="xs-chip" title="XP"><span class="material-icons">stars</span><strong id="xsXP">--</strong></div>
                <div class="xs-chip" title="Rádio"><span class="material-icons" id="xsRadioIcon">radio</span><strong id="xsRadio">OFF</strong></div>
            </div>

            <div class="user-section">
                <div class="coin-display"><span class="material-icons" style="font-size:1rem">monetization_on</span> <span id="coin-val">0</span></div>
                <div id="user-display" onclick="openProfileEditor()">---</div>
            </div>
        </div>
        <div class="dashboard-content">
            <div class="game-info"><h1 id="game-title">---</h1></div>
            <div class="carousel-container"><div class="carousel-track" id="track"></div></div>
        </div>
    </div>

    <div id="sideload-folder-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header"><h2>MINHA PASTA DE JOGOS</h2><button class="game-btn" onclick="closeModal('sideload-folder-modal')">X</button></div>
            <div id="folder-empty-msg" style="text-align: center; color: #666; padding: 20px;">Pasta vazia. Use o modo Sideload para adicionar URLs.</div>
            <div class="sideload-list" id="sideload-list"></div>
        </div>
    </div>

    <div id="profile-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header"><h2>DEFINIÇÕES DE JOGADOR</h2></div>
            <div class="profile-editor-layout">
                <div class="profile-preview"><img id="current-avatar-edit" src=""><input type="text" id="new-name" maxlength="12" class="name-input" placeholder="Seu nome"></div>
                <div class="profile-controls">
                    <p style="font-size:0.8rem; color:var(--ps-glow); margin-bottom:10px;">ESCOLHA UM PERFIL</p>
                    <div id="avatar-grid" class="avatar-grid-7"></div>
                    <button class="game-btn" style="width:100%; background:var(--ps-blue); margin-top:10px;" onclick="saveProfile()">SALVAR ALTERAÇÕES</button>
                </div>
            </div>
        </div>
    </div>


    
    <!-- XS MEMORY CARD MODALS (V2) -->
    <div id="xs-memory-export-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header">
                <h2>GRAVAR MEMORY CARD</h2>
                <button class="game-btn" onclick="closeModal('xs-memory-export-modal')">X</button>
            </div>
            <div style="padding:12px 10px;">
                <div style="font-size:0.85rem; color:#aaa; margin-bottom:12px; line-height:1.35;">
                    Escolha qual perfil você quer gravar. Dica: <b>CONSOLE COMPLETO</b> inclui todos os perfis.
                </div>
                <div id="xs-memory-export-list" style="display:flex; flex-direction:column; gap:10px;"></div>
            </div>
        </div>
    </div>

    <div id="xs-memory-import-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header">
                <h2>IMPORTAR MEMORY CARD</h2>
                <button class="game-btn" onclick="__xsCancelImport__()">X</button>
            </div>
            <div style="padding:12px 10px;">
                <div id="xs-memory-import-summary" style="font-size:0.88rem; color:#ddd; line-height:1.35; margin-bottom:12px;"></div>
                <div style="display:flex; gap:10px;">
                    <button class="game-btn" style="flex:1; background:rgba(0,229,255,0.14); border:1px solid rgba(0,229,255,0.35);" onclick="__xsConfirmImport__()">
                        <span class="material-icons" style="vertical-align:middle; margin-right:8px;">system_update_alt</span>IMPORTAR
                    </button>
                    <button class="game-btn" style="flex:1; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.18);" onclick="__xsCancelImport__()">
                        <span class="material-icons" style="vertical-align:middle; margin-right:8px;">close</span>CANCELAR
                    </button>
                </div>
                <div style="margin-top:10px; font-size:0.78rem; color:#aaa;">
                    Aviso: isso sobrescreve seu save atual. Um backup interno será guardado para emergência.
                </div>
            </div>
        </div>
    </div>
<div id="cloud-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header">
                <h2>MEMÓRIA CLOUD</h2>
                <button class="game-btn" onclick="closeModal('cloud-modal')">X</button>
            </div>

            <div class="cloud-mini">
                <b>Objetivo:</b> criar/vincular um usuário pra levar <b>suas moedas XC, compras, configs e progresso</b> pra outro console.<br>
                <span style="color:#b88;">Obs:</span> isso usa um "banco" externo (JSONBin). Você só precisa colar sua <b>API Key</b> e (se já tiver) o <b>Bin ID</b>.
            </div>

            <div class="cloud-form" style="margin-bottom:10px;">
                <div class="row">
                    <input id="cloudApiKey" type="password" placeholder="JSONBin API Key (X-Master-Key)">
                    <input id="cloudBinId" type="text" placeholder="Bin ID (opcional, pode criar aqui)">
                </div>
                <div class="cloud-actions">
                    <button class="game-btn" onclick="cloudSaveConfig()">SALVAR CONFIG</button>
                    <button class="game-btn" onclick="cloudCreateDb()">CRIAR BANCO CLOUD</button>
                    <button class="game-btn" onclick="cloudPullNow()">BAIXAR DO CLOUD</button>
                </div>
            </div>

            <div class="cloud-tabs">
                <button id="cloudTabCreate" class="cloud-tab active" onclick="cloudSwitchTab('create')">CRIAR CONTA</button>
                <button id="cloudTabLink" class="cloud-tab" onclick="cloudSwitchTab('link')">VINCULAR CONTA</button>
            </div>

            <div id="cloudPaneCreate">
                <div class="cloud-form">
                    <div class="row">
                        <input id="cloudUserCreate" type="text" maxlength="16" placeholder="Nome de usuário (ex: zuera)">
                        <input id="cloudPassCreate" type="password" maxlength="32" placeholder="Senha">
                    </div>
                    <div class="cloud-actions">
                        <button class="game-btn" onclick="cloudCreateAccount()">CRIAR E VINCULAR</button>
                    </div>
                </div>
            </div>

            <div id="cloudPaneLink" style="display:none;">
                <div class="cloud-form">
                    <div class="row">
                        <input id="cloudUserLink" type="text" maxlength="16" placeholder="Nome de usuário">
                        <input id="cloudPassLink" type="password" maxlength="32" placeholder="Senha">
                    </div>
                    <div class="cloud-actions">
                        <button class="game-btn" onclick="cloudLinkAccount()">VINCULAR E BAIXAR</button>
                        <button class="game-btn" onclick="cloudLogout()">SAIR DA CONTA</button>
                    </div>
                </div>
            </div>

            <div class="cloud-mini" style="margin-top:12px;">
                Dica: no outro console, abra este mesmo menu (+) e cole a mesma <b>API Key</b> e <b>Bin ID</b> pra ver a conta e vincular.
            </div>
        </div>
    </div>


    <div id="achievements-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header"><h2>TROFÉUS & CONQUISTAS</h2><button class="game-btn" onclick="closeModal('achievements-modal')">X</button></div>
            <p style="margin-bottom:10px; font-size:0.9rem; color:#aaa;">Tempo total de jogo: <span id="total-time-display" style="color:white; font-weight:bold;">0h 0m</span></p>
            <div class="achievements-list" id="ach-list-container"></div>
        </div>
    </div>

    <div id="custom-app-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header"><h2>LOJA DE PERSONALIZAÇÃO</h2><button class="game-btn" onclick="closeModal('custom-app-modal')">X</button></div>
            <div class="store-scroll">
                
                <div class="store-section-title">TEMAS DE SISTEMA (CORES)</div>
                <div class="custom-grid">
                    <div class="shop-btn tp-default" id="item-theme-default" onclick="selectShopItem('theme', 'default', 0)"><h4>TITANIUM</h4></div>
                    <div class="shop-btn tp-midnight" id="item-theme-midnight" onclick="selectShopItem('theme', 'midnight', 0)"><h4>MIDNIGHT</h4></div>
                    <div class="shop-btn tp-emerald" id="item-theme-emerald" onclick="selectShopItem('theme', 'emerald', 0)"><h4>EMERALD</h4></div>
                    <div class="shop-btn tp-ruby" id="item-theme-ruby" onclick="selectShopItem('theme', 'ruby', 0)"><h4>RUBY</h4></div>
                    
                    <div class="shop-btn tp-gold" id="item-theme-gold" onclick="selectShopItem('theme', 'gold', 2000)"><h4>GOLD</h4><div class="shop-lock"><span class="material-icons">lock</span>2000 XC</div></div>
                    <div class="shop-btn tp-matrix" id="item-theme-matrix" onclick="selectShopItem('theme', 'matrix', 2500)"><h4>MATRIX</h4><div class="shop-lock"><span class="material-icons">lock</span>2500 XC</div></div>
                    <div class="shop-btn tp-dracula" id="item-theme-dracula" onclick="selectShopItem('theme', 'dracula', 1800)"><h4>DRACULA</h4><div class="shop-lock"><span class="material-icons">lock</span>1800 XC</div></div>
                    <div class="shop-btn tp-cotton" id="item-theme-cotton" onclick="selectShopItem('theme', 'cotton', 1500)"><h4>COTTON</h4><div class="shop-lock"><span class="material-icons">lock</span>1500 XC</div></div>
                    
                    <div class="shop-btn tp-cyber" id="item-theme-cyber" onclick="selectShopItem('theme', 'cyber', 2200)"><h4>CYBER</h4><div class="shop-lock"><span class="material-icons">lock</span>2200 XC</div></div>
                    <div class="shop-btn tp-sunset" id="item-theme-sunset" onclick="selectShopItem('theme', 'sunset', 1700)"><h4>SUNSET</h4><div class="shop-lock"><span class="material-icons">lock</span>1700 XC</div></div>
                    <div class="shop-btn tp-monolith" id="item-theme-monolith" onclick="selectShopItem('theme', 'monolith', 1600)"><h4>MONOLITH</h4><div class="shop-lock"><span class="material-icons">lock</span>1600 XC</div></div>
                
                    <div class="shop-btn tp-vaporwave" id="item-theme-vaporwave" onclick="selectShopItem('theme', 'vaporwave', 2400)"><h4>VAPORWAVE</h4><div class="shop-lock"><span class="material-icons">lock</span>2400 XC</div></div>
                    <div class="shop-btn tp-deepsea" id="item-theme-deepsea" onclick="selectShopItem('theme', 'deepsea', 2100)"><h4>DEEP SEA</h4><div class="shop-lock"><span class="material-icons">lock</span>2100 XC</div></div>
                    <div class="shop-btn tp-marsrover" id="item-theme-marsrover" onclick="selectShopItem('theme', 'marsrover', 2200)"><h4>MARS ROVER</h4><div class="shop-lock"><span class="material-icons">lock</span>2200 XC</div></div>
                    <div class="shop-btn tp-forest" id="item-theme-forest" onclick="selectShopItem('theme', 'forest', 2000)"><h4>FOREST</h4><div class="shop-lock"><span class="material-icons">lock</span>2000 XC</div></div>
                    <div class="shop-btn tp-sakura" id="item-theme-sakura" onclick="selectShopItem('theme', 'sakura', 1900)"><h4>SAKURA</h4><div class="shop-lock"><span class="material-icons">lock</span>1900 XC</div></div>
                    <div class="shop-btn tp-cyberred" id="item-theme-cyberred" onclick="selectShopItem('theme', 'cyberred', 2300)"><h4>CYBERPUNK RED</h4><div class="shop-lock"><span class="material-icons">lock</span>2300 XC</div></div>
                    <div class="shop-btn tp-monogold" id="item-theme-monogold" onclick="selectShopItem('theme', 'monogold', 2600)"><h4>MONO GOLD</h4><div class="shop-lock"><span class="material-icons">lock</span>2600 XC</div></div>
                    <div class="shop-btn tp-arctic" id="item-theme-arctic" onclick="selectShopItem('theme', 'arctic', 1800)"><h4>ARCTIC</h4><div class="shop-lock"><span class="material-icons">lock</span>1800 XC</div></div>
                    <div class="shop-btn tp-ultraviolet" id="item-theme-ultraviolet" onclick="selectShopItem('theme', 'ultraviolet', 2400)"><h4>ULTRAVIOLET</h4><div class="shop-lock"><span class="material-icons">lock</span>2400 XC</div></div>
                    <div class="shop-btn tp-desertstorm" id="item-theme-desertstorm" onclick="selectShopItem('theme', 'desertstorm', 1700)"><h4>DESERT STORM</h4><div class="shop-lock"><span class="material-icons">lock</span>1700 XC</div></div>
</div>

                <div class="store-section-title">INICIALIZAÇÃO (BOOT)</div>
                <div class="custom-grid">
                    <div class="shop-btn" id="item-intro-xs" onclick="selectShopItem('intro', 'xs', 0)"><h4>TITANIUM</h4><p>Padrão</p></div>
                    <div class="shop-btn" id="item-intro-retro" onclick="selectShopItem('intro', 'retro', 1000)"><h4>RETRO BIOS</h4><p>Nostalgia</p><div class="shop-lock"><span class="material-icons">lock</span>1000 XC</div></div>
                    <div class="shop-btn" id="item-intro-cyber" onclick="selectShopItem('intro', 'cyber', 1500)"><h4>CYBER GLITCH</h4><p>Hacker</p><div class="shop-lock"><span class="material-icons">lock</span>1500 XC</div></div>
                    <div class="shop-btn" id="item-intro-static" onclick="selectShopItem('intro', 'static', 1200)"><h4>TV STATIC</h4><p>Ruído</p><div class="shop-lock"><span class="material-icons">lock</span>1200 XC</div></div>
                    <div class="shop-btn" id="item-intro-dvd" onclick="selectShopItem('intro', 'dvd', 2000)"><h4>DVD BOUNCE</h4><p>Clássico</p><div class="shop-lock"><span class="material-icons">lock</span>2000 XC</div></div>
                    <div class="shop-btn" id="item-intro-pulse" onclick="selectShopItem('intro', 'pulse', 1800)"><h4>PULSE</h4><p>Energia</p><div class="shop-lock"><span class="material-icons">lock</span>1800 XC</div></div>
                    <div class="shop-btn" id="item-intro-grid" onclick="selectShopItem('intro', 'grid', 1900)"><h4>GRID SCAN</h4><p>Scanner</p><div class="shop-lock"><span class="material-icons">lock</span>1900 XC</div></div>
                    <div class="shop-btn" id="item-intro-holo" onclick="selectShopItem('intro', 'holo', 2500)"><h4>HOLO</h4><p>Holograma</p><div class="shop-lock"><span class="material-icons">lock</span>2500 XC</div></div>
                
                    <div class="shop-btn" id="item-intro-x360" onclick="selectShopItem('intro', 'x360', 3000)"><h4>X360</h4><p>Clássico</p><div class="shop-lock"><span class="material-icons">lock</span>3000 XC</div></div>
                    <div class="shop-btn" id="item-intro-matrixrain" onclick="selectShopItem('intro', 'matrixrain', 2000)"><h4>MATRIX RAIN</h4><p>Chuva</p><div class="shop-lock"><span class="material-icons">lock</span>2000 XC</div></div>
                    <div class="shop-btn" id="item-intro-glitchv2" onclick="selectShopItem('intro', 'glitchv2', 1800)"><h4>GLITCH v2</h4><p>Erro</p><div class="shop-lock"><span class="material-icons">lock</span>1800 XC</div></div>
                    <div class="shop-btn" id="item-intro-starfield" onclick="selectShopItem('intro', 'starfield', 2200)"><h4>STARFIELD</h4><p>Espaço</p><div class="shop-lock"><span class="material-icons">lock</span>2200 XC</div></div>
                    <div class="shop-btn" id="item-intro-biohazard" onclick="selectShopItem('intro', 'biohazard', 2100)"><h4>BIOHAZARD</h4><p>Alerta</p><div class="shop-lock"><span class="material-icons">lock</span>2100 XC</div></div>
                    <div class="shop-btn" id="item-intro-aurora" onclick="selectShopItem('intro', 'aurora', 2300)"><h4>AURORA</h4><p>Luzes</p><div class="shop-lock"><span class="material-icons">lock</span>2300 XC</div></div>
                    <div class="shop-btn" id="item-intro-scanline" onclick="selectShopItem('intro', 'scanline', 1700)"><h4>SCANLINE</h4><p>CRT</p><div class="shop-lock"><span class="material-icons">lock</span>1700 XC</div></div>
                    <div class="shop-btn" id="item-intro-quantum" onclick="selectShopItem('intro', 'quantum', 2400)"><h4>QUANTUM</h4><p>Warp</p><div class="shop-lock"><span class="material-icons">lock</span>2400 XC</div></div>
                    <div class="shop-btn" id="item-intro-vhs" onclick="selectShopItem('intro', 'vhs', 1600)"><h4>VHS</h4><p>Tape</p><div class="shop-lock"><span class="material-icons">lock</span>1600 XC</div></div>
                    <div class="shop-btn" id="item-intro-bloom" onclick="selectShopItem('intro', 'bloom', 1900)"><h4>BLOOM</h4><p>Neon</p><div class="shop-lock"><span class="material-icons">lock</span>1900 XC</div></div>
</div>

                <div class="store-section-title">PACOTE DE SONS (SFX)</div>
                <div class="custom-grid">
                    <div class="shop-btn" id="item-sfx-standard" onclick="selectShopItem('sfx', 'standard', 0)"><h4>STANDARD</h4><p>Suave</p></div>
                    <div class="shop-btn" id="item-sfx-8bit" onclick="selectShopItem('sfx', '8bit', 1500)"><h4>8-BIT ARCADE</h4><p>Chiptune</p><div class="shop-lock"><span class="material-icons">lock</span>1500 XC</div></div>
                    <div class="shop-btn" id="item-sfx-futuristic" onclick="selectShopItem('sfx', 'futuristic', 1500)"><h4>FUTURISTIC</h4><p>Hi-Tech</p><div class="shop-lock"><span class="material-icons">lock</span>1500 XC</div></div>
                    <div class="shop-btn" id="item-sfx-cinematic" onclick="selectShopItem('sfx', 'cinematic', 1200)"><h4>CINEMATIC</h4><p>Impacto</p><div class="shop-lock"><span class="material-icons">lock</span>1200 XC</div></div>
                    <div class="shop-btn" id="item-sfx-glitch" onclick="selectShopItem('sfx', 'glitch', 1700)"><h4>GLITCH</h4><p>Bugado</p><div class="shop-lock"><span class="material-icons">lock</span>1700 XC</div></div>
                    <div class="shop-btn" id="item-sfx-lofi" onclick="selectShopItem('sfx', 'lofi', 900)"><h4>LOFI</h4><p>Suave</p><div class="shop-lock"><span class="material-icons">lock</span>900 XC</div></div>
                    <div class="shop-btn" id="item-sfx-retrorpg" onclick="selectShopItem('sfx', 'retrorpg', 1300)"><h4>RETRO-RPG</h4><p>8/16-bit Soft</p><div class="shop-lock"><span class="material-icons">lock</span>1300 XC</div></div>
                    <div class="shop-btn" id="item-sfx-heavymetal" onclick="selectShopItem('sfx', 'heavymetal', 1900)"><h4>HEAVY METAL</h4><p>Power</p><div class="shop-lock"><span class="material-icons">lock</span>1900 XC</div></div>
                    <div class="shop-btn" id="item-sfx-waterdrops" onclick="selectShopItem('sfx', 'waterdrops', 1100)"><h4>WATER DROPS</h4><p>Ping</p><div class="shop-lock"><span class="material-icons">lock</span>1100 XC</div></div>
                    <div class="shop-btn" id="item-sfx-spacecabin" onclick="selectShopItem('sfx', 'spacecabin', 1600)"><h4>SPACE CABIN</h4><p>Echo</p><div class="shop-lock"><span class="material-icons">lock</span>1600 XC</div></div>
                    <div class="shop-btn" id="item-sfx-ghostly" onclick="selectShopItem('sfx', 'ghostly', 1700)"><h4>GHOSTLY</h4><p>Whisper</p><div class="shop-lock"><span class="material-icons">lock</span>1700 XC</div></div>
                    <div class="shop-btn" id="item-sfx-mechanical" onclick="selectShopItem('sfx', 'mechanical', 1400)"><h4>MECHANICAL</h4><p>Clack</p><div class="shop-lock"><span class="material-icons">lock</span>1400 XC</div></div>
                    <div class="shop-btn" id="item-sfx-lasergun" onclick="selectShopItem('sfx', 'lasergun', 1800)"><h4>LASER-GUN</h4><p>Pew</p><div class="shop-lock"><span class="material-icons">lock</span>1800 XC</div></div>
                    <div class="shop-btn" id="item-sfx-bassboosted" onclick="selectShopItem('sfx', 'bassboosted', 2000)"><h4>BASS-BOOSTED</h4><p>Sub</p><div class="shop-lock"><span class="material-icons">lock</span>2000 XC</div></div>
                    <div class="shop-btn" id="item-sfx-orchestral" onclick="selectShopItem('sfx', 'orchestral', 2100)"><h4>ORCHESTRAL</h4><p>Swell</p><div class="shop-lock"><span class="material-icons">lock</span>2100 XC</div></div>
                    <div class="shop-btn" id="item-sfx-silent" onclick="selectShopItem('sfx', 'silent', 600)"><h4>SILENT</h4><p>Mute FX</p><div class="shop-lock"><span class="material-icons">lock</span>600 XC</div></div>

                </div>

                <div class="store-section-title">ESTILO DOS CARDS (PASTAS)</div>
                <div class="custom-grid">
                    <div class="shop-btn" id="item-card-glass" onclick="selectShopItem('card', 'glass', 0)"><h4>GLASS</h4><p>Padrão</p></div>
                    <div class="shop-btn" id="item-card-bubble" onclick="selectShopItem('card', 'bubble', 500)"><h4>BUBBLE</h4><p>Redondo</p><div class="shop-lock"><span class="material-icons">lock</span>500 XC</div></div>
                    <div class="shop-btn" id="item-card-sharp" onclick="selectShopItem('card', 'sharp', 500)"><h4>SHARP</h4><p>Quadrado</p><div class="shop-lock"><span class="material-icons">lock</span>500 XC</div></div>
                    <div class="shop-btn" id="item-card-poster" onclick="selectShopItem('card', 'poster', 800)"><h4>POSTER</h4><p>Vertical</p><div class="shop-lock"><span class="material-icons">lock</span>800 XC</div></div>
                    <div class="shop-btn" id="item-card-neon" onclick="selectShopItem('card', 'neon', 1200)"><h4>NEON</h4><p>Borda Luz</p><div class="shop-lock"><span class="material-icons">lock</span>1200 XC</div></div>
                    <div class="shop-btn" id="item-card-holo" onclick="selectShopItem('card', 'holo', 1200)"><h4>HOLO</h4><p>Iridescente</p><div class="shop-lock"><span class="material-icons">lock</span>1200 XC</div></div>
                    <div class="shop-btn" id="item-card-pixel" onclick="selectShopItem('card', 'pixel', 900)"><h4>PIXEL</h4><p>8-bit</p><div class="shop-lock"><span class="material-icons">lock</span>900 XC</div></div>
                    <div class="shop-btn" id="item-card-chrome" onclick="selectShopItem('card', 'chrome', 1300)"><h4>CHROME</h4><p>Metal</p><div class="shop-lock"><span class="material-icons">lock</span>1300 XC</div></div>
                    <div class="shop-btn" id="item-card-retrocartridge" onclick="selectShopItem('card', 'retrocartridge', 900)"><h4>RETRO-CARTRIDGE</h4><p>Cartucho</p><div class="shop-lock"><span class="material-icons">lock</span>900 XC</div></div>
                    <div class="shop-btn" id="item-card-scifiborder" onclick="selectShopItem('card', 'scifiborder', 1300)"><h4>SCI-FI BORDER</h4><p>Futuro</p><div class="shop-lock"><span class="material-icons">lock</span>1300 XC</div></div>
                    <div class="shop-btn" id="item-card-glowedge" onclick="selectShopItem('card', 'glowedge', 1200)"><h4>GLOW-EDGE</h4><p>Brilho</p><div class="shop-lock"><span class="material-icons">lock</span>1200 XC</div></div>
                    <div class="shop-btn" id="item-card-metallic" onclick="selectShopItem('card', 'metallic', 1400)"><h4>METALLIC</h4><p>Aço</p><div class="shop-lock"><span class="material-icons">lock</span>1400 XC</div></div>
                    <div class="shop-btn" id="item-card-minimalist" onclick="selectShopItem('card', 'minimalist', 800)"><h4>MINIMALIST</h4><p>Clean</p><div class="shop-lock"><span class="material-icons">lock</span>800 XC</div></div>
                    <div class="shop-btn" id="item-card-holov2" onclick="selectShopItem('card', 'holov2', 1500)"><h4>HOLOGRAPHIC v2</h4><p>Holo+</p><div class="shop-lock"><span class="material-icons">lock</span>1500 XC</div></div>
                    <div class="shop-btn" id="item-card-parchment" onclick="selectShopItem('card', 'parchment', 700)"><h4>PARCHMENT</h4><p>Papel</p><div class="shop-lock"><span class="material-icons">lock</span>700 XC</div></div>
                    <div class="shop-btn" id="item-card-carbonfiber" onclick="selectShopItem('card', 'carbonfiber', 1100)"><h4>CARBON FIBER</h4><p>Carbono</p><div class="shop-lock"><span class="material-icons">lock</span>1100 XC</div></div>
                    <div class="shop-btn" id="item-card-velvet" onclick="selectShopItem('card', 'velvet', 1000)"><h4>VELVET</h4><p>Veludo</p><div class="shop-lock"><span class="material-icons">lock</span>1000 XC</div></div>
                    <div class="shop-btn" id="item-card-prism" onclick="selectShopItem('card', 'prism', 1600)"><h4>PRISM</h4><p>Prisma</p><div class="shop-lock"><span class="material-icons">lock</span>1600 XC</div></div>

                </div>
            </div>
        </div>
    </div>



    <div id="roulette-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header"><h2>ROULETA XC</h2><button class="game-btn" onclick="closeModal('roulette-modal')">X</button></div>
            <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap; margin-bottom:10px;">
                <div style="font-size:0.85rem; color:#aaa;">Giros diários: <span id="roulette-spins-left" style="color:white; font-weight:bold;">0</span></div>
                <div style="font-size:0.85rem; color:#aaa;">Bônus: <span id="roulette-bonus-spins" style="color:white; font-weight:bold;">0</span></div>
                <div style="font-size:0.85rem; color:#aaa;">Último prêmio: <span id="roulette-last-win" style="color:white; font-weight:bold;">—</span></div>
            </div>

            <div class="roulette-stage">
                <div class="roulette-indicator"></div>
                <div class="roulette-viewport">
                    <div class="roulette-track" id="roulette-track"></div>
                </div>
            </div>

            <div style="display:flex; gap:10px; margin-top:12px; flex-wrap:wrap;">
                <button class="game-btn" style="background:var(--ps-blue);" id="roulette-spin-btn" onclick="spinRoulette()">GIRAR</button>
                <button class="game-btn" style="background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.15);" id="roulette-buy-btn" onclick="buyRouletteSpin()">COMPRAR GIRO (300 XC)</button>
                <button class="game-btn" style="background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.15);" onclick="openRouletteInventory()">INVENTÁRIO</button>
            </div>

            
            <div id="roulette-inventory" style="display:none; margin-top:12px;">
                <div class="ri-head">
                    <div class="ri-title">INVENTÁRIO DA ROLETA</div>
                    <div class="ri-sub"><span id="roulette-inv-count">0</span> ITENS</div>
                </div>

                <div class="ri-filters" id="roulette-inv-filters">
                    <button class="ri-filter active" data-filter="all">TUDO</button>
                    <button class="ri-filter" data-filter="avatars">AVATARES</button>
                    <button class="ri-filter" data-filter="frames">MOLDURAS</button>
                    <button class="ri-filter" data-filter="shop">TEMAS/LOJA</button>
                </div>

                <div class="ri-layout">
                    <div id="roulette-inv-grid" class="ri-gallery"></div>

                    <div class="ri-preview" id="roulette-inv-preview">
                        <div class="ri-preview-podium">
                            <img id="roulette-inv-preview-img" src="" alt="Preview do avatar" loading="lazy">
                        </div>
                        <div class="ri-preview-meta">
                            <div id="roulette-inv-preview-name" class="ri-preview-name">Selecione um item</div>
                            <div id="roulette-inv-preview-rarity" class="ri-preview-rarity">—</div>
                            <div id="roulette-inv-preview-desc" class="ri-preview-desc">
                                Clique em um card para <b>testar</b> no preview. Use <b>EQUIPAR</b> para aplicar de verdade no perfil.
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="settings-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header"><h2>CONFIGURAÇÕES DO SISTEMA</h2><button class="game-btn" onclick="closeModal('settings-modal')">X</button></div>
            <div class="settings-list">
                
                <div class="st-group-title">GERAL & ÁUDIO</div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">brightness_6</span><div><h4>BRILHO</h4><p style="font-size:0.75rem; color:#aaa;">Intensidade do painel</p></div></div><input type="range" id="brightness-slider" min="0" max="0.7" step="0.05" value="0" oninput="updateBrightness(this.value)" style="width:100px;"></div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">volume_up</span><div><h4>VOLUME MASTER</h4><p style="font-size:0.75rem; color:#aaa;">Saída de áudio</p></div></div><input type="range" id="vol-slider" min="0" max="1" step="0.1" value="0.5" onchange="updateVolume()" style="width:100px;"></div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">music_note</span><div><h4>INTRODUÇÃO</h4><p style="font-size:0.75rem; color:#aaa;">Ligar/Desligar Intro</p></div></div><label class="switch"><input type="checkbox" id="check-intro" onchange="toggleSetting('intro')"><span class="slider"></span></label></div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">graphic_eq</span><div><h4>SONS DE INTERFACE</h4><p style="font-size:0.75rem; color:#aaa;">Ligar/Desligar SFX</p></div></div><label class="switch"><input type="checkbox" id="check-sfx" onchange="toggleSetting('sfx')"><span class="slider"></span></label></div>

                <div class="st-group-title">CONTROLES</div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">sports_esports</span><div><h4>MODO DE CONTROLE</h4><p style="font-size:0.75rem; color:#aaa;">Auto / Touch / Teclado / Controle</p></div></div><select id="sel-input" onchange="setInputMode(this.value)" class="select-box"><option value="auto">AUTO (DETECTAR)</option><option value="touch">TOUCH</option><option value="keyboard">TECLADO/MOUSE</option><option value="gamepad">CONTROLE</option></select></div>


                <div class="st-group-title">PERFORMANCE (KERNEL)</div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons" style="color:#ff3b3b">bolt</span><div><h4 style="color:#ff3b3b">CPU OVERCLOCK</h4><p style="font-size:0.75rem; color:#aaa;">Turbo Mode (Instável)</p></div></div><label class="switch"><input type="checkbox" id="check-overclock" onchange="toggleSetting('overclock')"><span class="slider"></span></label></div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">memory</span><div><h4>TAMANHO DO BUFFER</h4><p style="font-size:0.75rem; color:#aaa;">Latência de áudio</p></div></div><select id="sel-buffer" onchange="toggleSetting('buffer')" class="select-box"><option value="128">128 samples</option><option value="256">256 samples</option><option value="512">512 samples</option><option value="1024">1024 samples</option></select></div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">blur_on</span><div><h4>MSAA 4X</h4><p style="font-size:0.75rem; color:#aaa;">Anti-serrilhamento</p></div></div><label class="switch"><input type="checkbox" id="check-aa" onchange="toggleSetting('aa')"><span class="slider"></span></label></div>

                <div class="st-group-title">MANUTENÇÃO</div>
                <div class="st-item">
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span class="material-icons">save</span>
                        <div>
                            <h4>GRAVAR MEMORY CARD</h4>
                            <p style="margin:0; font-size:0.8rem; color:#aaa;">Exporta seu save offline (.xsb)</p>
                        </div>
                    </div>
                    <button class="btn-action" onclick="exportXSMemory()">GRAVAR</button>
                </div>

                <div class="st-item">
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span class="material-icons">upload_file</span>
                        <div>
                            <h4>LER MEMORY CARD</h4>
                            <p style="margin:0; font-size:0.8rem; color:#aaa;">Importa um save (.xsb) e reinicia</p>
                        </div>
                    </div>
                    <input id="xs-memory-file" type="file" accept=".xsb" style="display:none" onchange="importXSMemory(event)">
                    <button class="btn-action" onclick="document.getElementById('xs-memory-file').click()">LER</button>
                </div>

                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">cleaning_services</span><div><h4>LIMPEZA DE CACHE</h4><p style="font-size:0.75rem; color:#aaa;">Resetar dados de app</p></div></div><button class="btn-action btn-danger" onclick="clearCache()">LIMPAR</button></div>
                <div class="st-item"><div style="display:flex; align-items:center; gap:10px;"><span class="material-icons">support_agent</span><div><h4>SUPORTE TÉCNICO</h4><p style="font-size:0.75rem; color:#aaa;">Whatsapp do dev</p></div></div><button class="btn-action btn-whatsapp" onclick="openSupport()">CONTATO</button></div>
            </div>
        </div>
    </div>

    
    <div id="create-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header">
                <h2>CRIAR</h2>
                <button class="game-btn" onclick="closeModal('create-modal')">X</button>
            </div>

            <div style="padding:12px 10px;">
                <div style="font-size:0.85rem; color:#aaa; margin-bottom:12px; line-height:1.35;">
                    Aqui você pode <b>criar/transportar</b> seu save sem internet usando <b>Memory Card Offline</b>.
                </div>

                <div style="display:flex; flex-direction:column; gap:10px;">
                    <button class="game-btn" style="width:100%; height:54px; border-radius:18px; background:rgba(0,229,255,0.14); border:1px solid rgba(0,229,255,0.35);"
                        onclick="exportXSMemory()">
                        <span class="material-icons" style="vertical-align:middle; margin-right:8px;">save</span>GRAVAR MEMORY CARD
                    </button>

                    <button class="game-btn" style="width:100%; height:54px; border-radius:18px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.18);"
                        onclick="document.getElementById('xs-memory-file').click()">
                        <span class="material-icons" style="vertical-align:middle; margin-right:8px;">upload_file</span>LER MEMORY CARD
                    </button>

                    <button class="game-btn" style="width:100%; height:54px; border-radius:18px; background:rgba(0,120,255,0.12); border:1px solid rgba(0,120,255,0.28);"
                        onclick="openModal('cloud-modal'); closeModal('create-modal');">
                        <span class="material-icons" style="vertical-align:middle; margin-right:8px;">cloud</span>MEMÓRIA CLOUD
                    </button>
                </div>
            </div>
        </div>
    </div>

    
    <!-- =========================
         XS EMULATOR FOLDERS (PS1 / SNES / ARCADE)
         ========================= -->
    <div id="emu-folder-modal" class="modal-overlay" style="display:none;">
        <div class="modal-box">
            <div class="modal-header">
                <h2 id="emu-folder-title">EMULADOR</h2>
                <button class="game-btn" onclick="closeModal('emu-folder-modal')">X</button>
            </div>
            <div style="padding:14px;">
                <div style="display:flex; gap:14px; align-items:center; flex-wrap:wrap;">
                    <img id="emu-folder-cover" src="" alt="Capa do emulador"
                         style="width:160px; height:160px; object-fit:contain; border-radius:18px;
                                background:rgba(0,0,0,0.22); border:1px solid rgba(255,255,255,0.14);
                                box-shadow:0 14px 40px rgba(0,0,0,0.35), 0 0 18px rgba(0,229,255,0.10);">
                    <div style="flex:1; min-width:220px;">
                        <div id="emu-folder-desc" style="color:#9aa; font-size:0.92rem; line-height:1.35;">
                            Abra em tela cheia. Use o botão <b>FECHAR JOGO</b> para sair.
                        </div>
                        <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
                            <button class="game-btn" onclick="launchEmuFolder()" style="background:var(--ps-blue);">ABRIR EMULADOR</button>
                            <button class="game-btn" onclick="closeModal('emu-folder-modal')">VOLTAR</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<div id="tutorial-modal" class="modal-overlay">
        <div class="modal-box guide-modal">
            <div class="modal-header">
                <h2>GUIA DO CONSOLE</h2>
                <button class="game-btn" onclick="closeGuide()">X</button>
            </div>

            <div class="guide-wrap">
                <!-- HUB -->
                <div id="guide-hub" class="guide-hub">
                    <div class="guide-hero">
                        <div class="guide-hero-title">GUIA DO CONSOLE</div>
                        <div class="guide-hero-sub">Escolha um capítulo e aprenda tudo do XUXUBISTATION XS — do básico ao Bixin Explorador (farm de XC).</div>
                    </div>

                    <div class="guide-carousel">
                        <button class="guide-nav-btn" onclick="guideHubPrev()" aria-label="Anterior">
                            <span class="material-icons">chevron_left</span>
                        </button>

                        <div class="guide-track" id="guide-track" aria-label="Capítulos do guia"></div>

                        <button class="guide-nav-btn" onclick="guideHubNext()" aria-label="Próximo">
                            <span class="material-icons">chevron_right</span>
                        </button>

                        <button class="guide-play-btn" onclick="guideOpenSelected()" aria-label="Abrir capítulo">
                            <span class="material-icons">play_arrow</span>
                        </button>
                    </div>

                    <div class="guide-hint">Dica: deslize para o lado (ou use ◀ ▶) e aperte ▶ para abrir o capítulo.</div>
                </div>

                <!-- READER -->
                <div id="guide-reader" class="guide-reader" style="display:none;">
                    <div class="guide-reader-top">
                        <button class="guide-back-btn" onclick="guideBackToHub()" aria-label="Voltar ao hub">
                            <span class="material-icons">arrow_back</span>
                        </button>

                        <div class="guide-reader-title">
                            <div id="guide-chapter-title" class="guide-chapter-title"></div>
                            <div id="guide-chapter-sub" class="guide-chapter-sub"></div>
                        </div>

                        <button class="guide-close-btn" onclick="closeGuide()" aria-label="Fechar guia">
                            <span class="material-icons">close</span>
                        </button>
                    </div>

                    <div class="guide-page" id="guide-page"></div>

                    <div class="guide-reader-nav">
                        <button class="guide-btn" onclick="guidePrevPage()" aria-label="Página anterior">
                            <span class="material-icons">chevron_left</span>
                        </button>
                        <div class="guide-page-ind"><span id="guide-page-num">1</span>/<span id="guide-page-total">1</span></div>
                        <button class="guide-btn" onclick="guideNextPage()" aria-label="Próxima página">
                            <span class="material-icons">chevron_right</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

        <!-- ======================
         XS DRIVE (Virtual File System)
         ====================== -->
<div id="drive-modal" class="modal-overlay">
        <div class="modal-box xs-drive-box">
            <div class="modal-header">
                <h2>XS DRIVE</h2>
                <button class="game-btn" onclick="closeModal('drive-modal')">FECHAR</button>
            </div>

            <div class="xs-drive">
                <div class="xs-drive-sidebar">
                    <div class="xs-drive-bar">
                        <div class="xs-drive-crumb" id="xsDriveCrumb"></div>
                        <div style="display:flex; gap:8px; align-items:center;">
                            <button class="game-btn" onclick="xsDriveToggleTrash()" title="Abrir/Largar Lixeira">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">delete</span>
                            </button>
                            <button class="game-btn" onclick="xsDriveGoUp()" title="Voltar uma pasta">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">arrow_upward</span>
                            </button>
                        </div>
                    </div>

                    <div class="xs-drive-bar" style="border-bottom: 0; padding-top: 0;">
                        <div class="xs-drive-actions" style="justify-content:flex-start;">
                            <button class="game-btn" onclick="xsDriveNewFolder()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">create_new_folder</span> Pasta
                            </button>
                            <button class="game-btn" onclick="xsDriveNewNote()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">note_add</span> Nota
                            </button>
                            <button class="game-btn" onclick="xsDriveUploadPick()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">upload</span> Upload
                            </button>
                            <button class="game-btn" onclick="xsDriveExport()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">download</span> Backup
                            </button>
                            <button class="game-btn" onclick="xsDriveImportPick()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">file_upload</span> Import
                            </button>
                        </div>
                    </div>

                    <div class="xs-drive-list" id="xsDriveList"></div>
                </div>

                <div class="xs-drive-editor">
                    <div class="xs-drive-editor-top">
                        <div class="xs-drive-title">
                            <div class="t1" id="xsDriveFileTitle">Selecione um arquivo</div>
                            <div class="t2" id="xsDriveFileHint">Dica: crie uma Nota, edite e clique em Salvar.</div>
                        </div>
                        <div class="xs-drive-editor-actions">
                            <button class="game-btn" onclick="xsDriveSaveFile()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">save</span>
                            </button>
                            <button class="game-btn" onclick="xsDriveRename()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">drive_file_rename_outline</span>
                            </button>
                            <button class="game-btn" onclick="xsDriveDownloadFile()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">file_download</span>
                            </button>
                            <button class="game-btn" onclick="xsDriveDelete()">
                                <span class="material-icons" style="font-size:18px; vertical-align:middle;">delete</span>
                            </button>
                        </div>
                    </div>

                    <textarea id="xsDriveEditor" class="xs-drive-textarea" placeholder="Nada selecionado..."></textarea>
                    <div class="xs-drive-meta" id="xsDriveMeta"></div>
                </div>
            </div>

            <!-- Prompt interno (evita prompt() do navegador) -->
            <div class="xs-drive-prompt" id="xsDrivePrompt">
                <div class="box">
                    <div class="hdr">
                        <div class="h">
                            <span class="material-icons" style="opacity:.9;">terminal</span>
                            <b id="xsDrivePromptTitle">XS Prompt</b>
                        </div>
                        <button class="game-btn" onclick="xsDrivePromptClose()">FECHAR</button>
                    </div>
                    <div class="body">
                        <div id="xsDrivePromptDesc" style="color:#aab5cf; font-size:0.88rem; margin-bottom:10px;"></div>
                        <input id="xsDrivePromptInput" type="text" placeholder="Digite aqui..." />
                        <textarea id="xsDrivePromptTextarea" placeholder="Conteúdo..." style="display:none; margin-top:10px;"></textarea>
                    </div>
                    <div class="btns">
                        <button class="game-btn" onclick="xsDrivePromptCancel()">Cancelar</button>
                        <button class="game-btn" onclick="xsDrivePromptOk()">OK</button>
                    </div>
                </div>
            </div>

            <input id="xsDriveUploadInput" type="file" style="display:none" />
            <input id="xsDriveImportInput" type="file" accept="application/json,.json" style="display:none" />
        </div>
    </div>

<div id="mobile-controls">
        <div class="btn-group"><div class="m-btn" onmousedown="move(-1)">◀</div><div class="m-btn" onmousedown="move(1)">▶</div></div>
        <div class="btn-group"><div class="m-btn" onmousedown="actionEnter()" style="background: var(--ps-blue);">✕</div></div>
    </div>

    <div id="game-runtime"><div class="ui-overlay"><button class="game-btn" onclick="closeGame()">FECHAR JOGO</button></div>
<div id="dino-game-container" style="display:none; position:relative; width:100%; height:100%; overflow:hidden;">
  <canvas id="dino-canvas" width="0" height="0" style="width:100%; height:100%;"></canvas>
  <div id="dino-kbd-hint">Use ESPAÇO e X para jogar</div>


        <!-- Touch UI: aparece somente quando detectar toque -->
        <div id="dino-touch-ui" aria-hidden="true">
          <div class="touch-btn" id="dino-btn-jump" role="button" aria-label="Pular" onclick="try{window.__DINO_JUMP__&&window.__DINO_JUMP__(); try{window.__DINO_LOCAL_JUMP__&&window.__DINO_LOCAL_JUMP__();}catch(e){}}catch(e){};return false;" ontouchstart="try{window.__DINO_JUMP__&&window.__DINO_JUMP__(); try{window.__DINO_LOCAL_JUMP__&&window.__DINO_LOCAL_JUMP__();}catch(e){}}catch(e){};return false;" onpointerdown="try{window.__DINO_JUMP__&&window.__DINO_JUMP__(); try{window.__DINO_LOCAL_JUMP__&&window.__DINO_LOCAL_JUMP__();}catch(e){}}catch(e){};return false;" onmousedown="try{window.__DINO_JUMP__&&window.__DINO_JUMP__(); try{window.__DINO_LOCAL_JUMP__&&window.__DINO_LOCAL_JUMP__();}catch(e){}}catch(e){};return false;">
            <span>PULAR</span>
          </div>
          <div class="touch-btn touch-btn-left" id="dino-btn-fire" role="button" aria-label="Atirar" onclick="try{window.__DINO_SHOOT__&&window.__DINO_SHOOT__();}catch(e){};return false;" ontouchstart="try{window.__DINO_SHOOT__&&window.__DINO_SHOOT__();}catch(e){};return false;" onpointerdown="try{window.__DINO_SHOOT__&&window.__DINO_SHOOT__();}catch(e){};return false;" onmousedown="try{window.__DINO_SHOOT__&&window.__DINO_SHOOT__();}catch(e){};return false;">
            <span>TIRO</span>
          </div>
        
  <!-- Tutorial (mostra no início; pode pular) -->
  <div id="dino-tutorial" style="display:none; position:absolute; inset:0; z-index:999998; background:rgba(0,0,0,0.72); backdrop-filter: blur(8px);">
    <div style="max-width:840px; margin:0 auto; height:100%; display:flex; align-items:center; justify-content:center; padding:18px;">
      <div style="width:min(760px, 96vw); background:rgba(8,12,18,0.82); border:1px solid rgba(0,255,255,0.18); box-shadow:0 0 24px rgba(0,255,255,0.14), 0 0 40px rgba(255,0,120,0.08); border-radius:22px; padding:18px 16px;">
        <div style="font-weight:900; letter-spacing:2px; text-transform:uppercase; color:#7fe9ff; font-size:1.05rem; margin-bottom:10px;">Como jogar</div>
        <div style="color:#cdd7e6; line-height:1.35; font-size:0.95rem;">
          <div style="margin-bottom:8px;">• <b>PULAR</b>: desvie dos blocos e suba nas plataformas cinzas.</div>
          <div style="margin-bottom:8px;">• <b>TIRO</b>: atire em inimigos e em blocos <span style="color:#ff2b5e; font-weight:900;">vermelhos</span> (quebram com <b>2 tiros</b>).</div>
          <div style="margin-bottom:8px;">• <b>Plataformas cinzas</b>: você pode pousar em cima. Só morre se bater <b>de lado</b>.</div>
          <div style="margin-bottom:8px;">• Cada 100m seu multiplicador aumenta. Moedas da corrida viram <b>XC</b> no final.</div>
          <div style="opacity:0.85; margin-top:10px; font-size:0.9rem;">Dica: no celular, use os botões na tela. No PC/controle: <b>Espaço</b> para pular.</div>
        </div>

        <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:14px; flex-wrap:wrap;">
          <button id="dino-tut-skip" style="border:none; padding:10px 14px; border-radius:14px; background:rgba(255,255,255,0.08); color:#e7eefc; font-weight:800; letter-spacing:0.5px;">Pular tutorial</button>
          <button id="dino-tut-start" style="border:none; padding:10px 14px; border-radius:14px; background:rgba(0,255,255,0.18); color:#eaffff; font-weight:900; letter-spacing:0.8px; box-shadow:0 0 16px rgba(0,255,255,0.18);">Começar</button>
        </div>
      </div>
    </div>
  </div>
</div>

  <div id="dino-game-over" style="display:none; position:absolute; inset:0; background:rgba(0,0,0,0.72); color:#fff; font-family:'Segoe UI',sans-serif; text-align:center; padding: max(16px, env(safe-area-inset-top)) 14px max(16px, env(safe-area-inset-bottom)) 14px;; z-index:999999;">
    <div style="max-width:720px; margin:0 auto; background:rgba(0,0,0,0.35); border:1px solid rgba(255,255,255,0.14); border-radius:22px; padding:18px 16px; backdrop-filter: blur(10px);">
      <div style="font-weight:900; letter-spacing:3px; color:var(--ps-glow,#00e5ff); text-transform:uppercase; font-size:1.1rem; margin-bottom:10px;">Game Over</div>
      <div style="font-size:0.95rem; color:#bbb; margin-bottom:6px;">Distância</div>
      <div id="dino-final-score" style="font-size:2.1rem; font-weight:900; margin-bottom:10px;">0</div>

      <div style="display:flex; justify-content:center; gap:12px; flex-wrap:wrap; margin:10px 0 8px;">
        <div style="min-width:200px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); border-radius:16px; padding:10px 12px;">
          <div style="font-size:0.85rem; color:#aaa;">Você ganhou</div>
          <div style="display:flex; align-items:center; justify-content:center; gap:8px; margin-top:2px;">
            <span class="material-icons" style="color:#ffd700;">monetization_on</span>
            <span id="dino-coins-earned" style="font-size:1.8rem; font-weight:900; color:#ffd700;">0</span>
            <span style="font-weight:900; color:#ffd700;">XC</span>
          </div>
          <div id="dino-cap-note" style="font-size:0.78rem; color:#8aa; margin-top:6px;"></div>
          <div style="margin-top:10px; padding:8px 10px; border-radius:12px; background:rgba(255,255,255,0.06); border:1px solid rgba(0,229,255,0.18);">
            <div style="display:flex; justify-content:space-between; font: 14px monospace; opacity:.95;">
              <span>MOEDAS NA CORRIDA</span>
              <span id="dino-run-coins">0</span>
            </div>
            <div style="margin-top:6px; font: 13px monospace; opacity:.85;">
              <span id="dino-convert-line">Convertendo…</span>
            </div>
          </div>

        </div>

        <div style="min-width:200px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); border-radius:16px; padding:10px 12px;">
          <div style="font-size:0.85rem; color:#aaa;">Saldo total</div>
          <div style="display:flex; align-items:center; justify-content:center; gap:8px; margin-top:2px;">
            <span class="material-icons" style="color:#ffd700;">account_balance_wallet</span>
            <span id="dino-total-coins" style="font-size:1.8rem; font-weight:900; color:#fff;">0</span>
            <span style="font-weight:900; color:#fff;">XC</span>
          </div>
        </div>
      </div>

      <div style="margin-top:12px; color:#bbb; font-size:0.92rem;">Toque / clique / ESPAÇO / (A) para jogar de novo</div>
      <div style="margin-top:6px; color:#777; font-size:0.8rem;">(Use o botão FECHAR para sair)</div>
    </div>
  </div>
</div>

<div id="external-runtime" style="display:none; position:fixed; inset:0; align-items:center; justify-content:center; z-index:3; pointer-events:none;">
  <div style="pointer-events:auto; width:min(92vw,560px); padding:18px; border-radius:22px;
              background:rgba(0,0,0,0.55); border:1px solid rgba(255,255,255,0.14);
              box-shadow:0 18px 60px rgba(0,0,0,0.55); text-align:center;">
    <div style="font-weight:900; letter-spacing:0.10em; text-transform:uppercase; color:#fff;">Abrindo em nova aba</div>
    <div style="margin-top:10px; color:#cdd; font-size:0.95rem; line-height:1.35;">
      Alguns sites bloqueiam execução dentro do console (iframe).<br>
      Toque em <b>ABRIR AGORA</b> para abrir fora, e use <b>FECHAR JOGO</b> para voltar.
    </div>
    <div style="margin-top:14px; display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
      <button class="game-btn" onclick="try{ __externalUrl && __openPopup(__externalUrl); }catch(e){}" style="background:var(--ps-blue);">ABRIR AGORA</button>
      <button class="game-btn" onclick="closeGame()">VOLTAR</button>
    </div>
  </div>
</div>

<iframe id="game-frame" allow="autoplay; fullscreen; keyboard; gamepad" src=""></iframe></div>

    <script>
        // DATA PERSISTENCE
        let profiles = JSON.parse(localStorage.getItem('xs_profiles')) || [{ name: "xuxubitus", avatar: "xuxu" }, { name: "bububis", avatar: "bubi" }];
        
        let systemSettings = JSON.parse(localStorage.getItem('xs_settings')) || { 
            theme: "default", volume: 0.5, brightness: 0, 
            overclock: false, buffer: "512", aa: false,
            intro: true, sfx: true, 
            introType: "xs", sfxPack: "standard", cardStyle: "glass", inputMode: "auto" 
        };
        // XS BOOT SAFETY: se o usuário ficou com intro desligado por acidente, reativa UMA vez.
        // Não mexe em playBootSequence nem no window.onload — só corrige settings persistido.
        try {
            const __xsIntroFixKey = 'xs_intro_forced_once';
            if (systemSettings && systemSettings.intro === false && localStorage.getItem(__xsIntroFixKey) !== '1') {
                systemSettings.intro = true;
                localStorage.setItem('xs_settings', JSON.stringify(systemSettings));
                localStorage.setItem(__xsIntroFixKey, '1');
            }
        } catch (e) {}

        
        let sideloadedGames = JSON.parse(localStorage.getItem('xs_sideloads')) || [];
        let userCoins = parseInt(localStorage.getItem('xs_coins')) || 0;
        let playTime = parseInt(localStorage.getItem('xs_playtime')) || 0;
        let purchasedItems = JSON.parse(localStorage.getItem('xs_purchased')) || ["intro-xs", "sfx-standard", "card-glass", "theme-default", "theme-midnight", "theme-emerald", "theme-ruby"];

        // STATS (para conquistas funcionarem de verdade)
        let stats = JSON.parse(localStorage.getItem('xs_stats')) || { shopOpens: 0, tutorialOpens: 0, gamesLaunched: 0, purchases: 0, avatarSaves: 0, filesOpens: 0, driveWrites: 0, driveExports: 0, driveImports: 0 };
        let sessionSeconds = 0;

        // Stats normalize (compatibilidade entre versões)
        try{
            stats.shopOpens = stats.shopOpens || 0;
            stats.tutorialOpens = stats.tutorialOpens || 0;
            stats.gamesLaunched = stats.gamesLaunched || 0;
            stats.purchases = stats.purchases || 0;
            stats.avatarSaves = stats.avatarSaves || 0;
            stats.filesOpens = stats.filesOpens || 0;
            stats.driveWrites = stats.driveWrites || 0;
            stats.driveExports = stats.driveExports || 0;
            stats.driveImports = stats.driveImports || 0;
        }catch(e){}

        function saveStats() { localStorage.setItem('xs_stats', JSON.stringify(stats)); }
        let __ach_eval_lock = false;
        function evaluateMilestones() {
            if (__ach_eval_lock) return;
            __ach_eval_lock = true;
            try {
                // Tempo total
                if (playTime >= 600) checkAchievement('gamer_novice');
                if (playTime >= 1800) checkAchievement('gamer_intermediate');
                if (playTime >= 3600) checkAchievement('gamer_pro');
                if (playTime >= 7200) checkAchievement('gamer_addict');
                if (playTime >= 18000) checkAchievement('gamer_legend');

                // Sessao (seguidas)
                if (sessionSeconds >= 10800) checkAchievement('marathon');

                // Loja / guia
                if (stats.shopOpens >= 5) checkAchievement('window_shopper');
                if (stats.tutorialOpens >= 3) checkAchievement('explorer');

                // Compras
                if (stats.purchases >= 3) checkAchievement('collector_3');
                if (stats.purchases >= 8) checkAchievement('collector_8');

                const paidItems = [
                    'theme-gold','theme-matrix','theme-dracula','theme-cotton',
                    'intro-retro','intro-cyber','intro-static','intro-dvd',
                    'sfx-8bit','sfx-futuristic',
                    'card-bubble','card-sharp','card-poster','card-neon'
                ];
                if (paidItems.every(id => purchasedItems.includes(id))) checkAchievement('collector_all');

                // Sideload
                if (sideloadedGames.length >= 5) checkAchievement('sideload_five');

                // XS Drive
                if ((stats.driveWrites||0) >= 10) checkAchievement('archivist');
                if ((stats.driveExports||0) >= 1) checkAchievement('backup_master');
                if ((stats.driveImports||0) >= 1) checkAchievement('restorer');

                // Dinheiro
                if (userCoins >= 2000) checkAchievement('rich_kid');
                if (userCoins >= 10000) checkAchievement('moneybags');
                if (userCoins >= 20000) checkAchievement('millionaire');

                // Meta
                const unlockedCount = achievements.filter(a => a.unlocked).length;
                if (unlockedCount >= 10) checkAchievement('master_user');
            } finally {
                __ach_eval_lock = false;
            }
        }

        
        // --- MASTER LIST (30 Itens) ---
        const masterAchievements = [
            { id: "first_boot", title: "Bem-vindo ao Futuro", desc: "Acesse o console pela primeira vez", reward: 100, unlocked: false },
            { id: "gamer_novice", title: "Aquecimento", desc: "Jogue por 10 minutos no total", reward: 200, unlocked: false },
            { id: "gamer_pro", title: "Viciado", desc: "Jogue por 1 hora no total", reward: 500, unlocked: false },
            { id: "sideload_king", title: "Desenvolvedor", desc: "Adicione um jogo via URL", reward: 300, unlocked: false },
            { id: "insomnia", title: "Insônia Gamer", desc: "Jogue entre 00:00 e 05:00 da manhã", reward: 1000, unlocked: false },
            { id: "rich_kid", title: "Magnata", desc: "Acumule 2000 XC", reward: 500, unlocked: false },
            { id: "customizer", title: "Estilista", desc: "Comprou seu primeiro tema", reward: 400, unlocked: false },
            { id: "overclocker", title: "Perigo!", desc: "Ativou o modo Overclock", reward: 150, unlocked: false },
            { id: "big_spender", title: "Ostentação", desc: "Gastou 2000 XC em um único item", reward: 1000, unlocked: false },
            { id: "audiophile", title: "DJ", desc: "Ajustou o volume do sistema", reward: 50, unlocked: false },
            { id: "clean_freak", title: "Faxina", desc: "Limpou o cache do sistema", reward: 100, unlocked: false },
            { id: "window_shopper", title: "Só Olhando", desc: "Abriu a loja 5 vezes", reward: 50, unlocked: false },
            { id: "support_ticket", title: "Chamando a Tropa", desc: "Clicou no botão de suporte", reward: 100, unlocked: false },
            { id: "weekend_warrior", title: "Fim de Semana", desc: "Jogou no Sábado ou Domingo", reward: 300, unlocked: false },
            { id: "marathon", title: "Maratonista", desc: "Jogou por 3 horas seguidas", reward: 1000, unlocked: false },
            { id: "gamer_intermediate", title: "Engatou a Marcha", desc: "Jogue por 30 minutos no total", reward: 400, unlocked: false },
            { id: "gamer_addict", title: "Modo Turbo", desc: "Jogue por 2 horas no total", reward: 1200, unlocked: false },
            { id: "gamer_legend", title: "Lenda do XS", desc: "Jogue por 5 horas no total", reward: 3000, unlocked: false },
            { id: "night_owl", title: "Coruja Noturna", desc: "Inicie um jogo após 22:00", reward: 500, unlocked: false },
            { id: "early_bird", title: "Bom Dia Gamer", desc: "Inicie um jogo entre 05:00 e 08:00", reward: 300, unlocked: false },
            { id: "collector_3", title: "Colecionador", desc: "Compre 3 itens na loja", reward: 400, unlocked: false },
            { id: "collector_8", title: "Colecionador Pro", desc: "Compre 8 itens na loja", reward: 1200, unlocked: false },
            { id: "collector_all", title: "Completista", desc: "Compre tudo da Loja de Personalização", reward: 8000, unlocked: false },
            { id: "sideload_five", title: "Biblioteca Cheia", desc: "Adicione 5 jogos via URL", reward: 1000, unlocked: false },
            { id: "explorer", title: "Explorador", desc: "Abra o Guia do Console 3 vezes", reward: 200, unlocked: false },
            { id: "avatar_artist", title: "Artista do Avatar", desc: "Salve uma personalização de avatar", reward: 250, unlocked: false },
            { id: "stylist_color", title: "Paleta Perfeita", desc: "Mude cor do cabelo/roupa/acessórios", reward: 200, unlocked: false },
            { id: "moneybags", title: "Bolso Pesado", desc: "Acumule 10000 XC", reward: 1500, unlocked: false },
            { id: "millionaire", title: "Banco do XS", desc: "Acumule 20000 XC", reward: 4000, unlocked: false },
            { id: "archivist", title: "Arquivista", desc: "Salve 10 vezes no XS Drive", reward: 500, unlocked: false },
            { id: "backup_master", title: "Backup Master", desc: "Exporte um backup do XS Drive", reward: 700, unlocked: false },
            { id: "restorer", title: "Restaurador", desc: "Importe um backup do XS Drive", reward: 700, unlocked: false },
            { id: "master_user", title: "Titanium User", desc: "Desbloqueou 10 conquistas", reward: 5000, unlocked: false }
        ];

        // --- MIGRATION LOGIC (CORREÇÃO DE BUG) ---
        let savedAchievements = JSON.parse(localStorage.getItem('xs_achievements')) || [];
        if (savedAchievements.length < masterAchievements.length) {
            // Mescla as salvas com as novas, mantendo o status 'unlocked'
            masterAchievements.forEach(master => {
                const found = savedAchievements.find(s => s.id === master.id);
                if (found) { master.unlocked = found.unlocked; } // Mantém progresso
            });
            savedAchievements = masterAchievements;
            localStorage.setItem('xs_achievements', JSON.stringify(savedAchievements));
        }
        let achievements = savedAchievements;

        const avatarBases = ["xuxu", "bubi", "Felix", "Jasper", "Luna", "Zoe", "Leo"];
        let playTimerInterval;
        let tutIdx = 0; 
        let currentAvTab = 'face';
        
        const __TUT_TOTAL = 6; 
        
        const GAMES = [
{ name: "Guia do Console", type: "tutorial", icon: "auto_stories" },
{ name: "Conquistas", type: "achievements", icon: "emoji_events" },
            { name: "Loja & Personalização", type: "custom", icon: "shopping_bag" },
            { name: "Roleta XC", type: "roulette", icon: "casino" },
            { name: "Jukebox", type: "jukebox", icon: "music_note" },
            { name: "Bixin Explorador", type: "dino", icon: "directions_run" },
            { name: "Configurações", type: "settings", icon: "settings" },
            { name: "Pasta de Jogos", type: "folder", icon: "snippet_folder" },
            { name: "XS Drive", type: "files", icon: "folder_open" },
{ name: "Emulador PS1", type: "emu_folder", img: "https://pngimg.com/uploads/sony_playstation/sony_playstation_PNG17545.png", url: "https://classicosps1.com.br/" }
            ,{ name: "Emulador Super Nintendo", type: "emu_folder", img: "https://upload.wikimedia.org/wikipedia/commons/3/36/SNES-Mod1-Console-Set.png", url: "https://classicgamezone.com/pt/snes-games" }
            ,{ name: "Fliperama (Arcade)", type: "emu_folder", img: "https://www.kindpng.com/picc/m/482-4822369_picture-download-cabaret-arcade-machine-machines-liftgate-angel.png", url: "https://classicgamezone.com/pt/arcade-games" }
            ,{ name: "EMULADOR DELUXE", type: "emu_folder", img: "https://gam.onl/logos2/play-retro-games-online.png", url: "https://gam.onl/" }
            ,{ name: "Windows93", type: "emu_folder", img: "https://www.windows93.net/favicon.ico", url: "https://www.windows93.net/#!recorder" }
,{ name: "Venge.io", type: "emu_folder", img: "https://img.poki-cdn.com/cdn-cgi/image/q%3D78%2Cscq%3D50%2Cwidth%3D204%2Cheight%3D204%2Cfit%3Dcover%2Cf%3Dauto/a2ddd7d16a599f8f01b65a3bc453e698/venge-io.png", url: "https://venge.io/" }
            ,{ name: "Stein.world", type: "emu_folder", img: "https://stein.world/assets/images/login-logo.png", url: "https://stein.world/" }

            ,{ name: "Vampire Survivors", type: "emu_folder", img: "https://img.itch.zone/aW1nLzcyNTA5NDUucG5n/original/hIx2ds.png", url: "https://poncle.itch.io/vampire-survivors?hl=pt-BR" }
            ,{ name: "Smash Karts", type: "emu_folder", img: "https://smashkarts.io/images/smashkarts.png", url: "https://smashkarts.io/" }
            ,{ name: "Flyff RPG", type: "emu_folder", img: "https://cdn-universe.flyff.com/site/landing/images/logo.png", url: "https://universe.flyff.com/news" }
        
            ,{ name: "Slow Roads", type: "emu_folder", img: "https://slowroads.io/icon.svg", url: "https://slowroads.io/?hl=pt-BR" },

  {
    id: "warbrokers",
    name: "War Brokers",
    type: "emu_folder",
    url: "https://warbrokers.io/",
    img: "https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/750470/header.jpg"
  },

  {
    id: "gulper_io",
    name: "Gulper.io",
    type: "emu_folder",
    url: "https://gulper.io/",
    img: "https://images.igdb.com/igdb/image/upload/t_720p/scfupf.png"
  },

  {
    id: "browserquest",
    name: "BrowserQuest",
    type: "emu_folder",
    url: "https://demos.workerman.net/browserquest/",
    img: "https://www.littleworkshop.fr/images/projects/hero-images/browserquest.jpg"
  },

  {
    id: "taming_io",
    name: "Taming.io",
    type: "emu_folder",
    url: "https://taming.io/",
    img: "https://media.indiedb.com/images/games/1/77/76588/taming_screenshot2.png"
  },

  {
    id: "lolbeans",
    name: "LOLBeans.io",
    type: "emu_folder",
    url: "https://lolbeans.io/",
    img: "https://lolbeans.io/ui/changelog-map-newballdrop.png"
  }
];

        let state = "INTRO", activeUser = 0, gameIdx = 0, tempAvatar = "";
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // =========================
        // JUKEBOX (músicas curtas em loop, com seleção/volume/pause)
        // =========================
        let jb2 = {
            mode: "synth", // synth | yt
            ytCur: -1,
            ytId: null,
            ctx: null,
            master: null,
            hp: null,
            lowShelf: null,
            comp: null,
            lp: null,
            isPlaying: false,
            cur: 0,
            nextNoteTime: 0,
            timer: null,
            step: 0,
            bars: 8,      // loops curtos (8 barras)
            stepsPerBar: 16,
            lookaheadMs: 25,
            scheduleAhead: 0.12,
            vol: 0.55
        };

        // Track generator (determinístico)
        function __jb2Rng(seed){
            let s = (seed >>> 0) || 1;
            return function(){
                s = (s * 1664525 + 1013904223) >>> 0;
                return s / 4294967296;
            };
        }

        const JB2_TRACKS = (() => {
            const namesA = ["NEON", "CAVERNA", "METRÔ", "ARCADE", "ROOFTOP", "CYBER", "GLITCH", "VHS", "LASER", "DRIFT"];
            const namesB = ["DREAM", "ECHO", "RITUAL", "NIGHT", "CITY", "SIGNAL", "FLOOR", "HEART", "RADIO", "TUNNEL"];
            const genres = ["Eletrônica", "Hip Hop", "Rap", "Phonk", "Ambient"];
            const scales = [
                [0, 3, 5, 7, 10],   // minor pentatonic
                [0, 2, 3, 5, 7, 10],// natural minor-ish
                [0, 2, 5, 7, 9],    // major pentatonic
            ];
            const tracks = [];
            let id = 1;
            for(let i=0;i<40;i++){
                const rng = __jb2Rng(9000 + i*97);
                const name = `${namesA[Math.floor(rng()*namesA.length)]} ${namesB[Math.floor(rng()*namesB.length)]}`;
                const genre = genres[Math.floor(rng()*genres.length)];
                const bpmBase = (genre==="Phonk") ? 152 : (genre==="Rap") ? 98 : (genre==="Hip Hop") ? 86 : (genre==="Ambient") ? 76 : 120;
                const bpm = Math.round(bpmBase + (rng()*10-5));
                const root = 33 + Math.floor(rng()*6); // ~A1..D2
                const sc = scales[Math.floor(rng()*scales.length)];
                // patterns 16 steps
                const k = Array(16).fill(0);
                const s = Array(16).fill(0);
                const h = Array(16).fill(0);
                // kick (menos pesado)
                k[0]=1; if(rng()>0.4) k[8]=1; if(rng()>0.65) k[12]=1;
                // snare
                s[4]=1; s[12]=1; if(rng()>0.7) s[14]=1;
                // hats
                for(let t=0;t<16;t++) h[t] = (t%2===0 || rng()>0.75) ? 1:0;
                // bassline (8 notes over bar, repeats)
                const bass = [];
                for(let t=0;t<8;t++){
                    const deg = sc[Math.floor(rng()*sc.length)];
                    bass.push(root + deg);
                }
                // lead (melodia curta)
                const lead = [];
                const leadRoot = root + 24;
                for(let t=0;t<16;t++){
                    if(rng()>0.55){
                        const deg = sc[Math.floor(rng()*sc.length)];
                        lead.push(leadRoot + deg + (rng()>0.85?12:0));
                    } else lead.push(null);
                }
                tracks.push({ id:id++, name, genre, bpm, seed:(9000+i*97), pat:{k,s,h,bass,lead} });
            }
            return tracks;
        })()

        // =========================
        // YOUTUBE MUSIC SIDELOAD (playlist local + player oficial)
        // =========================
        let ytPlaylist = (function(){
  const XS_MUSIC_URL = "https://www.ouvirmusica.com.br/";
  const PREF_KEY = "xs_music_view"; // "portrait" | "landscape"

  function xsGetWrap(){ return document.getElementById("xs-music-browser"); }
  function xsGetFrame(){ return document.getElementById("xsMusicFrame"); }

  function xsGetPref(){
    try{
      const v = (localStorage.getItem(PREF_KEY) || "").toLowerCase();
      if(v === "landscape" || v === "horizontal") return "landscape";
      return "portrait";
    }catch(e){ return "portrait"; }
  }
  function xsSetPref(v){
    try{ localStorage.setItem(PREF_KEY, v); }catch(e){}
    xsUpdateToggleUI();
    // se já estiver aberto, aplica na hora
    const wrap = xsGetWrap();
    if(wrap && wrap.style.display === "flex"){
      xsApplyView(v);
    }
  }

  function xsUpdateToggleUI(){
    const pBtn = document.getElementById("xsMusicViewPortrait");
    const lBtn = document.getElementById("xsMusicViewLandscape");
    const v = xsGetPref();
    if(pBtn) pBtn.classList.toggle("active", v === "portrait");
    if(lBtn) lBtn.classList.toggle("active", v === "landscape");
  }

  function xsEnsureFrame(){
    const wrap = xsGetWrap();
    if(!wrap) return null;
    let frame = xsGetFrame();
    if(!frame){
      const slot = document.getElementById("xsMusicFrameSlot") || wrap.querySelector(".xs-music-frameSlot");
      if(!slot) return null;
      frame = document.createElement("iframe");
      frame.id = "xsMusicFrame";
      slot.appendChild(frame);
    }
    try{
      frame.title = "Ouvirmusica";
      frame.referrerPolicy = "no-referrer";
      frame.allow = "autoplay; encrypted-media; clipboard-read; clipboard-write; fullscreen";
      frame.setAttribute("allowfullscreen","");
      frame.loading = "eager";
      // se estiver vazio/blank, restaura o site
      const src = (frame.getAttribute("src") || "").trim();
      if(!src || src === "about:blank") frame.setAttribute("src", XS_MUSIC_URL);
    }catch(e){}
    return frame;
  }

  // Fullscreen + orientation handling (mobile-friendly)
  let __xsMusicPrevFs = false;
  let __xsMusicWasLocked = false;
  let __xsMusicResizeHandler = null;

  function __xsMusicApplyRotation(pref){
    const wrap = xsGetWrap();
    if(!wrap) return;
    wrap.classList.remove("force-portrait","force-landscape");
    if(!wrap.classList.contains("is-fullscreen")) return;

    const isLandscape = (window.innerWidth > window.innerHeight);
    if(pref === "portrait" && isLandscape){
      wrap.classList.add("force-portrait");
    } else if(pref === "landscape" && !isLandscape){
      wrap.classList.add("force-landscape");
    }
  }

  async function __xsMusicTryLock(pref){
    try{
      if(screen && screen.orientation && screen.orientation.lock){
        await screen.orientation.lock(pref === "portrait" ? "portrait" : "landscape");
        __xsMusicWasLocked = true;
      }
    }catch(e){ __xsMusicWasLocked = false; }
  }

  async function __xsMusicEnterFullscreen(pref){
    const wrap = xsGetWrap();
    if(!wrap) return;
    __xsMusicPrevFs = !!(document.fullscreenElement || document.webkitFullscreenElement);

    try{
      const target = wrap;
      const req = target.requestFullscreen || target.webkitRequestFullscreen;
      if(req) await req.call(target);
    }catch(e){}

    // tenta travar orientação (funciona melhor em fullscreen)
    await __xsMusicTryLock(pref);
    __xsMusicApplyRotation(pref);
  }

  async function __xsMusicExitFullscreen(){
    const wrap = xsGetWrap();
    if(wrap) wrap.classList.remove("force-portrait","force-landscape");

    // tenta destravar orientação
    try{
      if(__xsMusicWasLocked && screen && screen.orientation && screen.orientation.unlock){
        screen.orientation.unlock();
      }
    }catch(e){}
    __xsMusicWasLocked = false;

    // sai do fullscreen se a gente que entrou
    try{
      const fsEl = (document.fullscreenElement || document.webkitFullscreenElement);
      if(fsEl && !__xsMusicPrevFs){
        if(document.exitFullscreen) await document.exitFullscreen();
        else if(document.webkitExitFullscreen) await document.webkitExitFullscreen();
      }
    }catch(e){}
    __xsMusicPrevFs = false;
  }

  async function xsApplyView(pref){
    const wrap = xsGetWrap();
    if(!wrap) return;

    // quando estiver aberto em fullscreen, tenta aplicar lock da orientação escolhida
    if(wrap.classList.contains("is-fullscreen")){
      await __xsMusicTryLock(pref);
    }
    __xsMusicApplyRotation(pref);
  }

  window.xsOpenMusicBrowser = async function(){
    const wrap = xsGetWrap();
    if(!wrap) return;

    const pref = xsGetPref();
    xsEnsureFrame();
    xsUpdateToggleUI();

    wrap.classList.remove("minimized");
    wrap.classList.add("is-fullscreen");
    wrap.style.display = "flex";
    wrap.setAttribute("aria-hidden","false");

    // tenta fullscreen + orientação; se o navegador bloquear, a rotação CSS segura a experiência
    try{ await __xsMusicEnterFullscreen(pref); }catch(e){}
    __xsMusicApplyRotation(pref);

    __xsMusicResizeHandler = () => __xsMusicApplyRotation(xsGetPref());
    try{ window.addEventListener("resize", __xsMusicResizeHandler, {passive:true}); }catch(e){}
  };

  window.xsMinimizeMusicBrowser = async function(){
    const wrap = xsGetWrap();
    if(!wrap) return;

    // volta para layout padrão do console (horizontal) ao minimizar
    try{ await __xsMusicExitFullscreen(); }catch(e){}
    // tenta travar em landscape pro console (nem sempre permitido)
    try{
      if(screen && screen.orientation && screen.orientation.lock){
        await screen.orientation.lock("landscape");
      }
    }catch(e){}

    wrap.classList.remove("is-fullscreen","force-portrait","force-landscape");
    if(__xsMusicResizeHandler){
      try{ window.removeEventListener("resize", __xsMusicResizeHandler); }catch(e){}
      __xsMusicResizeHandler = null;
    }

    // mantém o iframe vivo; só "some" da tela (tocando em segundo plano)
    wrap.classList.add("minimized");
    wrap.setAttribute("aria-hidden","true");
    try{ if(typeof showToast === "function") showToast("JUKEBOX","Música em segundo plano ativada",null,"library_music"); }catch(e){}
  };

  window.xsStopAndCloseMusicBrowser = async function(){
    const wrap = xsGetWrap();
    if(!wrap) return;

    // volta para layout padrão do console (horizontal) ao fechar
    try{ await __xsMusicExitFullscreen(); }catch(e){}
    try{
      if(screen && screen.orientation && screen.orientation.lock){
        await screen.orientation.lock("landscape");
      }
    }catch(e){}

    wrap.classList.remove("is-fullscreen","force-portrait","force-landscape");
    if(__xsMusicResizeHandler){
      try{ window.removeEventListener("resize", __xsMusicResizeHandler); }catch(e){}
      __xsMusicResizeHandler = null;
    }

    const frame = xsGetFrame();
    if(frame){
      // corta o áudio imediatamente
      try{ frame.setAttribute("src", "about:blank"); }catch(e){}
    }
    wrap.classList.remove("minimized");
    wrap.style.display = "none";
    wrap.setAttribute("aria-hidden","true");
  };

  window.addEventListener("DOMContentLoaded", ()=>{
    const openBtn = document.getElementById("xsOpenMusicBrowserBtn");
    const minBtn = document.getElementById("xsMusicMinBtn");
    const closeBtn = document.getElementById("xsMusicCloseBtn");

    if(openBtn) openBtn.addEventListener("click", ()=>{ window.xsOpenMusicBrowser(); });
    if(minBtn) minBtn.addEventListener("click", ()=>{ window.xsMinimizeMusicBrowser(); });
    if(closeBtn) closeBtn.addEventListener("click", ()=>{ window.xsStopAndCloseMusicBrowser(); });

    const pBtn = document.getElementById("xsMusicViewPortrait");
    const lBtn = document.getElementById("xsMusicViewLandscape");
    if(pBtn) pBtn.addEventListener("click", ()=> xsSetPref("portrait"));
    if(lBtn) lBtn.addEventListener("click", ()=> xsSetPref("landscape"));

    xsUpdateToggleUI();
  });
})();

        function __saveYtPlaylist__(){
            try { localStorage.setItem("xs_ytPlaylist", JSON.stringify(ytPlaylist || [])); } catch(e){}
        }

        function __ytExtractId__(url){
            const s = String(url || "").trim();
            if(!s) return null;
            const m = s.match(/(?:youtu\.be\/|youtube\.com\/(?:watch\?(?:.*&)?v=|embed\/|shorts\/|live\/))([A-Za-z0-9_-]{11})/);
            if(m && m[1]) return m[1];
            const m2 = s.match(/[?&]v=([A-Za-z0-9_-]{11})/);
            return (m2 && m2[1]) ? m2[1] : null;
        }

        async function addYoutubeTrack(url){
            const id = __ytExtractId__(url);
            if(!id){
                try{ showToast("JUKEBOX", "URL inválida", "Cole um link do YouTube", "error"); }catch(e){}
                return false;
            }
            if(Array.isArray(ytPlaylist) && ytPlaylist.some(t => t && t.id === id)){
                try{ showToast("JUKEBOX", "Já está na playlist", id, "playlist_add_check"); }catch(e){}
                return false;
            }

            const tr = { id, title: `YouTube • ${id}`, thumb: `https://i.ytimg.com/vi/${id}/hqdefault.jpg` };

            // tenta obter título/thumbnail via oEmbed (sem API key)
            try{
                const r = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${id}&format=json`);
                if(r && r.ok){
                    const j = await r.json();
                    if(j && j.title) tr.title = String(j.title);
                    if(j && j.thumbnail_url) tr.thumb = String(j.thumbnail_url);
                }
            }catch(e){}

            if(!Array.isArray(ytPlaylist)) ytPlaylist = [];
            ytPlaylist.unshift(tr);
            __saveYtPlaylist__();

            try{ showToast("JUKEBOX", "Sincronizada com o Kernel", tr.title, "cloud_done"); }catch(e){}
            try{ if(typeof __jb2RenderList__ === "function") __jb2RenderList__(true); }catch(e){}
            return true;
        }

        // --- YouTube Embed (JSAPI + postMessage) ---
        // Regras:
        // 1) Sanitização do src: https://www.youtube.com/embed/ID?enablejsapi=1&autoplay=1&mute=0&rel=0&origin= + window.location.origin
        // 2) iframe com allow + sandbox obrigatórios
        // 3) fallback de erro: showToast (restrição de direitos autorais / sem reprodução externa)
        // 4) volume: sincroniza via postMessage (setVolume)

        let __jb2YtIframe = null;
        let __jb2YtReady = false;
        let __jb2YtPendingId = null;
        let __jb2YtLastError = null;
        let __jb2YtLastMsgAt = 0;

        function __jb2YtOrigin__(){
            // Muitos WebViews abrem o HTML com origin "null" (file/content). Isso quebra o JSAPI do YouTube.
            // Sanitiza para um origin https válido quando necessário.
            const o = (window.location && window.location.origin) ? String(window.location.origin) : "";
            if(o && /^https?:\/\/.+/i.test(o) && o !== "null") return o;
            return "https://www.youtube.com";
        }

        function __jb2YtEmbedSrc__(videoId){
            const origin = encodeURIComponent(__jb2YtOrigin__());
            // IMPORTANT: manter o formato solicitado (apenas esses params)
            return "https://www.youtube.com/embed/" + encodeURIComponent(videoId)
                + "?enablejsapi=1&autoplay=1&mute=0&rel=0&origin=" + origin;
        }

        function __jb2EnsureYtIframe__(){
            if(__jb2YtIframe && document.body.contains(__jb2YtIframe)) return __jb2YtIframe;

            let host = document.getElementById("jb2-yt-host");
            if(!host){
                host = document.createElement("div");
                host.id = "jb2-yt-host";
                document.body.appendChild(host);
            }

            // Mantém renderizado (2x2) para evitar bloqueios de áudio em WebViews
            host.style.cssText = "position:fixed; right:6px; bottom:6px; width:2px; height:2px; opacity:0.02; pointer-events:none; z-index:999998; overflow:hidden;";

            host.innerHTML = "";

            const ifr = document.createElement("iframe");
            ifr.id = "jb2YtIframe";
            ifr.src = "about:blank";
            ifr.setAttribute("frameborder", "0");
            ifr.setAttribute("allow", "autoplay; encrypted-media");
            ifr.setAttribute("sandbox", "allow-forms allow-scripts allow-pointer-lock allow-same-origin allow-presentation");
            ifr.setAttribute("referrerpolicy", "no-referrer-when-downgrade");
            ifr.setAttribute("allowfullscreen", "1");
            ifr.style.width = "2px";
            ifr.style.height = "2px";
            ifr.style.border = "0";
            ifr.style.pointerEvents = "none";
            host.appendChild(ifr);

            __jb2YtIframe = ifr;
            return ifr;
        }

        function __jb2YtCmd__(func, args){
            const ifr = __jb2EnsureYtIframe__();
            if(!ifr || !ifr.contentWindow) return;
            const msg = JSON.stringify({ event: "command", func: func, args: (args || []) });
            try{ ifr.contentWindow.postMessage(msg, "*"); }catch(e){}
        }

        // Listener de eventos do player (ready / erro / state)
        window.addEventListener("message", function(e){
            let data = e.data;
            if(typeof data === "string"){
                // YouTube envia JSON string via postMessage
                try{ data = JSON.parse(data); }catch(_){ return; }
            }
            if(!data || typeof data !== "object") return;

            if(data.event === "onReady"){
                __jb2YtReady = true;
                __jb2YtLastError = null;
                __jb2YtLastMsgAt = Date.now();
                try{ __jb2YtCmd__("unMute"); }catch(_){}
                try{ __jb2YtCmd__("setVolume", [Math.round((jb2?.vol ?? 0.55) * 100)]); }catch(_){}
                // se havia pedido pendente, tenta play
                try{ if(__jb2YtPendingId) __jb2YtCmd__("playVideo"); }catch(_){}
            }

            if(data.event === "onStateChange"){
                __jb2YtLastMsgAt = Date.now();
            }

            if(data.event === "onError"){
                __jb2YtLastError = data.info;
                __jb2YtReady = false;
                const vid = __jb2YtPendingId || "";
                try{
                    showToast(
                        "JUKEBOX",
                        "Restrição de reprodução",
                        "Este vídeo possui restrições de direitos autorais e não permite reprodução externa: " + vid,
                        "error"
                    );
                }catch(_){}
            }
        }, false);

        // Ativador (quando o WebView exige toque no player)
        function __jb2ShowYtActivator__(){
            try{
                const wrap = document.getElementById("jb2-yt-activator");
                if(!wrap) return;
                wrap.style.display = "flex";

                const slot = document.getElementById("jb2YtActivatorSlot");
                if(!slot) return;

                const ifr = __jb2EnsureYtIframe__();
                if(ifr){
                    // torna clicável e visível
                    ifr.style.pointerEvents = "auto";
                    ifr.style.opacity = "1";
                    ifr.style.width = "100%";
                    ifr.style.height = "230px";
                    ifr.style.position = "relative";
                    ifr.style.right = "auto";
                    ifr.style.bottom = "auto";
                    ifr.style.zIndex = "auto";
                    slot.innerHTML = "";
                    slot.appendChild(ifr);
                }
            }catch(e){}
        }

        function __jb2HideYtActivator__(){
            try{
                const wrap = document.getElementById("jb2-yt-activator");
                if(wrap) wrap.style.display = "none";

                // devolve iframe pro host (background)
                let host = document.getElementById("jb2-yt-host");
                if(!host){
                    host = document.createElement("div");
                    host.id = "jb2-yt-host";
                    document.body.appendChild(host);
                }
                host.style.cssText = "position:fixed; right:6px; bottom:6px; width:2px; height:2px; opacity:0.02; pointer-events:none; z-index:999998; overflow:hidden;";
                const ifr = __jb2EnsureYtIframe__();
                if(ifr){
                    ifr.style.pointerEvents = "none";
                    ifr.style.opacity = "0.02";
                    ifr.style.width = "2px";
                    ifr.style.height = "2px";
                    ifr.style.position = "static";
                    host.innerHTML = "";
                    host.appendChild(ifr);
                }
            }catch(e){}
        }

        function __jb2SyncYtVol__(){
            try{ __jb2YtCmd__("setVolume", [Math.round((jb2?.vol ?? 0.55) * 100)]); }catch(e){}
        }

        function __jb2PlayYT__(videoId){
            if(!videoId) return;

            __jb2YtPendingId = videoId;
            __jb2YtReady = false;
            __jb2YtLastError = null;
            __jb2YtLastMsgAt = 0;

            const ifr = __jb2EnsureYtIframe__();
            const src = __jb2YtEmbedSrc__(videoId);

            try{ ifr.src = src; }catch(e){}

            // tenta comandos após carregar
            setTimeout(()=>{
                try{ __jb2YtCmd__("unMute"); }catch(e){}
                try{ __jb2SyncYtVol__(); }catch(e){}
                try{ __jb2YtCmd__("playVideo"); }catch(e){}
            }, 450);

            // Fallback: se falhar / não ficar pronto, avisa e abre ativador (toque no play)
            setTimeout(()=>{
                try{
                    if(__jb2YtLastError != null) return; // erro já tratado
                    // sem mensagens do player = provável bloqueio do WebView ou origin inválido
                    const stale = (Date.now() - (__jb2YtLastMsgAt || 0)) > 1500;
                    if(!__jb2YtReady && stale){
                        try{
                            showToast(
                                "JUKEBOX",
                                "Falha ao tocar",
                                "Este vídeo não permite reprodução externa ou o navegador bloqueou o player embutido.",
                                "error"
                            );
                        }catch(e){}
                        __jb2ShowYtActivator__();
                    }
                }catch(e){}
            }, 1400);
        }

        function __jb2PauseYT__(){
            try{ __jb2YtCmd__("pauseVideo"); }catch(e){}
        }


        function __jb2EnsureCtx(){
            if(jb2.ctx) return;
            // Reusa o mesmo audioCtx do sistema se existir e estiver ok
            // (mas evita conflito criando um ctx separado se necessário)
            try{
                jb2.ctx = audioCtx; // usa o ctx global do console (já existe)
            }catch(e){
                jb2.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            jb2.master = jb2.ctx.createGain();
            jb2.master.gain.value = jb2.vol;

            // corta sub-grave e reduz "boom"
            jb2.hp = jb2.ctx.createBiquadFilter();
            jb2.hp.type = "highpass";
            jb2.hp.frequency.value = 190;
            jb2.hp.Q.value = 0.7;

            jb2.lowShelf = jb2.ctx.createBiquadFilter();
            jb2.lowShelf.type = "lowshelf";
            jb2.lowShelf.frequency.value = 180;
            jb2.lowShelf.gain.value = -10;

            jb2.comp = jb2.ctx.createDynamicsCompressor();
            jb2.comp.threshold.value = -24;
            jb2.comp.knee.value = 18;
            jb2.comp.ratio.value = 3.2;
            jb2.comp.attack.value = 0.01;
            jb2.comp.release.value = 0.18;

            jb2.lp = jb2.ctx.createBiquadFilter();
            jb2.lp.type = "lowpass";
            jb2.lp.frequency.value = 15000;

            jb2.master.connect(jb2.hp);
            jb2.hp.connect(jb2.lowShelf);
            jb2.lowShelf.connect(jb2.comp);
            jb2.comp.connect(jb2.lp);
            jb2.lp.connect(jb2.ctx.destination);
        }

        function __jb2Now(){
            return jb2.ctx.currentTime;
        }

        function __jb2Schedule(){
            const tr = JB2_TRACKS[jb2.cur];
            const secondsPerBeat = 60.0 / tr.bpm;
            const secondsPerStep = secondsPerBeat / 4; // 16 steps per bar
            while(jb2.nextNoteTime < __jb2Now() + jb2.scheduleAhead){
                __jb2PlayStep(tr, jb2.step, jb2.nextNoteTime);
                jb2.nextNoteTime += secondsPerStep;
                jb2.step = (jb2.step + 1) % (jb2.stepsPerBar * jb2.bars);
            }
        }

        function __jb2TrigOsc(time, freq, type, dur, vol, det=0){
            const o = jb2.ctx.createOscillator();
            const g = jb2.ctx.createGain();
            o.type = type;
            o.frequency.setValueAtTime(freq, time);
            if(det) o.detune.setValueAtTime(det, time);
            g.gain.setValueAtTime(0.0001, time);
            g.gain.exponentialRampToValueAtTime(vol, time + 0.01);
            g.gain.exponentialRampToValueAtTime(0.0001, time + dur);
            o.connect(g);
            g.connect(jb2.master);
            o.start(time);
            o.stop(time + dur + 0.02);
        }

        function __jb2TrigNoise(time, dur, vol, hp=4000){
            const bufferSize = Math.floor(jb2.ctx.sampleRate * dur);
            const buffer = jb2.ctx.createBuffer(1, bufferSize, jb2.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * (1 - i/bufferSize);
            const src = jb2.ctx.createBufferSource();
            src.buffer = buffer;
            const f = jb2.ctx.createBiquadFilter();
            f.type = "highpass";
            f.frequency.value = hp;
            const g = jb2.ctx.createGain();
            g.gain.setValueAtTime(vol, time);
            g.gain.exponentialRampToValueAtTime(0.0001, time + dur);
            src.connect(f); f.connect(g); g.connect(jb2.master);
            src.start(time);
            src.stop(time + dur + 0.02);
        }

        function __midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }

        function __jb2PlayStep(tr, stepAbs, time){
            const step = stepAbs % 16;
            const bar = Math.floor(stepAbs / 16);

            // hats
            if(tr.pat.h[step]){
                __jb2TrigNoise(time, 0.035, 0.05, 6500);
            }
            // snare
            if(tr.pat.s[step]){
                __jb2TrigNoise(time, 0.12, 0.14, 2500);
                __jb2TrigOsc(time, 190, "triangle", 0.08, 0.05);
            }
            // kick (bem mais leve)
            if(tr.pat.k[step]){
                // pitch drop curto, mas volume baixo
                const o = jb2.ctx.createOscillator();
                const g = jb2.ctx.createGain();
                o.type = "sine";
                o.frequency.setValueAtTime(120, time);
                o.frequency.exponentialRampToValueAtTime(48, time + 0.10);
                g.gain.setValueAtTime(0.0001, time);
                g.gain.exponentialRampToValueAtTime(0.12, time + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, time + 0.11);
                o.connect(g); g.connect(jb2.master);
                o.start(time); o.stop(time + 0.13);
            }

            // bass: toca em 8th notes (steps 0,2,4...)
            if(step % 2 === 0){
                const idx = ((bar*8) + (step/2)) % tr.pat.bass.length;
                const note = tr.pat.bass[idx];
                // Bass sem sub: square filtrado pelo HP+lowShelf e volume moderado
                __jb2TrigOsc(time, __midiToHz(note), "square", 0.12, (tr.genre==="Ambient"?0.05:0.07));
            }

            // lead: 16 steps
            const ln = tr.pat.lead[step];
            if(ln != null){
                const hz = __midiToHz(ln);
                const bright = (tr.genre==="Eletrônica") ? 0.08 : (tr.genre==="Phonk") ? 0.07 : 0.06;
                __jb2TrigOsc(time, hz, "sawtooth", 0.09, bright, (Math.random()*8-4));
                // pequeno chorus fake: segunda voz detunada
                if(Math.random() > 0.78) __jb2TrigOsc(time+0.005, hz, "triangle", 0.08, bright*0.55, 7);
            }
        }

        function jb2Start(){
            __jb2EnsureCtx();
            if(jb2.ctx.state === "suspended"){
                jb2.ctx.resume().catch(()=>{});
            }
            jb2.isPlaying = true;
            jb2.step = 0;
            jb2.nextNoteTime = __jb2Now();
            if(jb2.timer) clearInterval(jb2.timer);
            jb2.timer = setInterval(__jb2Schedule, jb2.lookaheadMs);
            __jb2UI();
        }

        function jb2Stop(){
            jb2.isPlaying = false;
            if(jb2.timer){ clearInterval(jb2.timer); jb2.timer = null; }
            __jb2UI();
        }

        function jb2Toggle(){
            if(jb2.isPlaying) jb2Stop(); else jb2Start();
        }

        function jb2SetTrack(idx){
            jb2.cur = (idx + JB2_TRACKS.length) % JB2_TRACKS.length;
            // reseta loop pra não ficar "cortado"
            jb2.step = 0;
            jb2.nextNoteTime = __jb2Now();
            __jb2UI();
        }

        function jb2Next(){ jb2SetTrack(jb2.cur + 1); if(jb2.isPlaying) jb2Start(); }
        function jb2Prev(){ jb2SetTrack(jb2.cur - 1); if(jb2.isPlaying) jb2Start(); }
        function jb2Random(){ jb2SetTrack(Math.floor(Math.random()*JB2_TRACKS.length)); if(jb2.isPlaying) jb2Start(); }

        function __jb2UI(){
            const t = JB2_TRACKS[jb2.cur];
            const titleEl = document.getElementById("jb2Title");
            const subEl = document.getElementById("jb2Sub");
            const playBtn = document.getElementById("jb2Play");
            if(titleEl) titleEl.textContent = `${t.name}`;
            if(subEl) subEl.textContent = `${t.genre} • ${t.bpm} BPM • Loop ${jb2.bars} barras`;
            if(playBtn) playBtn.textContent = jb2.isPlaying ? "❚❚" : "▶";

            const list = document.getElementById("jb2List");
            if(list && !list.dataset.ready){
                list.dataset.ready = "1";
                list.innerHTML = "";
                JB2_TRACKS.forEach((tr, i) => {
                    const row = document.createElement("div");
                    row.className = "jb2-row";
                    row.innerHTML = `<div><div style="font-weight:800; color:#fff; font-size:0.95rem;">${tr.name}</div><div class="meta">${tr.genre}</div></div><div class="meta">${tr.bpm} BPM</div>`;
                    row.onclick = () => { jb2SetTrack(i); jb2Start(); __jb2Highlight(); };
                    list.appendChild(row);
                });
            }
            __jb2Highlight();
        }

        function __jb2Highlight(){
            const list = document.getElementById("jb2List");
            if(!list) return;
            [...list.children].forEach((ch, i) => ch.classList.toggle("active", i === jb2.cur));
        }

        function openJukebox(){
            openModal("jukebox-modal");
            // inicializa UI e mantém música tocando (sem parar ao fechar)
            __jb2EnsureCtx();
            // carrega volume salvo
            try{
                const v = parseFloat(localStorage.getItem("xs_jb2_vol") || "");
                if(!isNaN(v)) jb2.vol = Math.min(1, Math.max(0, v));
            }catch(e){}
            if(jb2.master) jb2.master.gain.value = jb2.vol;

            // se nunca tocou, começa já (1º gesto do usuário)
            if(!jb2.isPlaying){
                // Em modo YouTube, alguns navegadores bloqueiam autoplay mesmo com UI aberta.
                // Então só inicia automaticamente o modo synth; YT começa quando o usuário tocar Play/selecionar.
                if((jb2.mode || "synth") !== "yt") jb2Start();
            }
            __jb2UI();
            __jb2BindOnce();
        }

        let __jb2Bound = false;
        function __jb2BindOnce(){
            if(__jb2Bound) return;
            __jb2Bound = true;

            const prev = document.getElementById("jb2Prev");
            const next = document.getElementById("jb2Next");
            const play = document.getElementById("jb2Play");
            const vol = document.getElementById("jb2Vol");
            const volTxt = document.getElementById("jb2VolTxt");
            const rnd = document.getElementById("jb2Random");

            

            const addYT = document.getElementById("jb2AddYT");
            const ytLink = document.getElementById("jb2YtLinkBtn");
            const ytInput = document.getElementById("jb2YtUrl");

            const ytUnlock = document.getElementById("jb2YtUnlock");
            const actClose = document.getElementById("jb2YtActClose");
            const actOk = document.getElementById("jb2YtActOk");
if(prev) prev.onclick = () => { jb2Prev(); __jb2Highlight(); };
            if(next) next.onclick = () => { jb2Next(); __jb2Highlight(); };
            if(play) play.onclick = () => jb2Toggle();
            if(rnd) rnd.onclick = () => { jb2Random(); __jb2Highlight(); };

            
            if(addYT) addYT.onclick = () => { try{ openModal("jb2-yt-modal"); }catch(e){} try{ if(ytInput) ytInput.focus(); }catch(e){} };
            if(ytLink) ytLink.onclick = async () => {
                try{
                    const ok = await addYoutubeTrack(ytInput ? ytInput.value : "");
                    if(ok){ try{ closeModal("jb2-yt-modal"); }catch(e){} try{ if(ytInput) ytInput.value = ""; }catch(e){} }
                }catch(e){}
            };
            // Preload YouTube API early to keep play inside user gesture as much as possible
            try{ __jb2EnsureYtApi__().then(()=>{ try{ __jb2InitYtPlayer__(); }catch(e){} }); }catch(e){}

            if(ytUnlock) ytUnlock.onclick = () => {
                try{
                    showToast("JUKEBOX","Ativar áudio do YouTube","Se não sair som, toque no play dentro do quadro 1 vez.","info");
                }catch(e){}
                __jb2ShowYtActivator__();
            };
            if(actClose) actClose.onclick = () => { __jb2HideYtActivator__(); };
            if(actOk) actOk.onclick = () => {
                __jb2HideYtActivator__();
                // tenta dar play novamente com unmute + volume do jb2Vol
                try{
                    if(true){
                        try{ __jb2YtCmd__('unMute'); }catch(e){}
                        try{ __jb2SyncYtVol__(); }catch(e){}
                        try{ __jb2YtCmd__('playVideo'); }catch(e){}
                    }
                }catch(e){}
            };

            if(ytInput) ytInput.addEventListener("keydown", (ev)=>{ if(ev.key==="Enter"){ ev.preventDefault(); try{ ytLink && ytLink.click(); }catch(e){} } });
if(vol){
                vol.value = jb2.vol;
                if(volTxt) volTxt.textContent = Math.round(jb2.vol*100) + "%";
                vol.oninput = () => {
                    jb2.vol = parseFloat(vol.value);
                    if(jb2.master) jb2.master.gain.value = jb2.vol;
                    
                    try{ __jb2SyncYtVol__(); }catch(e){}
if(volTxt) volTxt.textContent = Math.round(jb2.vol*100) + "%";
                    try{ localStorage.setItem("xs_jb2_vol", String(jb2.vol)); }catch(e){}
                };
            }

            // Garantia: primeiro toque/tecla resume o áudio (celular)
            const resume = () => {
                try{
                    __jb2EnsureCtx();
                    if(jb2.ctx && jb2.ctx.state === "suspended") jb2.ctx.resume().catch(()=>{});
                }catch(e){}
                window.removeEventListener("pointerdown", resume);
                window.removeEventListener("keydown", resume);
            };
            window.addEventListener("pointerdown", resume, { once:true });
            window.addEventListener("keydown", resume, { once:true });
        }
    


        // =========================
        // PATCH: Integração YT no player da Jukebox (modo synth/yt + lista híbrida)
        // =========================
        function __jb2SwitchMode__(mode){
            jb2.mode = jb2.mode || "synth";
            if(jb2.mode === mode) return;

            // Para o que estiver tocando
            if(jb2.mode === "synth"){
                try{ if(jb2.timer){ clearInterval(jb2.timer); jb2.timer = null; } }catch(e){}
            } else if(jb2.mode === "yt"){
                try{ __jb2PauseYT__(); }catch(e){}
            }
            jb2.isPlaying = false;
            jb2.mode = mode;
        }

        function jb2SetTrack(idx){
            __jb2SwitchMode__("synth");
            jb2.cur = (idx + JB2_TRACKS.length) % JB2_TRACKS.length;
            jb2.step = 0;
            jb2.nextNoteTime = __jb2Now();
            __jb2UI();
        }

        function jb2SetYTTrack(idx){
            if(!Array.isArray(ytPlaylist) || !ytPlaylist.length) return;
            idx = (idx + ytPlaylist.length) % ytPlaylist.length;
            const tr = ytPlaylist[idx];
            if(!tr) return;
            __jb2SwitchMode__("yt");
            jb2.ytCur = idx;
            jb2.ytId = tr.id;
            __jb2UI();
        }

        function jb2Start(){
            __jb2EnsureCtx();
            if(jb2.ctx && jb2.ctx.state === "suspended"){
                jb2.ctx.resume().catch(()=>{});
            }
            jb2.mode = jb2.mode || "synth";

            if(jb2.mode === "yt"){
                jb2.isPlaying = true;
                __jb2PlayYT__(jb2.ytId);
                __jb2UI();
                return;
            }

            // synth
            jb2.isPlaying = true;
            jb2.step = 0;
            jb2.nextNoteTime = __jb2Now();
            if(jb2.timer) clearInterval(jb2.timer);
            jb2.timer = setInterval(__jb2Schedule, jb2.lookaheadMs);
            __jb2UI();
        }

        function jb2Stop(){
            jb2.mode = jb2.mode || "synth";
            if(jb2.mode === "yt"){
                jb2.isPlaying = false;
                __jb2PauseYT__();
                __jb2UI();
                return;
            }
            // synth
            jb2.isPlaying = false;
            if(jb2.timer){ clearInterval(jb2.timer); jb2.timer = null; }
            __jb2UI();
        }

        function jb2Toggle(){
            if(jb2.isPlaying) jb2Stop(); else jb2Start();
        }

        function jb2Next(){
            jb2.mode = jb2.mode || "synth";
            if(jb2.mode === "yt" && Array.isArray(ytPlaylist) && ytPlaylist.length){
                jb2SetYTTrack((jb2.ytCur|0) + 1);
                jb2Start();
                __jb2Highlight();
                return;
            }
            jb2SetTrack((jb2.cur|0) + 1);
            if(jb2.isPlaying) jb2Start();
            __jb2Highlight();
        }
        function jb2Prev(){
            jb2.mode = jb2.mode || "synth";
            if(jb2.mode === "yt" && Array.isArray(ytPlaylist) && ytPlaylist.length){
                jb2SetYTTrack((jb2.ytCur|0) - 1);
                jb2Start();
                __jb2Highlight();
                return;
            }
            jb2SetTrack((jb2.cur|0) - 1);
            if(jb2.isPlaying) jb2Start();
            __jb2Highlight();
        }
        function jb2Random(){
            jb2.mode = jb2.mode || "synth";
            if(jb2.mode === "yt" && Array.isArray(ytPlaylist) && ytPlaylist.length){
                jb2SetYTTrack(Math.floor(Math.random()*ytPlaylist.length));
                jb2Start();
                __jb2Highlight();
                return;
            }
            jb2SetTrack(Math.floor(Math.random()*JB2_TRACKS.length));
            if(jb2.isPlaying) jb2Start();
            __jb2Highlight();
        }

        function __jb2RenderList__(force){
            const list = document.getElementById("jb2List");
            if(!list) return;

            // refresh playlist from storage (caso outro módulo tenha mexido)
            try{
                const fresh = JSON.parse(localStorage.getItem("xs_ytPlaylist") || "[]") || [];
                if(Array.isArray(fresh)) ytPlaylist = fresh;
            }catch(e){}

            const ytIds = (Array.isArray(ytPlaylist) ? ytPlaylist.map(t=>t && t.id).filter(Boolean) : []);
            const sig = `${JB2_TRACKS.length}|${ytIds.length}|${ytIds.slice(0,6).join(",")}|${ytIds.slice(-2).join(",")}`;
            if(!force && list.dataset.sig === sig) return;

            list.dataset.sig = sig;
            list.innerHTML = "";

            // YT section
            if(Array.isArray(ytPlaylist) && ytPlaylist.length){
                const sec = document.createElement("div");
                sec.className = "jb2-section";
                sec.innerHTML = `<div>YOUTUBE MUSIC</div><div class="jb2-badge">${ytPlaylist.length} SALVAS</div>`;
                list.appendChild(sec);

                ytPlaylist.forEach((tr, i) => {
                    const row = document.createElement("div");
                    row.className = "jb2-row";
                    row.dataset.mode = "yt";
                    row.dataset.idx = String(i);
                    const safeTitle = String(tr.title || `YouTube • ${tr.id}`).replace(/</g,"&lt;");
                    const safeThumb = String(tr.thumb || `https://i.ytimg.com/vi/${tr.id}/hqdefault.jpg`).replace(/"/g,"&quot;");
                    row.innerHTML = `
                        <div class="jb2-row-left">
                            <img class="jb2-thumb" src="${safeThumb}" alt="">
                            <div style="min-width:0; flex:1;">
                                <div class="jb2-title2">${safeTitle}</div>
                                <div class="meta">YouTube • Áudio em background</div>
                            </div>
                        </div>
                        <div class="meta">YT</div>
                    `;
                    row.onclick = () => { jb2SetYTTrack(i); jb2Start(); __jb2Highlight(); };
                    list.appendChild(row);
                });
            } else {
                const sec = document.createElement("div");
                sec.className = "jb2-section";
                sec.innerHTML = `<div>YOUTUBE MUSIC</div><div class="jb2-badge">VAZIO</div>`;
                list.appendChild(sec);

                const empty = document.createElement("div");
                empty.style.padding = "10px 12px";
                empty.style.color = "#9aa";
                empty.style.fontSize = "0.82rem";
                empty.style.lineHeight = "1.3";
                empty.innerHTML = `Toque em <b>ADICIONAR MÚSICA YT</b> e vincule uma URL para salvar aqui.`;
                list.appendChild(empty);
            }

            // Synth section
            const sec2 = document.createElement("div");
            sec2.className = "jb2-section";
            sec2.innerHTML = `<div>LOOPS XS (SISTEMA)</div><div class="jb2-badge">${JB2_TRACKS.length}</div>`;
            list.appendChild(sec2);

            JB2_TRACKS.forEach((tr, i) => {
                const row = document.createElement("div");
                row.className = "jb2-row";
                row.dataset.mode = "synth";
                row.dataset.idx = String(i);
                row.innerHTML = `<div><div style="font-weight:800; color:#fff; font-size:0.95rem;">${tr.name}</div><div class="meta">${tr.genre}</div></div><div class="meta">${tr.bpm} BPM</div>`;
                row.onclick = () => { jb2SetTrack(i); jb2Start(); __jb2Highlight(); };
                list.appendChild(row);
            });
        }

        function __jb2UI(){
            __jb2RenderList__(false);

            const titleEl = document.getElementById("jb2Title");
            const subEl = document.getElementById("jb2Sub");
            const playBtn = document.getElementById("jb2Play");
            jb2.mode = jb2.mode || "synth";

            if(jb2.mode === "yt"){
                const tr = (Array.isArray(ytPlaylist) && ytPlaylist[jb2.ytCur]) ? ytPlaylist[jb2.ytCur] : null;
                const nm = tr ? (tr.title || ("YouTube • " + tr.id)) : "YouTube Music";
                if(titleEl) titleEl.textContent = nm;
                if(subEl) subEl.textContent = "YouTube • Áudio em segundo plano (player oficial)";
                if(playBtn) playBtn.textContent = jb2.isPlaying ? "❚❚" : "▶";
            } else {
                const t = JB2_TRACKS[jb2.cur];
                if(titleEl) titleEl.textContent = `${t.name}`;
                if(subEl) subEl.textContent = `${t.genre} • ${t.bpm} BPM • Loop ${jb2.bars} barras`;
                if(playBtn) playBtn.textContent = jb2.isPlaying ? "❚❚" : "▶";
            }

            __jb2Highlight();
        }

        function __jb2Highlight(){
            const list = document.getElementById("jb2List");
            if(!list) return;
            const rows = [...list.querySelectorAll(".jb2-row")];
            rows.forEach((row) => {
                const mode = row.dataset.mode;
                const idx = parseInt(row.dataset.idx||"-1",10);
                let active = false;
                if(mode === "yt") active = (jb2.mode === "yt" && idx === (jb2.ytCur|0));
                if(mode === "synth") active = (jb2.mode !== "yt" && idx === (jb2.cur|0));
                row.classList.toggle("active", !!active);
            });
        }

        function openJukebox(){
            openModal("jukebox-modal");
            __jb2EnsureCtx();

            // recarrega ytPlaylist e volume salvo
            try{
                const fresh = JSON.parse(localStorage.getItem("xs_ytPlaylist") || "[]") || [];
                if(Array.isArray(fresh)) ytPlaylist = fresh;
            }catch(e){}
            try{
                const v = parseFloat(localStorage.getItem("xs_jb2_vol") || "");
                if(!isNaN(v)) jb2.vol = Math.min(1, Math.max(0, v));
            }catch(e){}
            if(jb2.master) jb2.master.gain.value = jb2.vol;
            try{ __jb2SyncYtVol__(); }catch(e){}

            jb2.mode = jb2.mode || "synth";

            // se está em yt e não tem item selecionado, escolhe a primeira
            if(jb2.mode === "yt" && Array.isArray(ytPlaylist) && ytPlaylist.length && (jb2.ytCur < 0)){
                jb2SetYTTrack(0);
            }

            // se nunca tocou, começa já (1º gesto do usuário)
            if(!jb2.isPlaying){
                // Em modo YouTube, alguns navegadores bloqueiam autoplay mesmo com UI aberta.
                // Então só inicia automaticamente o modo synth; YT começa quando o usuário tocar Play/selecionar.
                if((jb2.mode || "synth") !== "yt") jb2Start();
            }
            __jb2UI();
            __jb2BindOnce();
        }


        // --- ENGINE DE ÁUDIO ---
        function playSysSound(f, type, d) {
            // Patch Estabilidade: evita vazamentos e explosão de nós de áudio
            try {
                if (!systemSettings || !systemSettings.sfx) return;
                const ctx = audioCtx;
                if (!ctx) return;

                // throttle (evita spam em loops rápidos)
                if (!window.__xsSfx) window.__xsSfx = { lastMs: 0, master: null };
                const nowMs = (window.performance && performance.now) ? performance.now() : Date.now();
                if (nowMs - (window.__xsSfx.lastMs || 0) < 18) return;
                window.__xsSfx.lastMs = nowMs;

                if (ctx.state === "suspended") { ctx.resume().catch(()=>{}); }

                // master gain (reutilizado)
                if (!window.__xsSfx.master) {
                    try {
                        const mg = ctx.createGain();
                        mg.gain.value = 1;
                        mg.connect(ctx.destination);
                        window.__xsSfx.master = mg;
                    } catch(e) {
                        window.__xsSfx.master = null;
                    }
                }
                const master = window.__xsSfx.master;
                if (!master) return;

                const o = ctx.createOscillator();
                const g = ctx.createGain();

                // extra nodes (para pacotes SFX avançados)
                let o2 = null, g2 = null;
                let filter = null;
                let delay = null, fb = null;
                let lfo = null, lfoGain = null;


                const vol = Math.max(0, Math.min(1, (systemSettings.volume ?? 0.5)));
                let dur = (typeof d === "number" && d > 0) ? d : 0.08;
                const t0 = ctx.currentTime;

                const baseF = (typeof f === "number" && f > 0) ? f : 440;
                const pack = systemSettings.sfxPack || "standard";

                // baseline envelope
                g.gain.setValueAtTime(0.0001, t0);

                if (pack === "8bit") {
                    o.type = "square";
                    o.frequency.setValueAtTime(baseF * 0.8, t0);
                    dur = 0.10;
                    g.gain.setValueAtTime(vol * 0.22, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "futuristic") {
                    o.type = "sine";
                    o.frequency.setValueAtTime(baseF * 2, t0);
                    o.frequency.exponentialRampToValueAtTime(baseF, t0 + 0.20);
                    dur = Math.max(dur, 0.12);
                    g.gain.setValueAtTime(vol * 0.12, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "cinematic") {
                    o.type = "triangle";
                    o.frequency.setValueAtTime(baseF * 0.6, t0);
                    o.frequency.exponentialRampToValueAtTime(baseF * 1.4, t0 + 0.08);
                    dur = 0.18;
                    g.gain.setValueAtTime(vol * 0.18, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "glitch") {
                    o.type = "sawtooth";
                    o.frequency.setValueAtTime(baseF * (1 + (Math.random()*0.25-0.12)), t0);
                    o.detune.setValueAtTime((Math.random()*1200-600), t0);
                    dur = 0.12;
                    g.gain.setValueAtTime(vol * 0.16, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "lofi") {
                    o.type = "sine";
                    o.frequency.setValueAtTime(baseF * 0.9, t0);
                    dur = Math.max(dur, 0.10);
                    g.gain.setValueAtTime(vol * 0.10, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "retrorpg") {
                    o.type = "triangle";
                    o.frequency.setValueAtTime(baseF * 0.95, t0);
                    dur = Math.max(dur, 0.12);
                    // vibrato leve
                    lfo = ctx.createOscillator();
                    lfoGain = ctx.createGain();
                    lfo.frequency.setValueAtTime(12, t0);
                    lfoGain.gain.setValueAtTime(baseF * 0.03, t0);
                    lfo.connect(lfoGain);
                    lfoGain.connect(o.frequency);
                    g.gain.setValueAtTime(vol * 0.14, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "heavymetal") {
                    o.type = "sawtooth";
                    o.frequency.setValueAtTime(baseF * 0.55, t0);
                    dur = Math.max(dur, 0.14);
                    filter = ctx.createBiquadFilter();
                    filter.type = "lowpass";
                    filter.frequency.setValueAtTime(1400, t0);
                    filter.Q.setValueAtTime(9, t0);
                    g.gain.setValueAtTime(vol * 0.22, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "waterdrops") {
                    o.type = "sine";
                    o.frequency.setValueAtTime(baseF * 2.4, t0);
                    o.frequency.exponentialRampToValueAtTime(baseF * 0.9, t0 + 0.16);
                    dur = 0.20;
                    g.gain.setValueAtTime(vol * 0.13, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "spacecabin") {
                    o.type = "sine";
                    o.frequency.setValueAtTime(baseF * 1.25, t0);
                    dur = Math.max(dur, 0.18);
                    // echo curto
                    delay = ctx.createDelay(0.4);
                    delay.delayTime.setValueAtTime(0.12, t0);
                    fb = ctx.createGain();
                    fb.gain.setValueAtTime(0.22, t0);
                    g.gain.setValueAtTime(vol * 0.12, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "ghostly") {
                    o.type = "triangle";
                    o.frequency.setValueAtTime(baseF * 0.75, t0);
                    dur = 0.28;
                    // ataque e cauda
                    g.gain.setValueAtTime(0.0001, t0);
                    g.gain.linearRampToValueAtTime(vol * 0.12, t0 + 0.06);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "mechanical") {
                    o.type = "square";
                    o.frequency.setValueAtTime(baseF * 1.1, t0);
                    dur = 0.14;
                    // tremolo por steps
                    const peak = vol * 0.16;
                    g.gain.setValueAtTime(0.0001, t0);
                    for (let i = 0; i < 6; i++) {
                        const ti = t0 + (i * 0.02);
                        g.gain.setValueAtTime((i % 2 === 0) ? peak : (peak * 0.25), ti);
                    }
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "lasergun") {
                    o.type = "sawtooth";
                    o.frequency.setValueAtTime(baseF * 4.2, t0);
                    o.frequency.exponentialRampToValueAtTime(baseF * 0.65, t0 + 0.14);
                    dur = 0.16;
                    g.gain.setValueAtTime(vol * 0.16, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "bassboosted") {
                    o.type = "sine";
                    o.frequency.setValueAtTime(baseF * 0.55, t0);
                    dur = Math.max(dur, 0.16);
                    o2 = ctx.createOscillator();
                    g2 = ctx.createGain();
                    o2.type = "sine";
                    o2.frequency.setValueAtTime(baseF * 0.28, t0);
                    g2.gain.setValueAtTime(vol * 0.10, t0);
                    g2.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                    g.gain.setValueAtTime(vol * 0.18, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "orchestral") {
                    o.type = "triangle";
                    o.frequency.setValueAtTime(baseF * 0.78, t0);
                    o.frequency.exponentialRampToValueAtTime(baseF * 1.18, t0 + 0.10);
                    dur = 0.22;
                    // camada 2 levemente desafinada
                    o2 = ctx.createOscillator();
                    g2 = ctx.createGain();
                    o2.type = "triangle";
                    o2.frequency.setValueAtTime(baseF * 0.80, t0);
                    o2.detune.setValueAtTime(7, t0);
                    g2.gain.setValueAtTime(vol * 0.08, t0);
                    g2.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                    g.gain.setValueAtTime(vol * 0.14, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                } else if (pack === "silent") {
                    return;
                } else {
                    o.type = type || "sine";
                    o.frequency.setValueAtTime(baseF, t0);
                    g.gain.setValueAtTime(vol * 0.12, t0);
                    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
                }


                // conexões (com suporte a filtros/echo e segunda camada)
                if (filter) {
                    o.connect(filter);
                    filter.connect(g);
                } else {
                    o.connect(g);
                }
                g.connect(master);

                if (delay) {
                    g.connect(delay);
                    delay.connect(master);
                    if (fb) { delay.connect(fb); fb.connect(delay); }
                }

                if (o2 && g2) {
                    o2.connect(g2);
                    g2.connect(master);
                }

                const cleanup = () => {
                    try { o.disconnect(); } catch(e) {}
                    try { g.disconnect(); } catch(e) {}
                    try { if (filter) filter.disconnect(); } catch(e) {}
                    try { if (delay) delay.disconnect(); } catch(e) {}
                    try { if (fb) fb.disconnect(); } catch(e) {}
                    try { if (o2) o2.disconnect(); } catch(e) {}
                    try { if (g2) g2.disconnect(); } catch(e) {}
                    try { if (lfo) lfo.disconnect(); } catch(e) {}
                    try { if (lfoGain) lfoGain.disconnect(); } catch(e) {}
                };
                o.onended = cleanup;
                if (o2) o2.onended = cleanup;

                o.start(t0);
                o.stop(t0 + dur);
                if (o2) { o2.start(t0); o2.stop(t0 + dur); }
                if (lfo) { lfo.start(t0); lfo.stop(t0 + dur); }

                // safety cleanup
                setTimeout(cleanup, Math.ceil((dur + 0.06) * 1000));

            } catch(e) {}
        }

        async function forceFullscreen() { 
            const el = document.documentElement; if (el.requestFullscreen) await el.requestFullscreen().catch(()=>{});
            if (screen.orientation && screen.orientation.lock) await screen.orientation.lock("landscape").catch(() => {});
        }

        window.onload = () => {
            applySavedSettings();
            updateCoinDisplay();
            evaluateMilestones();
            checkAchievement("first_boot");
            
            // CORREÇÃO TELA PRETA: Se intro estiver off, esconde o layer imediatamente
            if(systemSettings.intro) {
                playBootSequence(); 
            } else { 
                document.getElementById('intro-layer').style.display = "none"; 
                document.getElementById('user-select-layer').style.display = "flex"; 
                state = "LOGIN"; 
            }
        };

        // --- BOOT SEQUENCE ---
        function playBootSequence() {
            const layer = document.getElementById('intro-layer');
            layer.className = ""; layer.innerHTML = "";
            if(systemSettings.introType === "retro") { layer.className = "intro-retro"; layer.innerHTML = `<div class="xs-logo">XUXUBISTATION BIOS v5.5... OK<br>CHECKING MEMORY... OK<br>LOADING KERNEL... OK</div><div class="powered-by">SYSTEM READY_</div>`; } 
            else if(systemSettings.introType === "cyber") {
                layer.className = "intro-cyber";
                layer.innerHTML = `
                    <div class="xs-logo" data-text="XS">XS</div>
                    <div class="cyber-tag">SYSTEM BREACH</div>
                    <div class="cyber-console">
                        <div>XS kernel .......... <span class="ok">OK</span></div>
                        <div>xuxubis drive ...... <span class="ok">MOUNTED</span></div>
                        <div>XC wallet .......... <span class="ok">SYNC</span></div>
                        <div>security layer ...... <span class="ok">BYPASS</span></div>
                    </div>
                    <div class="cyber-bar"><div class="fill"></div></div>
                    <div class="powered-by">ACCESS GRANTED</div>
                `;
            } 
            else if(systemSettings.introType === "static") { layer.className = "intro-static"; layer.innerHTML = `<div class="xs-logo">XS</div>`; }
            else if(systemSettings.introType === "dvd") { layer.className = "intro-dvd"; layer.innerHTML = `<div class="xs-logo">XS</div>`; }
            else if(systemSettings.introType === "pulse") { layer.className = "intro-pulse"; layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">PULSE MODE</div>`; }
            else if(systemSettings.introType === "grid") { layer.className = "intro-grid"; layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">GRID SCAN</div>`; }
            else if(systemSettings.introType === "holo") { layer.className = "intro-holo"; layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">HOLO BOOT</div>`; }

            else if(systemSettings.introType === "x360") {
                layer.className = "intro-x360";
                layer.innerHTML = `
                    <div class="x360-orb o1"></div>
                    <div class="x360-orb o2"></div>
                    <div class="x360-orb o3"></div>
                    <div class="x360-orb o4"></div>
                    <div class="x360-core"></div>
                    <div class="xs-logo">XS</div>
                    <div class="powered-by">X360 BOOT</div>
                `;
            }
            else if(systemSettings.introType === "matrixrain") {
                layer.className = "intro-matrixrain";
                layer.innerHTML = `<div class="matrix"></div><div class="xs-logo">XS</div><div class="powered-by">MATRIX RAIN</div>`;
            }
            else if(systemSettings.introType === "glitchv2") {
                layer.className = "intro-glitchv2";
                layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">GLITCH v2</div>`;
            }
            else if(systemSettings.introType === "starfield") {
                layer.className = "intro-starfield";
                layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">STARFIELD</div>`;
            }
            else if(systemSettings.introType === "biohazard") {
                layer.className = "intro-biohazard";
                layer.innerHTML = `<div class="haz-ring"></div><div class="xs-logo">XS</div><div class="powered-by">BIOHAZARD ALERT</div>`;
            }
            else if(systemSettings.introType === "aurora") {
                layer.className = "intro-aurora";
                layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">AURORA</div>`;
            }
            else if(systemSettings.introType === "scanline") {
                layer.className = "intro-scanline";
                layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">SCANLINE</div>`;
            }
            else if(systemSettings.introType === "quantum") {
                layer.className = "intro-quantum";
                layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">QUANTUM</div>`;
            }
            else if(systemSettings.introType === "vhs") {
                layer.className = "intro-vhs";
                layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">VHS</div>`;
            }
            else if(systemSettings.introType === "bloom") {
                layer.className = "intro-bloom";
                layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">BLOOM</div>`;
            }

            else { layer.className = "intro-titanium"; layer.innerHTML = `<div class="xs-logo">XS</div><div class="powered-by">titanium expansion</div>`; }
            
            layer.style.display = "flex";
            setTimeout(() => { layer.style.opacity = "0"; setTimeout(() => { layer.style.display = "none"; document.getElementById('user-select-layer').style.display = "flex"; state = "LOGIN"; }, 1000); }, 4000);
        }

        // --- TUTORIAL LOGIC ---
        function nextTut() { document.getElementById(`tut-${tutIdx}`).classList.remove('active'); tutIdx = (tutIdx + 1) % __TUT_TOTAL; document.getElementById(`tut-${tutIdx}`).classList.add('active'); document.getElementById('tut-page').innerText = tutIdx + 1; playSysSound(400, 'sine', 0.1); }
        function prevTut() { document.getElementById(`tut-${tutIdx}`).classList.remove('active'); tutIdx = (tutIdx - 1 + __TUT_TOTAL) % __TUT_TOTAL; document.getElementById(`tut-${tutIdx}`).classList.add('active'); document.getElementById('tut-page').innerText = tutIdx + 1; playSysSound(400, 'sine', 0.1); }

        // --- LOJA LOGIC ---
        function selectShopItem(category, value, cost) {
            const itemId = `${category}-${value}`;
            const already = purchasedItems.includes(itemId);

            // helper: aplica item e atualiza UI
            const applySelection = () => {
                if (category === 'theme') { systemSettings.theme = value; changeTheme(value); checkAchievement('customizer'); }
                if (category === 'intro') { systemSettings.introType = value; }
                if (category === 'sfx') { systemSettings.sfxPack = value; }
                if (category === 'card') { systemSettings.cardStyle = value; renderTrack(); }
                saveSettings();
                updateStoreVisuals();
            };

            if (already) {
                applySelection();
                showToast("LOJA", "Item equipado.", null, "check_circle");
                playSysSound(600, 'sine', 0.1);
                return;
            }

            // Compra 1-clique: sem confirm/alert do navegador
            if (userCoins < cost) {
                showToast("XC INSUFICIENTE", `Você precisa de ${cost} XC para comprar.`, null, "lock");
                playSysSound(220, 'square', 0.10);
                return;
            }

            userCoins -= cost;
            purchasedItems.push(itemId);
            stats.purchases++; saveStats();
            saveEconomy();

            applySelection();

            if (cost >= 2000) checkAchievement('big_spender');
            showToast("COMPRA REALIZADA", "Item liberado e equipado.", `-${cost} XC`, "shopping_cart");
            playSysSound(820, 'square', 0.18);
        }

        function updateStoreVisuals() {
            purchasedItems.forEach(id => { const el = document.getElementById(`item-${id}`); if (el) { const lock = el.querySelector('.shop-lock'); if (lock) lock.style.display = 'none'; } });
            document.querySelectorAll('.shop-btn').forEach(b => b.classList.remove('active'));
            if(document.getElementById(`item-theme-${systemSettings.theme}`)) document.getElementById(`item-theme-${systemSettings.theme}`).classList.add('active');
            if(document.getElementById(`item-intro-${systemSettings.introType}`)) document.getElementById(`item-intro-${systemSettings.introType}`).classList.add('active');
            if(document.getElementById(`item-sfx-${systemSettings.sfxPack}`)) document.getElementById(`item-sfx-${systemSettings.sfxPack}`).classList.add('active');
            if(document.getElementById(`item-card-${systemSettings.cardStyle}`)) document.getElementById(`item-card-${systemSettings.cardStyle}`).classList.add('active');
        }

        // --- SETTINGS LOGIC ---
        function updateBrightness(val) { systemSettings.brightness = val; document.getElementById('brightness-layer').style.opacity = val; saveSettings(); }
        function updateVolume() { systemSettings.volume = parseFloat(document.getElementById('vol-slider').value); saveSettings(); checkAchievement('audiophile'); }
        function toggleSetting(key) {
            if(key === 'overclock') { systemSettings.overclock = document.getElementById('check-overclock').checked; if(systemSettings.overclock) { showToast("WARNING", "HIGH TEMP!", null, 'warning'); playSysSound(100, 'sawtooth', 0.5); checkAchievement('overclocker'); } }
            if(key === 'intro') systemSettings.intro = document.getElementById('check-intro').checked;
            if(key === 'sfx') systemSettings.sfx = document.getElementById('check-sfx').checked;
            if(key === 'buffer') systemSettings.buffer = document.getElementById('sel-buffer').value;
            if(key === 'aa') systemSettings.aa = document.getElementById('check-aa').checked;
            saveSettings();
        }
        function clearCache() {
            // Sem popup nativo do navegador: toque duas vezes para confirmar
            if (!window.__xsClearCache) window.__xsClearCache = { ts: 0 };
            const now = Date.now();
            if (now - (window.__xsClearCache.ts || 0) > 2400) {
                window.__xsClearCache.ts = now;
                showToast("CONFIRMAR", "Toque novamente para limpar o cache.", "2s", "warning");
                playSysSound(260, 'square', 0.10);
                return;
            }
            window.__xsClearCache.ts = 0;

            const keep = ['xs_coins', 'xs_profiles', 'xs_achievements', 'xs_purchased', 'xs_settings', 'xs_playtime'];
            const data = {};
            keep.forEach(k => data[k] = localStorage.getItem(k));
            localStorage.clear();
            keep.forEach(k => { if (data[k]) localStorage.setItem(k, data[k]); });
            checkAchievement('clean_freak');
            showToast("CACHE", "Cache limpo. Reiniciando…", null, "delete");
            playSysSound(720, 'sine', 0.14);
            location.reload();
        }
        function openSupport() { checkAchievement('support_ticket'); window.open("https://api.whatsapp.com/send?phone=5551991681654&text=Ola%20eu%20quero%20falar%20sobre%20o%20XUXUBISTATION", "_blank"); }


        // --- INPUT AUTO DETECT (TECLADO / TOUCH / CONTROLE) ---
        let __lastInput = 'keyboard';
        let __gpLoopOn = false;
        const __gpState = { lastMove: 0, a: false, b: false };

        function setInputMode(mode) {
            systemSettings.inputMode = mode || 'auto';
            saveSettings();
            applyInputMode();
        }

        function __markInput(type) {
            __lastInput = type;
            if ((systemSettings.inputMode || 'auto') === 'auto') applyInputMode();
        }

        function applyInputMode() {
            const forced = systemSettings.inputMode || 'auto';
            const mode = (forced === 'auto') ? (__lastInput === 'touch' ? 'touch' : (__lastInput === 'gamepad' ? 'gamepad' : 'keyboard')) : forced;

            const mob = document.getElementById('mobile-controls');
            if (mob) mob.style.display = (mode === 'touch') ? 'flex' : 'none';

            if (mode === 'gamepad') __startGamepadLoop();
        }

        window.addEventListener('touchstart', () => __markInput('touch'), { passive: true });
        window.addEventListener('mousedown', () => __markInput('mouse'), { passive: true });
        window.addEventListener('keydown', () => __markInput('keyboard'));
        window.addEventListener('gamepadconnected', () => __markInput('gamepad'));

        function __startGamepadLoop() {
            if (__gpLoopOn) return;
            __gpLoopOn = true;
            const tick = () => {
                const pads = (navigator.getGamepads && navigator.getGamepads()) ? navigator.getGamepads() : [];
                const gp = pads && pads[0];
                if (gp) {
                    const now = performance.now();
                    const ax = (gp.axes && gp.axes.length) ? gp.axes[0] : 0;
                    const left = (gp.buttons[14] && gp.buttons[14].pressed) || (ax < -0.6);
                    const right = (gp.buttons[15] && gp.buttons[15].pressed) || (ax > 0.6);
                    const a = (gp.buttons[0] && gp.buttons[0].pressed);
                    const b = (gp.buttons[1] && gp.buttons[1].pressed) || (gp.buttons[9] && gp.buttons[9].pressed);

                    if ((left || right) && now - __gpState.lastMove > 180) {
                        if (left) move(-1);
                        if (right) move(1);
                        __gpState.lastMove = now;
                    }

                    if (a && !__gpState.a) actionEnter();
                    if (b && !__gpState.b) {
                        closeModal('profile-modal'); closeModal('settings-modal'); closeModal('tutorial-modal');
                        closeModal('sideload-folder-modal'); closeModal('achievements-modal'); closeModal('custom-app-modal');
                        closeModal('roulette-modal'); closeGame();
                    }

                    __gpState.a = a;
                    __gpState.b = b;
                }
                requestAnimationFrame(tick);
            };
            requestAnimationFrame(tick);
        }

        // --- ROULETA XC ---
        const __RKEY = { daily: 'xs_roulette_daily', bonus: 'xs_roulette_bonus', inv: 'xs_roulette_inv', last: 'xs_roulette_last', play: 'xs_roulette_play_award', pity: 'xs_roulette_pity', hist: 'xs_roulette_hist' };
        const __DAILY_SPINS = 3;
        const __ROULETTE_ITEM_W = 120;
        let __rouletteSpinning = false;

        // --- ROULETTE INVENTORY UI STATE (somente apresentação) ---
        let __rouletteInvFilter = 'all';      // all | avatars | frames | shop
        let __rouletteInvSelectedId = null;   // item id selecionado
        let __rouletteInvPreviewBase = null;  // config base do preview (não salva)



        function __localDateKey() {
            const d = new Date();
            const y = d.getFullYear();
            const m = String(d.getMonth()+1).padStart(2,'0');
            const day = String(d.getDate()).padStart(2,'0');
            return y + '-' + m + '-' + day;
        }

        function __getDailyState() {
            let st = {};
            try { st = JSON.parse(localStorage.getItem(__RKEY.daily) || '{}') || {}; } catch(e) { st = {}; }
            const today = __localDateKey();
            if (st.date !== today) st = { date: today, used: 0 };
            if (typeof st.used !== 'number') st.used = 0;
            st.used = Math.max(0, Math.min(__DAILY_SPINS, st.used));
            localStorage.setItem(__RKEY.daily, JSON.stringify(st));
            return st;
        }

        function __getBonusSpins() {
            return Math.max(0, parseInt(localStorage.getItem(__RKEY.bonus) || '0', 10) || 0);
        }

        function __setBonusSpins(v) {
            localStorage.setItem(__RKEY.bonus, String(Math.max(0, (v|0))));
        }

        function __getInventory() {
            try {
                const arr = JSON.parse(localStorage.getItem(__RKEY.inv) || '[]');
                return Array.isArray(arr) ? arr : [];
            } catch(e) { return []; }
        }

        function __setInventory(arr) {
            localStorage.setItem(__RKEY.inv, JSON.stringify(arr));
        }

        function __svgData(svg) {
            return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
        }

        function __getPity() {
            let p = {};
            try { p = JSON.parse(localStorage.getItem(__RKEY.pity) || '{}') || {}; } catch(e) { p = {}; }
            if (typeof p.sinceEpic !== 'number') p.sinceEpic = 0;
            if (typeof p.sinceLegendary !== 'number') p.sinceLegendary = 0;
            if (typeof p.sinceMythic !== 'number') p.sinceMythic = 0;
            if (typeof p.total !== 'number') p.total = 0;
            return p;
        }
        function __setPity(p) {
            try { localStorage.setItem(__RKEY.pity, JSON.stringify(p||{})); } catch(e) {}
        }
        function __bumpPity(wonRarity) {
            const p = __getPity();
            p.total = (p.total|0) + 1;
            p.sinceEpic = (p.sinceEpic|0) + 1;
            p.sinceLegendary = (p.sinceLegendary|0) + 1;
            p.sinceMythic = (p.sinceMythic|0) + 1;
            if (wonRarity === 'epic') p.sinceEpic = 0;
            if (wonRarity === 'legendary') { p.sinceEpic = 0; p.sinceLegendary = 0; }
            if (wonRarity === 'mythic') { p.sinceEpic = 0; p.sinceLegendary = 0; p.sinceMythic = 0; }
            __setPity(p);
        }

        function __getHist() {
            try {
                const h = JSON.parse(localStorage.getItem(__RKEY.hist) || '[]');
                return Array.isArray(h) ? h : [];
            } catch(e) { return []; }
        }
        function __pushHist(entry) {
            const h = __getHist();
            h.unshift(entry);
            while (h.length > 10) h.pop();
            try { localStorage.setItem(__RKEY.hist, JSON.stringify(h)); } catch(e) {}
        }

        let __roulettePreloaded = false;
        function __preloadRouletteAssets() {
            if (__roulettePreloaded) return;
            __roulettePreloaded = true;
            try {
                (__ROULETTE_ITEMS || []).forEach(it => {
                    if (!it || !it.img) return;
                    const im = new Image();
                    im.src = it.img;
                });
            } catch(e) {}
        }


        
        const __ROULETTE_ITEMS_EXPANDED = (() => {
  // SVGs FIXOS (sem reatividade). Mythic: gradientes ouro/prata/neon via <linearGradient>.
  const __encSVG = (svg) => 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);

  function __mkRouletteSVG(id, rarity, kind, exclusive, shopCat) {
    const esc = (s) => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    const bg = (rarity === 'mythic') ? ['#0b1020','#121a33']
            : (rarity === 'legendary') ? ['#1b1606','#2b2207']
            : (rarity === 'epic') ? ['#12081f','#1a0c2d']
            : ['#0b0f18','#111827'];

    const gradBg = `
      <linearGradient id="bg_${id}" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%" stop-color="${bg[0]}"/>
        <stop offset="100%" stop-color="${bg[1]}"/>
      </linearGradient>`;

    const gold = `
      <linearGradient id="gold_${id}" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%" stop-color="#7a5b00"/>
        <stop offset="25%" stop-color="#ffd166"/>
        <stop offset="55%" stop-color="#fff2b0"/>
        <stop offset="85%" stop-color="#ffd166"/>
        <stop offset="100%" stop-color="#7a5b00"/>
      </linearGradient>`;

    const silver = `
      <linearGradient id="silver_${id}" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%" stop-color="#3b3f46"/>
        <stop offset="30%" stop-color="#e5e7eb"/>
        <stop offset="60%" stop-color="#ffffff"/>
        <stop offset="100%" stop-color="#3b3f46"/>
      </linearGradient>`;

    const neon = `
      <linearGradient id="neon_${id}" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="#00f5d4"/>
        <stop offset="50%" stop-color="#ff00ff"/>
        <stop offset="100%" stop-color="#3a86ff"/>
      </linearGradient>`;

    const badge = (rarity === 'mythic') ? 'MYTHIC'
               : (rarity === 'legendary') ? 'LEGEND'
               : (rarity === 'epic') ? 'EPIC'
               : 'COMMON';

    const kindMark = (kind === 'shop')
      ? (shopCat === 'theme' ? 'THEME' : shopCat === 'intro' ? 'BOOT' : shopCat === 'sfx' ? 'SFX' : 'CARD')
      : (exclusive ? 'EXCL' : 'AVTR');

    const core = (rarity === 'mythic') ? `
      <circle cx="24" cy="24" r="19" fill="none" stroke="url(#gold_${id})" stroke-width="3"/>
      <circle cx="24" cy="24" r="14" fill="none" stroke="url(#silver_${id})" stroke-width="2" opacity="0.95"/>
      <path d="M10 28 L17 15 L24 28 L31 15 L38 28" fill="none" stroke="url(#neon_${id})" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M14 34 L24 38 L34 34" fill="none" stroke="url(#neon_${id})" stroke-width="2" opacity="0.8" stroke-linecap="round"/>
      <circle cx="24" cy="24" r="6.5" fill="url(#neon_${id})" opacity="0.12"/>
      <circle cx="14" cy="18" r="1.6" fill="url(#neon_${id})"/>
      <circle cx="34" cy="18" r="1.6" fill="url(#neon_${id})"/>
      <circle cx="24" cy="12.5" r="1.4" fill="url(#gold_${id})"/>
    ` : (rarity === 'legendary') ? `
      <circle cx="24" cy="24" r="18" fill="none" stroke="url(#gold_${id})" stroke-width="3"/>
      <path d="M14 30 L24 14 L34 30 Z" fill="url(#gold_${id})" opacity="0.22"/>
      <path d="M16 32 H32" stroke="url(#gold_${id})" stroke-width="2" stroke-linecap="round"/>
    ` : (rarity === 'epic') ? `
      <circle cx="24" cy="24" r="18" fill="none" stroke="url(#neon_${id})" stroke-width="2.6"/>
      <path d="M14 18 L34 18 L24 34 Z" fill="url(#neon_${id})" opacity="0.18"/>
      <path d="M16 32 H32" stroke="url(#neon_${id})" stroke-width="2" stroke-linecap="round" opacity="0.9"/>
    ` : `
      <circle cx="24" cy="24" r="18" fill="none" stroke="#3a86ff" stroke-width="2" opacity="0.85"/>
      <path d="M16 30 H32" stroke="#3a86ff" stroke-width="2" stroke-linecap="round" opacity="0.8"/>
    `;

    const defs = (rarity === 'mythic')
      ? `<defs>${gradBg}${gold}${silver}${neon}</defs>`
      : (rarity === 'legendary')
        ? `<defs>${gradBg}${gold}</defs>`
        : `<defs>${gradBg}${neon}</defs>`;

    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48">
        ${defs}
        <rect x="2" y="2" width="44" height="44" rx="12" fill="url(#bg_${id})"/>
        <rect x="2" y="2" width="44" height="44" rx="12" fill="none" stroke="${rarity==='legendary'?'#ffd166':rarity==='mythic'?'#fff2b0':rarity==='epic'?'#ff00ff':'#3a86ff'}" opacity="0.15"/>
        ${core}
        <text x="24" y="43" text-anchor="middle" font-size="6.2" fill="#e5e7eb" opacity="0.92" font-family="Arial">${esc(badge)}</text>
        <text x="24" y="10.8" text-anchor="middle" font-size="6.2" fill="${rarity==='legendary'?'#ffd166':rarity==='mythic'?'#fff2b0':rarity==='epic'?'#ff00ff':'#8be9fd'}" opacity="0.95" font-family="Arial">${esc(kindMark)}</text>
      </svg>`;
    return __encSVG(svg);
  }

  return [
    { id:'mx_ex_01', name:'EXCLUSIVO • Protocolo SERAFIM', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'turban',eyes:'hearts',mouth:'twinkle',clothing:'shirtCrewNeck',accessoriesOn:true,accessories:'wayfarers',skinColor:'7f4a2c',hairColor:'fd9841',clothingColor:'ffd166',accessoriesColor:'ffd166',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_01','mythic','preset',true) },
    { id:'mx_ex_02', name:'EXCLUSIVO • Oráculo de Cromo', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'winterHat04',eyes:'xDizzy',mouth:'tongue',clothing:'graphicShirt|resist',accessoriesOn:true,accessories:'sunglasses',skinColor:'f8d5c2',hairColor:'a55728',clothingColor:'c0c0c0',accessoriesColor:'c0c0c0',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_02','mythic','preset',true) },
    { id:'mx_ex_03', name:'EXCLUSIVO • Neon Sanctum', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'frida',eyes:'winkWacky',mouth:'smile',clothing:'shirtButtonUp',accessoriesOn:true,accessories:'eyepatch',skinColor:'e8b38d',hairColor:'fd9841',clothingColor:'00f5d4',accessoriesColor:'00f5d4',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_03','mythic','preset',true) },
    { id:'mx_ex_04', name:'EXCLUSIVO • Titânio Ancestral', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'hat',eyes:'surprised',mouth:'grimace',clothing:'shirtScoopNeck',accessoriesOn:true,accessories:'kurt',skinColor:'d08b5b',hairColor:'fd9841',clothingColor:'ff00ff',accessoriesColor:'ff00ff',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_04','mythic','preset',true) },
    { id:'mx_ex_05', name:'EXCLUSIVO • Eclipse Dourado', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'hijab',eyes:'eyeRoll',mouth:'screamOpen',clothing:'shirtCrewNeck',accessoriesOn:true,accessories:'prescription02',skinColor:'f3c59f',hairColor:'d6b370',clothingColor:'3a86ff',accessoriesColor:'8be9fd',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_05','mythic','preset',true) },
    { id:'mx_ex_06', name:'EXCLUSIVO • Núcleo AURORA', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'dreads',eyes:'happy',mouth:'serious',clothing:'collarAndSweater',accessoriesOn:true,accessories:'wayfarers',skinColor:'d08b5b',hairColor:'090806',clothingColor:'8338ec',accessoriesColor:'ffffff',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_06','mythic','preset',true) },
    { id:'mx_ex_07', name:'EXCLUSIVO • Ídolo Prismático', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'bigHair',eyes:'default',mouth:'twinkle',clothing:'shirtButtonUp',accessoriesOn:true,accessories:'sunglasses',skinColor:'a66a4a',hairColor:'090806',clothingColor:'06d6a0',accessoriesColor:'c0c0c0',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_07','mythic','preset',true) },
    { id:'mx_ex_08', name:'EXCLUSIVO • Zero-Point XS', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'miaWallace',eyes:'hearts',mouth:'smile',clothing:'graphicShirt|bear',accessoriesOn:true,accessories:'eyepatch',skinColor:'a66a4a',hairColor:'a55728',clothingColor:'ef476f',accessoriesColor:'ffd166',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_08','mythic','preset',true) },
    { id:'mx_ex_09', name:'EXCLUSIVO • Fenda Arcana', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'bun',eyes:'xDizzy',mouth:'default',clothing:'shirtScoopNeck',accessoriesOn:true,accessories:'kurt',skinColor:'e8b38d',hairColor:'d6b370',clothingColor:'ffffff',accessoriesColor:'00f5d4',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_09','mythic','preset',true) },
    { id:'mx_ex_10', name:'EXCLUSIVO • Selo Imperador', rarity:'mythic', kind:'preset', exclusive:true, preset:{top:'shavedSides',eyes:'wink',mouth:'twinkle',clothing:'blazerAndShirt',accessoriesOn:true,accessories:'prescription01',skinColor:'7f4a2c',hairColor:'b55239',clothingColor:'ffd166',accessoriesColor:'ff00ff',frame:'frame_mythic'}, img: __mkRouletteSVG('mx_ex_10','mythic','preset',true) },
    { id:'lg_ex_01', name:'EXCLUSIVO • Ghost Runner', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'fro',eyes:'closed',mouth:'smile',clothing:'collarAndSweater',accessoriesOn:true,accessories:'sunglasses',skinColor:'7f4a2c',hairColor:'3d2314',clothingColor:'06d6a0',accessoriesColor:'ffd166',frame:'frame_gold'}, img: __mkRouletteSVG('lg_ex_01','legendary','preset',true) },
    { id:'lg_ex_02', name:'EXCLUSIVO • Holo-Drift', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'winterHat04',eyes:'xDizzy',mouth:'vomit',clothing:'shirtButtonUp',accessoriesOn:true,accessories:'wayfarers',skinColor:'d08b5b',hairColor:'090806',clothingColor:'ef476f',accessoriesColor:'ffffff',frame:'frame_steel'}, img: __mkRouletteSVG('lg_ex_02','legendary','preset',true) },
    { id:'lg_ex_03', name:'EXCLUSIVO • Steel Saint', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'hat',eyes:'side',mouth:'serious',clothing:'graphicShirt|skull',accessoriesOn:true,accessories:'sunglasses',skinColor:'f3c59f',hairColor:'fd9841',clothingColor:'111827',accessoriesColor:'ffd166',frame:'frame_arcade'}, img: __mkRouletteSVG('lg_ex_03','legendary','preset',true) },
    { id:'lg_ex_04', name:'EXCLUSIVO • Ruby Vandal', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'bigHair',eyes:'surprised',mouth:'smile',clothing:'graphicShirt|formula',accessoriesOn:true,accessories:'wayfarers',skinColor:'e8b38d',hairColor:'b55239',clothingColor:'f8f9fa',accessoriesColor:'e5e7eb',frame:'frame_gold'}, img: __mkRouletteSVG('lg_ex_04','legendary','preset',true) },
    { id:'lg_ex_05', name:'EXCLUSIVO • Matrix Punk', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'theCaesar',eyes:'winkWacky',mouth:'concerned',clothing:'graphicShirt|bear',accessoriesOn:true,accessories:'kurt',skinColor:'f8d5c2',hairColor:'4a312c',clothingColor:'ff006e',accessoriesColor:'00f5d4',frame:'frame_gold'}, img: __mkRouletteSVG('lg_ex_05','legendary','preset',true) },
    { id:'lg_ex_06', name:'EXCLUSIVO • Chrome Mirage', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'miaWallace',eyes:'winkWacky',mouth:'grimace',clothing:'graphicShirt|skull',accessoriesOn:true,accessories:'eyepatch',skinColor:'a66a4a',hairColor:'2c1b18',clothingColor:'0b1020',accessoriesColor:'00f5d4',frame:'frame_steel'}, img: __mkRouletteSVG('lg_ex_06','legendary','preset',true) },
    { id:'lg_ex_07', name:'EXCLUSIVO • Sunset Raider', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'turban',eyes:'hearts',mouth:'grimace',clothing:'collarAndSweater',accessoriesOn:true,accessories:'prescription02',skinColor:'f3c59f',hairColor:'e8e1e1',clothingColor:'3a86ff',accessoriesColor:'ff00ff',frame:'frame_gold'}, img: __mkRouletteSVG('lg_ex_07','legendary','preset',true) },
    { id:'lg_ex_08', name:'EXCLUSIVO • Midnight Warden', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'shortRound',eyes:'winkWacky',mouth:'default',clothing:'collarAndSweater',accessoriesOn:true,accessories:'prescription02',skinColor:'f8d5c2',hairColor:'b55239',clothingColor:'00f5d4',accessoriesColor:'00f5d4',frame:'frame_steel'}, img: __mkRouletteSVG('lg_ex_08','legendary','preset',true) },
    { id:'lg_ex_09', name:'EXCLUSIVO • Emerald Witch', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'curvy',eyes:'cry',mouth:'concerned',clothing:'sweater',accessoriesOn:true,accessories:'round',skinColor:'e8b38d',hairColor:'a55728',clothingColor:'ff006e',accessoriesColor:'8be9fd',frame:'frame_arcade'}, img: __mkRouletteSVG('lg_ex_09','legendary','preset',true) },
    { id:'lg_ex_10', name:'EXCLUSIVO • Neon Pilot', rarity:'legendary', kind:'preset', exclusive:true, preset:{top:'bob',eyes:'squint',mouth:'concerned',clothing:'graphicShirt|skull',accessoriesOn:true,accessories:'prescription01',skinColor:'f3c59f',hairColor:'3d2314',clothingColor:'8338ec',accessoriesColor:'e5e7eb',frame:'frame_arcade'}, img: __mkRouletteSVG('lg_ex_10','legendary','preset',true) },
    { id:'shop_theme_gold', name:'DESBLOQUEIO • THEME GOLD', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'theme',value:'gold'}, preset:{}, img: __mkRouletteSVG('shop_theme_gold','legendary','shop',false,'theme') },
    { id:'shop_theme_matrix', name:'DESBLOQUEIO • THEME MATRIX', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'theme',value:'matrix'}, preset:{}, img: __mkRouletteSVG('shop_theme_matrix','legendary','shop',false,'theme') },
    { id:'shop_theme_cyber', name:'DESBLOQUEIO • THEME CYBER', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'theme',value:'cyber'}, preset:{}, img: __mkRouletteSVG('shop_theme_cyber','legendary','shop',false,'theme') },
    { id:'shop_intro_holo', name:'DESBLOQUEIO • INTRO HOLO', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'intro',value:'holo'}, preset:{}, img: __mkRouletteSVG('shop_intro_holo','legendary','shop',false,'intro') },
    { id:'shop_intro_dvd', name:'DESBLOQUEIO • INTRO DVD', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'intro',value:'dvd'}, preset:{}, img: __mkRouletteSVG('shop_intro_dvd','legendary','shop',false,'intro') },
    { id:'shop_sfx_cinematic', name:'DESBLOQUEIO • SFX CINEMATIC', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'sfx',value:'cinematic'}, preset:{}, img: __mkRouletteSVG('shop_sfx_cinematic','legendary','shop',false,'sfx') },
    { id:'shop_sfx_glitch', name:'DESBLOQUEIO • SFX GLITCH', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'sfx',value:'glitch'}, preset:{}, img: __mkRouletteSVG('shop_sfx_glitch','legendary','shop',false,'sfx') },
    { id:'shop_card_chrome', name:'DESBLOQUEIO • CARD CHROME', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'card',value:'chrome'}, preset:{}, img: __mkRouletteSVG('shop_card_chrome','legendary','shop',false,'card') },
    { id:'shop_card_holo', name:'DESBLOQUEIO • CARD HOLO', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'card',value:'holo'}, preset:{}, img: __mkRouletteSVG('shop_card_holo','legendary','shop',false,'card') },
    { id:'shop_card_neon', name:'DESBLOQUEIO • CARD NEON', rarity:'legendary', kind:'shop', exclusive:false, shop:{category:'card',value:'neon'}, preset:{}, img: __mkRouletteSVG('shop_card_neon','legendary','shop',false,'card') },
    { id:'ep_ex_01', name:'EXCLUSIVO • Pixel Samurai', rarity:'epic', kind:'preset', exclusive:true, preset:{top:'straight02',eyes:'hearts',mouth:'screamOpen',clothing:'graphicShirt|formula',accessoriesOn:true,accessories:'round',skinColor:'7f4a2c',hairColor:'2c1b18',clothingColor:'3a86ff',accessoriesColor:'c0c0c0',frame:'frame_azure'}, img: __mkRouletteSVG('ep_ex_01','epic','preset',true) },
    { id:'ep_ex_02', name:'EXCLUSIVO • Bubble Popper', rarity:'epic', kind:'preset', exclusive:true, preset:{top:'bob',eyes:'default',mouth:'grimace',clothing:'sweaterCropped',accessoriesOn:true,accessories:'sunglasses',skinColor:'7f4a2c',hairColor:'b55239',clothingColor:'ef476f',accessoriesColor:'ff00ff',frame:'frame_basic'}, img: __mkRouletteSVG('ep_ex_02','epic','preset',true) },
    { id:'ep_ex_03', name:'EXCLUSIVO • Glitch Doctor', rarity:'epic', kind:'preset', exclusive:true, preset:{top:'winterHat02',eyes:'xDizzy',mouth:'vomit',clothing:'shirtScoopNeck',accessoriesOn:true,accessories:'round',skinColor:'a66a4a',hairColor:'3d2314',clothingColor:'111827',accessoriesColor:'ffd166',frame:'frame_azure'}, img: __mkRouletteSVG('ep_ex_03','epic','preset',true) },
    { id:'ep_ex_04', name:'EXCLUSIVO • Azure Knight', rarity:'epic', kind:'preset', exclusive:true, preset:{top:'bob',eyes:'wink',mouth:'concerned',clothing:'collarAndSweater',accessoriesOn:true,accessories:'prescription01',skinColor:'7f4a2c',hairColor:'e8e1e1',clothingColor:'0b1020',accessoriesColor:'ffd166',frame:'frame_basic'}, img: __mkRouletteSVG('ep_ex_04','epic','preset',true) },
    { id:'ep_ex_05', name:'EXCLUSIVO • Poster Idol', rarity:'epic', kind:'preset', exclusive:true, preset:{top:'shortFlat',eyes:'default',mouth:'screamOpen',clothing:'shirtVNeck',accessoriesOn:true,accessories:'prescription02',skinColor:'a66a4a',hairColor:'fd9841',clothingColor:'f8f9fa',accessoriesColor:'8be9fd',frame:'frame_basic'}, img: __mkRouletteSVG('ep_ex_05','epic','preset',true) },
    { id:'ep_ex_06', name:'EXCLUSIVO • Neon Courier', rarity:'epic', kind:'preset', exclusive:true, preset:{top:'shaggy',eyes:'winkWacky',mouth:'grimace',clothing:'collarAndSweater',accessoriesOn:true,accessories:'prescription01',skinColor:'f3c59f',hairColor:'b55239',clothingColor:'3a86ff',accessoriesColor:'c0c0c0',frame:'frame_azure'}, img: __mkRouletteSVG('ep_ex_06','epic','preset',true) },
    { id:'shop_card_pixel', name:'DESBLOQUEIO • CARD PIXEL', rarity:'epic', kind:'shop', exclusive:false, shop:{category:'card',value:'pixel'}, preset:{}, img: __mkRouletteSVG('shop_card_pixel','epic','shop',false,'card') },
    { id:'shop_card_glass', name:'DESBLOQUEIO • CARD GLASS', rarity:'epic', kind:'shop', exclusive:false, shop:{category:'card',value:'glass'}, preset:{}, img: __mkRouletteSVG('shop_card_glass','epic','shop',false,'card') },
    { id:'shop_sfx_futuristic', name:'DESBLOQUEIO • SFX FUTURISTIC', rarity:'epic', kind:'shop', exclusive:false, shop:{category:'sfx',value:'futuristic'}, preset:{}, img: __mkRouletteSVG('shop_sfx_futuristic','epic','shop',false,'sfx') },
    { id:'shop_intro_retro', name:'DESBLOQUEIO • INTRO RETRO', rarity:'epic', kind:'shop', exclusive:false, shop:{category:'intro',value:'retro'}, preset:{}, img: __mkRouletteSVG('shop_intro_retro','epic','shop',false,'intro') },
    { id:'ep_01', name:'Avatar EPIC • EP_01', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'bigHair',eyes:'wink',mouth:'eating',clothing:'graphicShirt|bear',accessoriesOn:true,accessories:'round',skinColor:'e8b38d',hairColor:'a55728',clothingColor:'ff006e',accessoriesColor:'8be9fd',frame:'frame_azure'}, img: __mkRouletteSVG('ep_01','epic','preset',false) },
    { id:'ep_02', name:'Avatar EPIC • EP_02', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'dreads02',eyes:'closed',mouth:'default',clothing:'shirtButtonUp',accessoriesOn:false,accessories:'eyepatch',skinColor:'d08b5b',hairColor:'fd9841',clothingColor:'f8f9fa',accessoriesColor:'8be9fd',frame:'frame_azure'}, img: __mkRouletteSVG('ep_02','epic','preset',false) },
    { id:'ep_03', name:'Avatar EPIC • EP_03', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'winterHat1',eyes:'hearts',mouth:'concerned',clothing:'sweater',accessoriesOn:true,accessories:'sunglasses',skinColor:'e8b38d',hairColor:'090806',clothingColor:'ef476f',accessoriesColor:'ffffff',frame:'frame_arcade'}, img: __mkRouletteSVG('ep_03','epic','preset',false) },
    { id:'ep_04', name:'Avatar EPIC • EP_04', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'winterHat04',eyes:'squint',mouth:'concerned',clothing:'hoodie',accessoriesOn:false,accessories:'kurt',skinColor:'a66a4a',hairColor:'fd9841',clothingColor:'2b2d42',accessoriesColor:'c0c0c0',frame:'frame_basic'}, img: __mkRouletteSVG('ep_04','epic','preset',false) },
    { id:'ep_05', name:'Avatar EPIC • EP_05', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'frizzle',eyes:'default',mouth:'eating',clothing:'shirtScoopNeck',accessoriesOn:true,accessories:'eyepatch',skinColor:'a66a4a',hairColor:'4a312c',clothingColor:'0b1020',accessoriesColor:'e5e7eb',frame:'frame_azure'}, img: __mkRouletteSVG('ep_05','epic','preset',false) },
    { id:'ep_06', name:'Avatar EPIC • EP_06', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'turban',eyes:'wink',mouth:'default',clothing:'collarAndSweater',accessoriesOn:false,accessories:'prescription01',skinColor:'7f4a2c',hairColor:'090806',clothingColor:'ff006e',accessoriesColor:'ff00ff',frame:'frame_basic'}, img: __mkRouletteSVG('ep_06','epic','preset',false) },
    { id:'ep_07', name:'Avatar EPIC • EP_07', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'noHair',eyes:'cry',mouth:'screamOpen',clothing:'hoodie',accessoriesOn:true,accessories:'round',skinColor:'f3c59f',hairColor:'fd9841',clothingColor:'ef476f',accessoriesColor:'8be9fd',frame:'frame_basic'}, img: __mkRouletteSVG('ep_07','epic','preset',false) },
    { id:'ep_08', name:'Avatar EPIC • EP_08', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'turban',eyes:'default',mouth:'concerned',clothing:'blazerAndSweater',accessoriesOn:false,accessories:'kurt',skinColor:'e8b38d',hairColor:'090806',clothingColor:'ff006e',accessoriesColor:'ffffff',frame:'frame_arcade'}, img: __mkRouletteSVG('ep_08','epic','preset',false) },
    { id:'ep_09', name:'Avatar EPIC • EP_09', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'dreads',eyes:'eyeRoll',mouth:'tongue',clothing:'blazerAndShirt',accessoriesOn:true,accessories:'prescription01',skinColor:'f8d5c2',hairColor:'d6b370',clothingColor:'f8f9fa',accessoriesColor:'e5e7eb',frame:'frame_arcade'}, img: __mkRouletteSVG('ep_09','epic','preset',false) },
    { id:'ep_10', name:'Avatar EPIC • EP_10', rarity:'epic', kind:'preset', exclusive:false, preset:{top:'shortWaved',eyes:'eyeRoll',mouth:'sad',clothing:'graphicShirt|resist',accessoriesOn:false,accessories:'sunglasses',skinColor:'f8d5c2',hairColor:'090806',clothingColor:'ef476f',accessoriesColor:'c0c0c0',frame:'frame_azure'}, img: __mkRouletteSVG('ep_10','epic','preset',false) },
    { id:'cm_01', name:'Avatar COMUM • CM_01', rarity:'common', kind:'preset', exclusive:false, preset:{top:'turban',eyes:'happy',mouth:'vomit',clothing:'shirtScoopNeck',accessoriesOn:true,accessories:'kurt',skinColor:'d08b5b',hairColor:'e8e1e1',clothingColor:'1f2937',accessoriesColor:'00f5d4'}, img: __mkRouletteSVG('cm_01','common','preset',false) },
    { id:'cm_02', name:'Avatar COMUM • CM_02', rarity:'common', kind:'preset', exclusive:false, preset:{top:'theCaesar',eyes:'cry',mouth:'eating',clothing:'sweaterCropped',accessoriesOn:false,accessories:'kurt',skinColor:'f3c59f',hairColor:'b55239',clothingColor:'8338ec',accessoriesColor:'e5e7eb'}, img: __mkRouletteSVG('cm_02','common','preset',false) },
    { id:'cm_03', name:'Avatar COMUM • CM_03', rarity:'common', kind:'preset', exclusive:false, preset:{top:'shaggy',eyes:'winkWacky',mouth:'twinkle',clothing:'graphicShirt|resist',accessoriesOn:false,accessories:'prescription01',skinColor:'a66a4a',hairColor:'d6b370',clothingColor:'8338ec',accessoriesColor:'e5e7eb'}, img: __mkRouletteSVG('cm_03','common','preset',false) },
    { id:'cm_04', name:'Avatar COMUM • CM_04', rarity:'common', kind:'preset', exclusive:false, preset:{top:'miaWallace',eyes:'winkWacky',mouth:'concerned',clothing:'shirtScoopNeck',accessoriesOn:false,accessories:'kurt',skinColor:'f8d5c2',hairColor:'b55239',clothingColor:'8338ec',accessoriesColor:'ffd166'}, img: __mkRouletteSVG('cm_04','common','preset',false) },
    { id:'cm_05', name:'Avatar COMUM • CM_05', rarity:'common', kind:'preset', exclusive:false, preset:{top:'winterHat02',eyes:'default',mouth:'serious',clothing:'sweaterCropped',accessoriesOn:false,accessories:'kurt',skinColor:'7f4a2c',hairColor:'4a312c',clothingColor:'2b2d42',accessoriesColor:'ffd166'}, img: __mkRouletteSVG('cm_05','common','preset',false) },
    { id:'cm_06', name:'Avatar COMUM • CM_06', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straight01',eyes:'side',mouth:'disbelief',clothing:'graphicShirt|resist',accessoriesOn:false,accessories:'prescription02',skinColor:'a66a4a',hairColor:'4a312c',clothingColor:'f8f9fa',accessoriesColor:'ff00ff'}, img: __mkRouletteSVG('cm_06','common','preset',false) },
    { id:'cm_07', name:'Avatar COMUM • CM_07', rarity:'common', kind:'preset', exclusive:false, preset:{top:'froBand',eyes:'happy',mouth:'eating',clothing:'graphicShirt|formula',accessoriesOn:false,accessories:'round',skinColor:'f8d5c2',hairColor:'090806',clothingColor:'8338ec',accessoriesColor:'e5e7eb'}, img: __mkRouletteSVG('cm_07','common','preset',false) },
    { id:'cm_08', name:'Avatar COMUM • CM_08', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straight02',eyes:'eyeRoll',mouth:'disbelief',clothing:'hoodie',accessoriesOn:false,accessories:'eyepatch',skinColor:'a66a4a',hairColor:'3d2314',clothingColor:'ff006e',accessoriesColor:'ffffff',frame:'frame_basic'}, img: __mkRouletteSVG('cm_08','common','preset',false) },
    { id:'cm_09', name:'Avatar COMUM • CM_09', rarity:'common', kind:'preset', exclusive:false, preset:{top:'shaggy',eyes:'winkWacky',mouth:'sad',clothing:'graphicShirt|skull',accessoriesOn:true,accessories:'wayfarers',skinColor:'f3c59f',hairColor:'3d2314',clothingColor:'3a86ff',accessoriesColor:'8be9fd'}, img: __mkRouletteSVG('cm_09','common','preset',false) },
    { id:'cm_10', name:'Avatar COMUM • CM_10', rarity:'common', kind:'preset', exclusive:false, preset:{top:'curly',eyes:'wink',mouth:'screamOpen',clothing:'collarAndSweater',accessoriesOn:false,accessories:'prescription02',skinColor:'f3c59f',hairColor:'b55239',clothingColor:'1f2937',accessoriesColor:'00f5d4'}, img: __mkRouletteSVG('cm_10','common','preset',false) },
    { id:'cm_11', name:'Avatar COMUM • CM_11', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straight02',eyes:'xDizzy',mouth:'disbelief',clothing:'hoodie',accessoriesOn:false,accessories:'sunglasses',skinColor:'7f4a2c',hairColor:'a55728',clothingColor:'00f5d4',accessoriesColor:'e5e7eb'}, img: __mkRouletteSVG('cm_11','common','preset',false) },
    { id:'cm_12', name:'Avatar COMUM • CM_12', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straight01',eyes:'squint',mouth:'vomit',clothing:'graphicShirt|diamond',accessoriesOn:false,accessories:'prescription02',skinColor:'e8b38d',hairColor:'090806',clothingColor:'2b2d42',accessoriesColor:'ff00ff'}, img: __mkRouletteSVG('cm_12','common','preset',false) },
    { id:'cm_13', name:'Avatar COMUM • CM_13', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straightAndStrand',eyes:'squint',mouth:'disbelief',clothing:'tankTop',accessoriesOn:false,accessories:'sunglasses',skinColor:'a66a4a',hairColor:'a55728',clothingColor:'111827',accessoriesColor:'00f5d4'}, img: __mkRouletteSVG('cm_13','common','preset',false) },
    { id:'cm_14', name:'Avatar COMUM • CM_14', rarity:'common', kind:'preset', exclusive:false, preset:{top:'froBand',eyes:'cry',mouth:'concerned',clothing:'shirtVNeck',accessoriesOn:false,accessories:'sunglasses',skinColor:'d08b5b',hairColor:'3d2314',clothingColor:'ff006e',accessoriesColor:'8be9fd'}, img: __mkRouletteSVG('cm_14','common','preset',false) },
    { id:'cm_15', name:'Avatar COMUM • CM_15', rarity:'common', kind:'preset', exclusive:false, preset:{top:'hijab',eyes:'side',mouth:'smile',clothing:'overall',accessoriesOn:false,accessories:'wayfarers',skinColor:'d08b5b',hairColor:'3d2314',clothingColor:'ef476f',accessoriesColor:'c0c0c0'}, img: __mkRouletteSVG('cm_15','common','preset',false) },
    { id:'cm_16', name:'Avatar COMUM • CM_16', rarity:'common', kind:'preset', exclusive:false, preset:{top:'winterHat04',eyes:'surprised',mouth:'twinkle',clothing:'graphicShirt|skull',accessoriesOn:false,accessories:'wayfarers',skinColor:'e8b38d',hairColor:'3d2314',clothingColor:'ef476f',accessoriesColor:'ffd166'}, img: __mkRouletteSVG('cm_16','common','preset',false) },
    { id:'cm_17', name:'Avatar COMUM • CM_17', rarity:'common', kind:'preset', exclusive:false, preset:{top:'dreads02',eyes:'xDizzy',mouth:'sad',clothing:'hoodie',accessoriesOn:true,accessories:'prescription01',skinColor:'f8d5c2',hairColor:'b55239',clothingColor:'06d6a0',accessoriesColor:'8be9fd',frame:'frame_basic'}, img: __mkRouletteSVG('cm_17','common','preset',false) },
    { id:'cm_18', name:'Avatar COMUM • CM_18', rarity:'common', kind:'preset', exclusive:false, preset:{top:'sides',eyes:'wink',mouth:'sad',clothing:'shirtVNeck',accessoriesOn:false,accessories:'eyepatch',skinColor:'f3c59f',hairColor:'b55239',clothingColor:'f8f9fa',accessoriesColor:'c0c0c0'}, img: __mkRouletteSVG('cm_18','common','preset',false) },
    { id:'cm_19', name:'Avatar COMUM • CM_19', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straightAndStrand',eyes:'closed',mouth:'screamOpen',clothing:'graphicShirt|resist',accessoriesOn:false,accessories:'eyepatch',skinColor:'f3c59f',hairColor:'090806',clothingColor:'8338ec',accessoriesColor:'00f5d4'}, img: __mkRouletteSVG('cm_19','common','preset',false) },
    { id:'cm_20', name:'Avatar COMUM • CM_20', rarity:'common', kind:'preset', exclusive:false, preset:{top:'shaggyMullet',eyes:'xDizzy',mouth:'twinkle',clothing:'blazerAndShirt',accessoriesOn:false,accessories:'prescription01',skinColor:'a66a4a',hairColor:'d6b370',clothingColor:'ff006e',accessoriesColor:'ffffff'}, img: __mkRouletteSVG('cm_20','common','preset',false) },
    { id:'cm_21', name:'Avatar COMUM • CM_21', rarity:'common', kind:'preset', exclusive:false, preset:{top:'winterHat02',eyes:'cry',mouth:'sad',clothing:'graphicShirt|hola',accessoriesOn:false,accessories:'prescription01',skinColor:'e8b38d',hairColor:'d6b370',clothingColor:'3a86ff',accessoriesColor:'ff00ff'}, img: __mkRouletteSVG('cm_21','common','preset',false) },
    { id:'cm_22', name:'Avatar COMUM • CM_22', rarity:'common', kind:'preset', exclusive:false, preset:{top:'winterHat04',eyes:'surprised',mouth:'tongue',clothing:'shirtVNeck',accessoriesOn:false,accessories:'prescription01',skinColor:'d08b5b',hairColor:'a55728',clothingColor:'00f5d4',accessoriesColor:'c0c0c0'}, img: __mkRouletteSVG('cm_22','common','preset',false) },
    { id:'cm_23', name:'Avatar COMUM • CM_23', rarity:'common', kind:'preset', exclusive:false, preset:{top:'shortRound',eyes:'closed',mouth:'grimace',clothing:'graphicShirt|diamond',accessoriesOn:false,accessories:'round',skinColor:'f8d5c2',hairColor:'4a312c',clothingColor:'ff006e',accessoriesColor:'8be9fd'}, img: __mkRouletteSVG('cm_23','common','preset',false) },
    { id:'cm_24', name:'Avatar COMUM • CM_24', rarity:'common', kind:'preset', exclusive:false, preset:{top:'theCaesar',eyes:'happy',mouth:'default',clothing:'sweater',accessoriesOn:false,accessories:'prescription01',skinColor:'e8b38d',hairColor:'a55728',clothingColor:'ffd166',accessoriesColor:'00f5d4'}, img: __mkRouletteSVG('cm_24','common','preset',false) },
    { id:'cm_25', name:'Avatar COMUM • CM_25', rarity:'common', kind:'preset', exclusive:false, preset:{top:'bun',eyes:'default',mouth:'concerned',clothing:'blazerAndShirt',accessoriesOn:true,accessories:'prescription01',skinColor:'7f4a2c',hairColor:'3d2314',clothingColor:'ff006e',accessoriesColor:'c0c0c0'}, img: __mkRouletteSVG('cm_25','common','preset',false) },
    { id:'cm_26', name:'Avatar COMUM • CM_26', rarity:'common', kind:'preset', exclusive:false, preset:{top:'theCaesar',eyes:'surprised',mouth:'concerned',clothing:'blazerAndSweater',accessoriesOn:false,accessories:'wayfarers',skinColor:'7f4a2c',hairColor:'a55728',clothingColor:'f8f9fa',accessoriesColor:'00f5d4',frame:'frame_basic'}, img: __mkRouletteSVG('cm_26','common','preset',false) },
    { id:'cm_27', name:'Avatar COMUM • CM_27', rarity:'common', kind:'preset', exclusive:false, preset:{top:'dreads01',eyes:'winkWacky',mouth:'sad',clothing:'shirtScoopNeck',accessoriesOn:false,accessories:'eyepatch',skinColor:'d08b5b',hairColor:'3d2314',clothingColor:'1f2937',accessoriesColor:'8be9fd'}, img: __mkRouletteSVG('cm_27','common','preset',false) },
    { id:'cm_28', name:'Avatar COMUM • CM_28', rarity:'common', kind:'preset', exclusive:false, preset:{top:'froBand',eyes:'happy',mouth:'eating',clothing:'tankTop',accessoriesOn:false,accessories:'eyepatch',skinColor:'f8d5c2',hairColor:'a55728',clothingColor:'0b1020',accessoriesColor:'ffd166'}, img: __mkRouletteSVG('cm_28','common','preset',false) },
    { id:'cm_29', name:'Avatar COMUM • CM_29', rarity:'common', kind:'preset', exclusive:false, preset:{top:'hat',eyes:'wink',mouth:'default',clothing:'shirtScoopNeck',accessoriesOn:false,accessories:'eyepatch',skinColor:'f3c59f',hairColor:'3d2314',clothingColor:'f8f9fa',accessoriesColor:'ff00ff'}, img: __mkRouletteSVG('cm_29','common','preset',false) },
    { id:'cm_30', name:'Avatar COMUM • CM_30', rarity:'common', kind:'preset', exclusive:false, preset:{top:'frizzle',eyes:'surprised',mouth:'vomit',clothing:'graphicShirt|hola',accessoriesOn:false,accessories:'kurt',skinColor:'f8d5c2',hairColor:'e8e1e1',clothingColor:'ff006e',accessoriesColor:'e5e7eb'}, img: __mkRouletteSVG('cm_30','common','preset',false) },
    { id:'cm_31', name:'Avatar COMUM • CM_31', rarity:'common', kind:'preset', exclusive:false, preset:{top:'dreads01',eyes:'winkWacky',mouth:'twinkle',clothing:'tankTop',accessoriesOn:false,accessories:'prescription02',skinColor:'d08b5b',hairColor:'b55239',clothingColor:'0b1020',accessoriesColor:'00f5d4'}, img: __mkRouletteSVG('cm_31','common','preset',false) },
    { id:'cm_32', name:'Avatar COMUM • CM_32', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straight02',eyes:'wink',mouth:'screamOpen',clothing:'shirtCrewNeck',accessoriesOn:false,accessories:'wayfarers',skinColor:'f8d5c2',hairColor:'3d2314',clothingColor:'1f2937',accessoriesColor:'c0c0c0'}, img: __mkRouletteSVG('cm_32','common','preset',false) },
    { id:'cm_33', name:'Avatar COMUM • CM_33', rarity:'common', kind:'preset', exclusive:false, preset:{top:'longButNotTooLong',eyes:'surprised',mouth:'concerned',clothing:'graphicShirt|bear',accessoriesOn:true,accessories:'round',skinColor:'a66a4a',hairColor:'4a312c',clothingColor:'111827',accessoriesColor:'ff00ff'}, img: __mkRouletteSVG('cm_33','common','preset',false) },
    { id:'cm_34', name:'Avatar COMUM • CM_34', rarity:'common', kind:'preset', exclusive:false, preset:{top:'shortWaved',eyes:'cry',mouth:'sad',clothing:'graphicShirt|hola',accessoriesOn:false,accessories:'prescription01',skinColor:'7f4a2c',hairColor:'4a312c',clothingColor:'1f2937',accessoriesColor:'8be9fd'}, img: __mkRouletteSVG('cm_34','common','preset',false) },
    { id:'cm_35', name:'Avatar COMUM • CM_35', rarity:'common', kind:'preset', exclusive:false, preset:{top:'hat',eyes:'side',mouth:'tongue',clothing:'collarAndSweater',accessoriesOn:false,accessories:'prescription01',skinColor:'f3c59f',hairColor:'a55728',clothingColor:'00f5d4',accessoriesColor:'ff00ff',frame:'frame_basic'}, img: __mkRouletteSVG('cm_35','common','preset',false) },
    { id:'cm_36', name:'Avatar COMUM • CM_36', rarity:'common', kind:'preset', exclusive:false, preset:{top:'shortCurly',eyes:'cry',mouth:'screamOpen',clothing:'graphicShirt|formula',accessoriesOn:false,accessories:'round',skinColor:'f3c59f',hairColor:'090806',clothingColor:'06d6a0',accessoriesColor:'8be9fd'}, img: __mkRouletteSVG('cm_36','common','preset',false) },
    { id:'cm_37', name:'Avatar COMUM • CM_37', rarity:'common', kind:'preset', exclusive:false, preset:{top:'frida',eyes:'surprised',mouth:'default',clothing:'tankTop',accessoriesOn:false,accessories:'wayfarers',skinColor:'e8b38d',hairColor:'090806',clothingColor:'ef476f',accessoriesColor:'c0c0c0'}, img: __mkRouletteSVG('cm_37','common','preset',false) },
    { id:'cm_38', name:'Avatar COMUM • CM_38', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straightAndStrand',eyes:'side',mouth:'twinkle',clothing:'shirtScoopNeck',accessoriesOn:false,accessories:'prescription02',skinColor:'7f4a2c',hairColor:'2c1b18',clothingColor:'ffd166',accessoriesColor:'00f5d4'}, img: __mkRouletteSVG('cm_38','common','preset',false) },
    { id:'cm_39', name:'Avatar COMUM • CM_39', rarity:'common', kind:'preset', exclusive:false, preset:{top:'straightAndStrand',eyes:'eyeRoll',mouth:'serious',clothing:'graphicShirt|bear',accessoriesOn:false,accessories:'round',skinColor:'a66a4a',hairColor:'d6b370',clothingColor:'ef476f',accessoriesColor:'8be9fd'}, img: __mkRouletteSVG('cm_39','common','preset',false) },
    { id:'cm_40', name:'Avatar COMUM • CM_40', rarity:'common', kind:'preset', exclusive:false, preset:{top:'winterHat03',eyes:'side',mouth:'tongue',clothing:'blazerAndShirt',accessoriesOn:false,accessories:'sunglasses',skinColor:'7f4a2c',hairColor:'e8e1e1',clothingColor:'f8f9fa',accessoriesColor:'00f5d4'}, img: __mkRouletteSVG('cm_40','common','preset',false) },
  ];
})();
        const __ROULETTE_ITEMS = __ROULETTE_ITEMS_EXPANDED;

        function __rarityLabel(r) {
            if (r==='common') return {t:'COMUM', c:'rr-common', k:'r-common'};
            if (r==='rare') return {t:'RARO', c:'rr-rare', k:'r-rare'};
            if (r==='epic') return {t:'ÉPICO', c:'rr-epic', k:'r-epic'};
            if (r==='legendary') return {t:'LENDÁRIO', c:'rr-legendary', k:'r-legendary'};
            return {t:'MÍTICO', c:'rr-mythic', k:'r-mythic'};
        }

        // --- SOM DA ROLETA (estilo CS:GO) ---
        function __getTranslateX(el) {
            try {
                const tr = getComputedStyle(el).transform;
                if (!tr || tr === 'none') return 0;
                if (tr.startsWith('matrix3d(')) {
                    const v = tr.slice(9,-1).split(',').map(parseFloat);
                    return v[12] || 0;
                }
                if (tr.startsWith('matrix(')) {
                    const v = tr.slice(7,-1).split(',').map(parseFloat);
                    return v[4] || 0;
                }
            } catch(e) {}
            return 0;
        }

        function playRouletteTick(intensity=1) {
            if(!systemSettings.sfx) return;
            try { if (audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{}); } catch(e) {}
            const t = audioCtx.currentTime;
            const g = audioCtx.createGain();
            const base = Math.max(0.02, Math.min(1, systemSettings.volume || 0.5));
            g.gain.setValueAtTime(base * 0.14 * intensity, t);
            g.gain.exponentialRampToValueAtTime(0.001, t + 0.045);

            const o1 = audioCtx.createOscillator();
            const o2 = audioCtx.createOscillator();
            o1.type = 'square';
            o2.type = 'triangle';
            o1.frequency.setValueAtTime(1400, t);
            o1.frequency.exponentialRampToValueAtTime(650, t + 0.03);
            o2.frequency.setValueAtTime(2200, t);
            o2.frequency.exponentialRampToValueAtTime(900, t + 0.02);

            o1.connect(g);
            o2.connect(g);
            g.connect(audioCtx.destination);

            o1.start(t);
            o2.start(t);
            o1.stop(t + 0.055);
            o2.stop(t + 0.055);
        }


        function __pickWeighted() {
            const p = __getPity();

            // Pesos base (SEM 'rare' porque o pool expandido não tem essa categoria)
            const w = { common: 70, epic: 20, legendary: 8, mythic: 2 };

            // Pity: garante raridades altas após muitas tentativas
            if (p.sinceMythic >= 150) {
                const pool = __ROULETTE_ITEMS.filter(x=>x.rarity==='mythic');
                return pool[Math.floor(Math.random()*pool.length)] || __ROULETTE_ITEMS[0];
            }
            if (p.sinceLegendary >= 70) {
                const pool = __ROULETTE_ITEMS.filter(x=>x.rarity==='legendary');
                return pool[Math.floor(Math.random()*pool.length)] || __ROULETTE_ITEMS[0];
            }
            if (p.sinceEpic >= 25) {
                const pool = __ROULETTE_ITEMS.filter(x=>x.rarity==='epic');
                return pool[Math.floor(Math.random()*pool.length)] || __ROULETTE_ITEMS[0];
            }

            // Boost progressivo (mantém hardcore sem inflacionar)
            const epicBoost = Math.max(0, (p.sinceEpic - 10)) * 0.18;
            const legBoost  = Math.max(0, (p.sinceLegendary - 22)) * 0.07;
            const mytBoost  = Math.max(0, (p.sinceMythic - 40)) * 0.03;

            w.epic += epicBoost;
            w.legendary += legBoost;
            w.mythic += mytBoost;
            // compensa tirando de common
            w.common = Math.max(45, w.common - (epicBoost*0.85 + legBoost*0.75 + mytBoost*0.6));

            const total = w.common + w.epic + w.legendary + w.mythic;
            let r = Math.random() * total;
            let chosen = 'common';
            for (const k of ['common','epic','legendary','mythic']) {
                r -= w[k];
                if (r <= 0) { chosen = k; break; }
            }
            const pool = __ROULETTE_ITEMS.filter(x => x.rarity === chosen);
            return pool[Math.floor(Math.random()*pool.length)] || __ROULETTE_ITEMS[0];
        }


        function buyRouletteSpin() {
            const cost = 300;
            if (__rouletteSpinning) return;
            if (userCoins < cost) {
                showToast('ROULETA', 'XC insuficiente para comprar giro', null, 'casino');
                playSysSound(140, 'sawtooth', 0.12);
                return;
            }
            userCoins -= cost;
            localStorage.setItem('xs_coins', String(userCoins));
            updateCoinDisplay();
            __setBonusSpins(__getBonusSpins() + 1);
            __updateRouletteUI();
            playSysSound(780, 'square', 0.18);
            showToast('ROULETA', 'Giro bônus comprado', `-${cost} XC`, 'casino');
        }

function __updateRouletteUI() {
            const st = __getDailyState();
            const dailyLeft = Math.max(0, __DAILY_SPINS - st.used);
            const bonus = __getBonusSpins();
            const elA = document.getElementById('roulette-spins-left');
            const elB = document.getElementById('roulette-bonus-spins');
            if (elA) elA.innerText = String(dailyLeft);
            if (elB) elB.innerText = String(bonus);
            const last = localStorage.getItem(__RKEY.last) || '—';
            const elL = document.getElementById('roulette-last-win');
            if (elL) elL.innerText = last;
            const btn = document.getElementById('roulette-spin-btn');
            if (btn) btn.disabled = (dailyLeft + bonus) <= 0 || __rouletteSpinning;
            const bbtn = document.getElementById('roulette-buy-btn');
            if (bbtn) bbtn.disabled = __rouletteSpinning || userCoins < 300;
        }


        function openRoulette() {
            __preloadRouletteAssets();
            openModal('roulette-modal');
            __updateRouletteUI();
            __ensureFxRefresh();
            // histórico (injeção leve, sem mudar o layout geral)
            try {
                const box = document.querySelector('#roulette-modal .modal-box');
                if (box && !document.getElementById('roulette-history')) {
                    const topRow = box.querySelector('div[style*="justify-content:space-between"]');
                    if (topRow) {
                        const h = document.createElement('div');
                        h.id = 'roulette-history';
                        h.style.marginTop = '6px';
                        h.style.fontSize = '0.78rem';
                        h.style.color = '#9aa';
                        h.style.opacity = '0.95';
                        topRow.insertAdjacentElement('afterend', h);
                    }
                }
            } catch(e) {}
            __renderRouletteHistory();
            __renderRouletteStrip([__pickWeighted(),__pickWeighted(),__pickWeighted(),__pickWeighted(),__pickWeighted(),__pickWeighted(),__pickWeighted(),__pickWeighted(),__pickWeighted()]);
        }

        function __renderRouletteHistory() {
            const el = document.getElementById('roulette-history');
            if (!el) return;
            const h = __getHist();
            if (!h.length) { el.innerText = 'Histórico: —'; return; }
            const last = h.slice(0,3).map(x => x.name).join(' • ');
            el.innerText = 'Histórico: ' + last;
        }

        function __renderRouletteStrip(items) {
            const track = document.getElementById('roulette-track');
            if (!track) return;
            track.innerHTML = '';
            items.forEach(it => {
                const lab = __rarityLabel(it.rarity);
                const el = document.createElement('div');
                el.className = 'roulette-item ' + lab.k;
                el.innerHTML = `<img src="${it.img}" onerror="this.src='${__svgData('<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64"><rect x="10" y="10" width="44" height="44" rx="12" fill="rgba(255,255,255,0.06)" stroke="rgba(255,255,255,0.25)" stroke-width="4"/><text x="32" y="38" font-size="12" text-anchor="middle" fill="#eaeaea">ITEM</text></svg>')}'">` +
                              `<div class='ri-name'>${it.name}</div>` +
                              `<div class='ri-rarity ${lab.c}'>${lab.t}</div>`;
                track.appendChild(el);
            });
            track.style.transform = 'translateX(0px)';
        }

        function __consumeSpin() {
            const st = __getDailyState();
            const dailyLeft = Math.max(0, __DAILY_SPINS - st.used);
            let bonus = __getBonusSpins();
            if (dailyLeft > 0) {
                st.used += 1;
                localStorage.setItem(__RKEY.daily, JSON.stringify(st));
                return true;
            }
            if (bonus > 0) {
                bonus -= 1;
                __setBonusSpins(bonus);
                return true;
            }
            return false;
        }

        function spinRoulette() {
            if (__rouletteSpinning) return;
            if (!__consumeSpin()) { showToast('ROULETA', 'Sem giros disponíveis', null, 'casino'); return; }

            // Se já existia animação/RAF (ex: fechou modal no meio), cancela aqui
            try { __stopRouletteRuntime(); } catch(e){}

            __rouletteSpinning = true;
            __updateRouletteUI();
            playSysSound(520, 'sine', 0.12);

            const viewport = document.querySelector('#roulette-modal .roulette-viewport');
            const viewW = viewport ? viewport.clientWidth : 600;
            const WIN_INDEX = 48;

            const strip = [];
            for (let i=0;i<60;i++) strip.push(__pickWeighted());
            const winItem = __pickWeighted();
            strip[WIN_INDEX] = winItem;

            __renderRouletteStrip(strip);

            const track = document.getElementById('roulette-track');
            if (!track) { __rouletteSpinning = false; __updateRouletteUI(); return; }

            // alvo central
            const targetX = -((WIN_INDEX * __ROULETTE_ITEM_W + __ROULETTE_ITEM_W/2) - viewW/2);

            const anim = track.animate([
                { transform: 'translateX(0px)' },
                { transform: `translateX(${targetX}px)` }
            ], {
                duration: 5200,
                easing: 'cubic-bezier(0.08, 0.9, 0.12, 1)',
                fill: 'forwards'
            });

            // registra runtime para poder cancelar se fechar a modal
            __rouletteRuntime.anim = anim;
            __rouletteRuntime.tickRunning = true;

            // ticks sincronizados com a passagem dos itens (estilo CS:GO)
            let __lastTickIndex = null;
            let __lastX = 0;
            let __lastT = performance.now();

            const __tickLoop = () => {
                if (!__rouletteRuntime.tickRunning) return;
                const x = __getTranslateX(track);
                const now = performance.now();
                const dt = Math.max(16, now - __lastT);
                const speed = Math.min(1.8, Math.abs(x - __lastX) / dt * 0.9);
                __lastX = x;
                __lastT = now;

                const idx = Math.max(0, Math.floor(((-x) + (viewW/2)) / __ROULETTE_ITEM_W));
                if (__lastTickIndex === null) __lastTickIndex = idx;
                if (idx !== __lastTickIndex) {
                    __lastTickIndex = idx;
                    playRouletteTick(0.85 + speed*0.35);
                }
                __rouletteRuntime.tickRaf = requestAnimationFrame(__tickLoop);
            };
            __rouletteRuntime.tickRaf = requestAnimationFrame(__tickLoop);

            anim.onfinish = () => {
                __rouletteRuntime.tickRunning = false;
                try { if (__rouletteRuntime.tickRaf) cancelAnimationFrame(__rouletteRuntime.tickRaf); } catch(e){}
                __rouletteRuntime.tickRaf = 0;
                __rouletteRuntime.anim = null;

                __awardRouletteItem(winItem);
                __rouletteSpinning = false;
                __updateRouletteUI();
                playSysSound(880, 'square', 0.22);
            };
        }

        // Runtime de roleta (anti-leak): permite cancelar animações/RAF ao fechar modal
        const __rouletteRuntime = { anim: null, tickRaf: 0, tickRunning: false };
        function __stopRouletteRuntime(){
            try { __rouletteRuntime.tickRunning = false; } catch(e){}
            try { if (__rouletteRuntime.tickRaf) cancelAnimationFrame(__rouletteRuntime.tickRaf); } catch(e){}
            __rouletteRuntime.tickRaf = 0;

            try {
                if (__rouletteRuntime.anim) {
                    __rouletteRuntime.anim.onfinish = null;
                    __rouletteRuntime.anim.cancel();
                }
            } catch(e){}
            __rouletteRuntime.anim = null;

            // se fechou no meio, garante UI consistente
            try { __rouletteSpinning = false; __updateRouletteUI(); } catch(e){}
        }



        function __dupReward(rarity) {
            if (rarity === 'common') return 80;
            if (rarity === 'rare') return 180;
            if (rarity === 'epic') return 450;
            if (rarity === 'legendary') return 1100;
            return 2500;
        }

        function __awardRouletteItem(it) {
            if (!it) return;

            const inv = __getInventory();
            const isShop = (it.kind === 'shop' && it.shop && it.shop.category && it.shop.value);
            const shopId = isShop ? (it.shop.category + '-' + it.shop.value) : null;
            const alreadyShop = isShop ? purchasedItems.includes(shopId) : false;
            const alreadyInv = (!isShop) ? inv.includes(it.id) : false;

            // Duplicata -> XC
            if (alreadyInv || alreadyShop) {
                const add = __dupReward(it.rarity);
                userCoins += add;
                saveEconomy();
                localStorage.setItem(__RKEY.last, `DUPLICATA: ${it.name}`);
                __pushHist({ name: `DUPLICATA: ${it.name} (+${add} XC)`, rarity: it.rarity, ts: Date.now() });
                __renderRouletteHistory();
                showToast('DUPLICATA', it.name, `+${add} XC`, 'paid');
                playSysSound(860, 'square', 0.18);
                __bumpPity('common');
                openRouletteInventory(true);
                return;
            }

            // Registrar no inventário da roleta (para itens não-loja, e também para loja como registro)
            if (!inv.includes(it.id)) inv.push(it.id);
            __setInventory(inv);

            // Desbloqueio de itens da LOJA (não equipa automaticamente - opção A)
            if (isShop && shopId) {
                purchasedItems.push(shopId);
                saveEconomy();
                updateStoreVisuals();
            }

            // Efeitos
            if (it.kind === 'effect' && it.effect && it.effect.fxMode) {
                avatarConfig.fxMode = it.effect.fxMode;
                if (!avatarConfig.fxSeed) avatarConfig.fxSeed = String(Date.now());
            }

            // Aplicar preset/paleta/moldura no avatar (equip automático apenas para itens do avatar)
            if (it.kind === 'preset' && it.preset) {
                try {
                    if (typeof avatarConfig === 'object') {
                        Object.assign(avatarConfig, it.preset);
                        avatarConfig = __normalize(avatarConfig);
                        __setPreview();
                        if (typeof __renderCustomizerUI === 'function') __renderCustomizerUI();
                    }
                } catch(e) {}
            }

            if (it.kind === 'palette' && it.unlock) {
                try {
                    if (it.unlock.hairColor && it.unlock.hairColor[0]) avatarConfig.hairColor = (''+it.unlock.hairColor[0]).replace('#','');
                    if (it.unlock.clothingColor && it.unlock.clothingColor[0]) avatarConfig.clothingColor = (''+it.unlock.clothingColor[0]).replace('#','');
                    if (it.unlock.accessoriesColor && it.unlock.accessoriesColor[0]) avatarConfig.accessoriesColor = (''+it.unlock.accessoriesColor[0]).replace('#','');
                    avatarConfig = __normalize(avatarConfig);
                    __setPreview();
                } catch(e) {}
            }

            if ((it.kind === 'frame' || it.unlock?.frame) && it.unlock && it.unlock.frame && it.unlock.frame[0]) {
                try {
                    avatarConfig.frame = it.unlock.frame[0];
                    avatarConfig = __normalize(avatarConfig);
                    __setPreview();
                    __applyFrameToPreview();
  try { __ensureFxRefresh(); } catch(e) {}
                } catch(e) {}
            }

            // Sync unlocks
            try { if (typeof __syncRouletteUnlocksToAvatarOptions === 'function') __syncRouletteUnlocksToAvatarOptions(); } catch(e) {}

            // Persistir avatar atual no perfil (para efeitos/paletas) - mantém consistência
            try {
                profiles[activeUser].avatar = JSON.stringify(__normalize(avatarConfig));
                localStorage.setItem('xs_profiles', JSON.stringify(profiles));
                updateDashboardHeader();
                __patchLoginAvatars();
            } catch(e) {}

            localStorage.setItem(__RKEY.last, it.name);
            __pushHist({ name: it.name, rarity: it.rarity, ts: Date.now() });
            __renderRouletteHistory();
            __bumpPity(it.rarity);

            showToast('ROULETA!', `${it.name}`, isShop ? 'DESBLOQUEADO NA LOJA' : null, 'casino');
            openRouletteInventory(true);
        }


        
        function openRouletteInventory(forceOpen) {
            const box = document.getElementById('roulette-inventory');
            if (!box) return;

            // Toggle
            if (forceOpen) box.style.display = 'block';
            else box.style.display = (box.style.display === 'none' || !box.style.display) ? 'block' : 'none';

            // Só renderiza quando estiver visível
            if (box.style.display === 'none') return;

            const grid = document.getElementById('roulette-inv-grid');
            if (!grid) return;

            // Bind filtros (uma vez)
            const filters = document.getElementById('roulette-inv-filters');
            if (filters && !filters.dataset.bound) {
                filters.dataset.bound = '1';
                filters.addEventListener('click', (ev) => {
                    const btn = ev.target && ev.target.closest ? ev.target.closest('button.ri-filter') : null;
                    if (!btn) return;
                    __tapFeedback();
                    playSysSound(420, 'sine', 0.08);
                    __rouletteInvFilter = btn.dataset.filter || 'all';
                    __rouletteInvSelectedId = null;
                    __renderRouletteInventoryGrid();
                });
            }

            // Base do preview (não salva)
            if (!__rouletteInvPreviewBase) {
                try {
                    const raw = profiles?.[activeUser]?.avatar;
                    if (typeof raw === 'string' && raw.trim().startsWith('{')) __rouletteInvPreviewBase = __normalize(JSON.parse(raw));
                    else __rouletteInvPreviewBase = __normalize(__AVATAR_DEFAULT__);
                } catch(e) {
                    __rouletteInvPreviewBase = __normalize(__AVATAR_DEFAULT__);
                }
            }

            // Render
            __renderRouletteInventoryGrid();
        }

        function __rouletteInvCategory(it) {
            try {
                if ((it.kind === 'frame') || (it.unlock && it.unlock.frame)) return 'frames';
                if ((it.kind === 'shop') && it.shop) return 'shop';
            } catch(e) {}
            return 'avatars';
        }

        function __rouletteInvTypeLabel(cat, it) {
            if (cat === 'frames') return 'MOLDURA';
            if (cat === 'shop') return 'LOJA';
            // avatars
            if (it && it.kind === 'palette') return 'PALETA';
            if (it && it.kind === 'effect') return 'EFEITO';
            return 'AVATAR';
        }

        function __setRouletteInvPreview(it) {
            const img = document.getElementById('roulette-inv-preview-img');
            const nameEl = document.getElementById('roulette-inv-preview-name');
            const rarEl = document.getElementById('roulette-inv-preview-rarity');
            if (!img || !nameEl || !rarEl) return;

            if (!it) {
                nameEl.textContent = 'Selecione um item';
                rarEl.textContent = '—';
                try {
                    img.classList.remove('loaded');
                    img.src = buildAvatarURL(__rouletteInvPreviewBase || __normalize(__AVATAR_DEFAULT__));
                    img.onload = () => img.classList.add('loaded');
                    __applyFrameToImg(img, JSON.stringify(__rouletteInvPreviewBase || __normalize(__AVATAR_DEFAULT__)));
                } catch(e) {}
                return;
            }

            const lab = __rarityLabel(it.rarity);
            const cat = __rouletteInvCategory(it);
            nameEl.textContent = it.name || '—';
            rarEl.textContent = `${lab.t} • ${__rouletteInvTypeLabel(cat, it)}`;

            // Monta config temporária para preview (não salva)
            try {
                const base = __rouletteInvPreviewBase ? { ...__rouletteInvPreviewBase } : __normalize(__AVATAR_DEFAULT__);
                let temp = { ...base };

                if (cat === 'shop') {
                    // Para itens de loja/tema, mostra a própria imagem do item
                    img.classList.remove('loaded');
                    img.src = it.img || '';
                    img.onload = () => img.classList.add('loaded');
                    img.style.border = '2px solid rgba(255,255,255,0.18)';
                    img.style.boxShadow = '0 16px 30px rgba(0,0,0,0.35)';
                    return;
                }

                if (it.kind === 'preset' && it.preset) {
                    Object.assign(temp, it.preset);
                } else if (it.kind === 'palette' && it.unlock) {
                    if (it.unlock.hairColor && it.unlock.hairColor[0]) temp.hairColor = ('' + it.unlock.hairColor[0]).replace('#','');
                    if (it.unlock.clothingColor && it.unlock.clothingColor[0]) temp.clothingColor = ('' + it.unlock.clothingColor[0]).replace('#','');
                    if (it.unlock.accessoriesColor && it.unlock.accessoriesColor[0]) temp.accessoriesColor = ('' + it.unlock.accessoriesColor[0]).replace('#','');
                } else if ((it.kind === 'frame' || it.unlock?.frame) && it.unlock && it.unlock.frame && it.unlock.frame[0]) {
                    temp.frame = it.unlock.frame[0];
                } else if (it.kind === 'effect' && it.effect && it.effect.fxMode) {
                    temp.fxMode = it.effect.fxMode;
                }

                temp = __normalize(temp);

                img.classList.remove('loaded');
                img.src = buildAvatarURL(temp);
                img.onload = () => img.classList.add('loaded');
                __applyFrameToImg(img, JSON.stringify(temp));
            } catch(e) {}
        }

        function __renderRouletteInventoryGrid() {
            const grid = document.getElementById('roulette-inv-grid');
            if (!grid) return;

            // Atualiza estado visual dos filtros
            const filters = document.getElementById('roulette-inv-filters');
            if (filters) {
                filters.querySelectorAll('button.ri-filter').forEach(b => {
                    b.classList.toggle('active', (b.dataset.filter || 'all') === (__rouletteInvFilter || 'all'));
                });
            }

            grid.replaceChildren();

            const inv = __getInventory(); // NÃO alterar: vem do localStorage xs_roulette_inv
            const countEl = document.getElementById('roulette-inv-count');
            if (countEl) countEl.textContent = String(inv.length || 0);

            if (!inv || inv.length === 0) {
                const empty = document.createElement('div');
                empty.style.gridColumn = '1/-1';
                empty.style.color = '#777';
                empty.style.textAlign = 'center';
                empty.style.padding = '14px';
                empty.style.borderRadius = '16px';
                empty.style.border = '1px solid rgba(255,255,255,0.12)';
                empty.style.background = 'rgba(0,0,0,0.16)';
                empty.textContent = 'Nenhum prêmio ainda. Gire a roleta!';
                grid.appendChild(empty);
                __setRouletteInvPreview(null);
                return;
            }

            const byId = {};
            (__ROULETTE_ITEMS || []).forEach(x => byId[x.id] = x);

            // Resolve itens e aplica filtro
            const items = inv.map(id => byId[id]).filter(Boolean);
            const filtered = items.filter(it => (__rouletteInvFilter === 'all') || (__rouletteInvCategory(it) === __rouletteInvFilter));

            if (filtered.length === 0) {
                grid.innerHTML = `<div style="grid-column:1/-1; color:#777; text-align:center; padding:14px; border-radius:16px; border:1px solid rgba(255,255,255,0.12); background:rgba(0,0,0,0.16);">Nada aqui com esse filtro.</div>`;
                __setRouletteInvPreview(null);
                return;
            }

            // Render com fragment para performance
            const frag = document.createDocumentFragment();

            filtered.forEach((it) => {
                const lab = __rarityLabel(it.rarity);
                const cat = __rouletteInvCategory(it);
                const isShop = (cat === 'shop');
                const isExclusive = (!isShop && !!it.exclusive);
                const selected = (__rouletteInvSelectedId && __rouletteInvSelectedId === it.id);

                const card = document.createElement('div');
                card.className = `ri-card ${lab.k}` + (selected ? ' selected' : '');
                card.setAttribute('data-id', it.id);

                const seal = isExclusive
                    ? `<div class="ri-seal"><span class="material-icons">verified</span>EXCLUSIVO</div>`
                    : '';

                const btnText = isShop ? 'VER NA LOJA' : 'EQUIPAR';
                const btnClass = isShop ? 'ri-equip ghost' : 'ri-equip';

                card.innerHTML = `
                    ${seal}
                    <div class="ri-media">
                        <img src="${it.img}" alt="" loading="lazy">
                    </div>
                    <div class="ri-body">
                        <div class="ri-name">${it.name}</div>
                        <div class="ri-meta">
                            <div class="ri-rarity"><b>${lab.t}</b></div>
                            <div class="ri-type">${__rouletteInvTypeLabel(cat, it)}</div>
                        </div>
                        <button class="game-btn ${btnClass}" data-equip="1">${btnText}</button>
                    </div>
                `;

                // Fade-in da imagem ao carregar
                const img = card.querySelector('img');
                if (img) {
                    img.addEventListener('load', () => img.classList.add('loaded'), { once: true });
                    img.addEventListener('error', () => { try { img.style.display = 'none'; } catch(e){} }, { once: true });
                }

                // Seleção + preview ao clicar no card (exceto equip)
                card.addEventListener('click', (ev) => {
                    const hitEquip = ev.target && ev.target.closest ? ev.target.closest('button[data-equip]') : null;
                    if (hitEquip) return;

                    __tapFeedback();
                    playSysSound(380, 'sine', 0.07);

                    __rouletteInvSelectedId = it.id;

                    // Atualiza classes (sem rerender completo)
                    grid.querySelectorAll('.ri-card.selected').forEach(el => el.classList.remove('selected'));
                    card.classList.add('selected');

                    // Preview imediato
                    __setRouletteInvPreview(it);
                });

                // Equipar
                const btn = card.querySelector('button[data-equip]');
                if (btn) {
                    btn.addEventListener('click', (ev) => {
                        ev.stopPropagation();
                        __tapFeedback();
                        playSysSound(520, 'sine', 0.08);

                        try {
                            if (isShop) {
                                closeModal('roulette-modal');
                                openModal('custom-app-modal');
                                showToast('LOJA', 'Item desbloqueado! Selecione na loja', null, 'shopping_bag');
                                return;
                            }

                            if (typeof __equipRouletteItem === 'function') {
                                __equipRouletteItem(it);

                                // Atualiza base do preview para refletir o perfil após equipar
                                try {
                                    const raw = profiles?.[activeUser]?.avatar;
                                    if (typeof raw === 'string' && raw.trim().startsWith('{')) __rouletteInvPreviewBase = __normalize(JSON.parse(raw));
                                } catch(e) {}

                                // Se o editor estiver aberto, repinta controles
                                try {
                                    const pm = document.getElementById('profile-modal');
                                    if (pm && pm.style.display === 'flex' && typeof __renderCustomizerUI === 'function') __renderCustomizerUI();
                                } catch(e) {}

                                showToast('EQUIPADO', it.name, null, 'check_circle');
                            }
                        } catch(e) {}
                    });
                }

                frag.appendChild(card);
            });

            grid.appendChild(frag);

            // Se não tiver nada selecionado ainda, seta um preview padrão (base)
            if (!__rouletteInvSelectedId) __setRouletteInvPreview(null);
        }


        function awardSpinsFromPlaytime() {
            // 1 giro bônus a cada 10 minutos jogando (acumulado)
            const step = 300; // 5min
            const earned = Math.floor((playTime || 0) / step);
            const last = parseInt(localStorage.getItem(__RKEY.play) || '0', 10) || 0;
            if (earned > last) {
                const add = earned - last;
                __setBonusSpins(__getBonusSpins() + add);
                localStorage.setItem(__RKEY.play, String(earned));
            }
        }

        // --- CORE ---
        function checkAchievement(id) { let ach = achievements.find(a => a.id === id); if (ach && !ach.unlocked) { ach.unlocked = true; userCoins += ach.reward; saveEconomy(); showToast("CONQUISTA!", `${ach.title}`, `+${ach.reward} XC`, 'emoji_events'); playSysSound(800, 'square', 0.5); evaluateMilestones(); } }
        function showToast(title, msg, rewardText=null, iconName=null) {
            const toast = document.getElementById('achievement-toast');
            if (!toast) return;
            document.getElementById('toast-title').innerText = title;
            document.getElementById('toast-msg').innerText = msg;
            const icon = document.getElementById('toast-icon');
            if (icon) icon.innerText = iconName ? iconName : "";
            const reward = document.getElementById('toast-reward');
            if (rewardText) {
                reward.style.display = 'block';
                reward.innerText = rewardText;
            } else {
                reward.style.display = 'none';
                reward.innerText = '';
            }
            toast.classList.add('show');
            clearTimeout(window.__toastTimer);
            window.__toastTimer = setTimeout(() => { toast.classList.remove('show'); }, 3200);
        }
        function saveEconomy() { localStorage.setItem('xs_coins', userCoins); localStorage.setItem('xs_achievements', JSON.stringify(achievements)); localStorage.setItem('xs_playtime', playTime); localStorage.setItem('xs_purchased', JSON.stringify(purchasedItems)); updateCoinDisplay(); evaluateMilestones(); }
        function saveSettings() { localStorage.setItem('xs_settings', JSON.stringify(systemSettings)); }
        function updateCoinDisplay() { document.getElementById('coin-val').innerText = `${userCoins} XC`; updateStoreVisuals(); }

        function renderAchievements() {
            const list = document.getElementById('ach-list-container'); list.innerHTML = "";
            let h = Math.floor(playTime / 3600); let m = Math.floor((playTime % 3600) / 60);
            document.getElementById('total-time-display').innerText = `${h}h ${m}m`;
            achievements.forEach(ach => {
                const item = document.createElement('div'); item.className = `achievement-item ${ach.unlocked ? 'unlocked' : ''}`;
                item.innerHTML = `<div style="display:flex; align-items:center;"><span class="material-icons ach-icon">${ach.unlocked ? 'emoji_events' : 'lock'}</span><div class="ach-details"><h4>${ach.title}</h4><p>${ach.desc}</p></div></div><div style="font-weight:bold; color:${ach.unlocked ? '#ffd700' : '#666'};">${ach.reward}$</div>`;
                list.appendChild(item);
            });
        }

        function applySavedSettings() {
            changeTheme(systemSettings.theme);
            document.getElementById('vol-slider').value = systemSettings.volume;
            document.getElementById('brightness-slider').value = systemSettings.brightness;
            document.getElementById('brightness-layer').style.opacity = systemSettings.brightness;
            document.getElementById('check-overclock').checked = systemSettings.overclock;
            document.getElementById('check-intro').checked = systemSettings.intro;
            document.getElementById('check-sfx').checked = systemSettings.sfx;
            document.getElementById('sel-buffer').value = systemSettings.buffer;
            document.getElementById('check-aa').checked = systemSettings.aa;
            const selInp = document.getElementById('sel-input');
            if (selInp) selInp.value = systemSettings.inputMode || 'auto';
            applyInputMode();
            awardSpinsFromPlaytime();
            updateStoreVisuals();
            document.getElementById('name0').innerText = profiles[0].name; document.getElementById('av0').innerHTML = `<img src="https://api.dicebear.com/7.x/avataaars/svg?seed=${profiles[0].avatar}" width="100%">`;
            document.getElementById('name1').innerText = profiles[1].name; document.getElementById('av1').innerHTML = `<img src="https://api.dicebear.com/7.x/avataaars/svg?seed=${profiles[1].avatar}" width="100%">`;
        }

        function confirmUser(idx) { activeUser = idx; playSysSound(600, 'sine', 0.2); forceFullscreen(); document.getElementById('user-select-layer').style.display = "none"; document.getElementById('main-ui').style.display = "block"; updateDashboardHeader(); renderTrack(); state = "DASHBOARD"; updateDash(); }
        
        function renderTrack() {
            const track = document.getElementById('track'); track.replaceChildren();
            GAMES.forEach((g, i) => {
                const card = document.createElement('div');
                card.className = `game-card style-${systemSettings.cardStyle} ${i===gameIdx?'active':''}`;
                try { if (g && g.type === 'tutorial') card.classList.add('guide-highlight'); } catch(e) {}
                if(g.icon) card.innerHTML = `<span class="material-icons sys-icon">${g.icon}</span>`;
                else card.innerHTML = `<img src="${g.img}" onerror="this.src='https://placehold.jp/24/003791/ffffff/260x260.png?text=${encodeURIComponent(g.name)}'">`;
                card.onclick = () => { gameIdx = i; updateDash(); forceFullscreen(); };
                track.appendChild(card);
            });
        }

        function sideloadGame() { let url = prompt("URL DO JOGO:"); if(url) { let name = prompt("NOME DO JOGO:"); let newGame = { name: name || "Game Salvo", url: url }; sideloadedGames.push(newGame); localStorage.setItem('xs_sideloads', JSON.stringify(sideloadedGames)); checkAchievement("sideload_king"); evaluateMilestones(); openSideloadFolder(); } }
        function openSideloadFolder() { const list = document.getElementById('sideload-list'); list.innerHTML = ""; if(sideloadedGames.length > 0) { document.getElementById('folder-empty-msg').style.display = "none"; sideloadedGames.forEach((g, i) => { const item = document.createElement('div'); item.className = "sideload-item"; item.innerHTML = `<span>${g.name}</span><button class="game-btn" style="background:transparent; color:#ff3b3b; padding:0;" onclick="deleteSideload(${i}); event.stopPropagation();">🗑️</button>`; item.onclick = () => { playGame(g.url); closeModal('sideload-folder-modal'); }; list.appendChild(item); }); } else { document.getElementById('folder-empty-msg').style.display = "block"; } openModal('sideload-folder-modal'); }
        function deleteSideload(idx) { sideloadedGames.splice(idx, 1); localStorage.setItem('xs_sideloads', JSON.stringify(sideloadedGames)); openSideloadFolder(); }
        function playGame(url) {
            playSysSound(800, 'sine', 0.3);
            forceFullscreen();
            const now = new Date();
            const h = now.getHours();
            const d = now.getDay();
            if (h >= 0 && h < 5) checkAchievement('insomnia');
            if (h >= 22) checkAchievement('night_owl');
            if (h >= 5 && h < 8) checkAchievement('early_bird');
            if (d === 0 || d === 6) checkAchievement('weekend_warrior');
            stats.gamesLaunched++; saveStats();
            sessionSeconds = 0;
            document.getElementById('game-runtime').style.display = "block";
            const gf = document.getElementById('game-frame');
            const ext = document.getElementById('external-runtime');

            // FIX: sempre resetar o modo "abrir em nova aba" ao iniciar qualquer jogo
            try{ if(ext) ext.style.display = "none"; }catch(e){}
            try{ if(gf) gf.style.display = "block"; }catch(e){}
            try{ if(__popupWin && !__popupWin.closed) __popupWin.close(); }catch(e){}
            __popupWin = null;
            __externalUrl = null;

            
            // FIX: se o Bixin Explorador (Dino) estava aberto antes, esconda e pare para não sobrepor outros jogos
            try { if (typeof __DINO_RUN__ !== 'undefined' && __DINO_RUN__ && __DINO_RUN__.stop) __DINO_RUN__.stop(); } catch(e) {}
            try { const dinoCont = document.getElementById('dino-game-container'); if (dinoCont) dinoCont.style.display = 'none'; } catch(e) {}
// Sites that often block iframe embedding (X-Frame-Options / CSP)
            if(url && /(^|\.)(gam\.onl|smashkarts\.io|poncle\.itch\.io|universe\.flyff\.com)(\/|$)/i.test(url.replace(/^https?:\/\//,'').split('#')[0])){
                __externalUrl = url;
                if(gf){ gf.style.display = "none"; gf.src = ""; }
                if(ext) ext.style.display = "flex";
                __openPopup(url);
                return;
            } else {
                if(ext) ext.style.display = "none";
                if(gf){ gf.style.display = "block"; gf.src = url; }
            }
            playTimerInterval = setInterval(() => {
                playTime++;
                sessionSeconds++;
                if (playTime % 5 === 0) evaluateMilestones();
                if (playTime % 60 === 0) saveEconomy();
                if (playTime % 30 === 0) awardSpinsFromPlaytime();
            }, 1000);
        }
        function __xsCenterSelectedCard(behavior){
    const container = document.querySelector('.carousel-container');
    const cards = document.querySelectorAll('.game-card');
    const card = cards && cards[gameIdx];
    if(!container || !card) return;
    const b = behavior || 'smooth';

    // Primary: native API
    try{
        card.scrollIntoView({ behavior: b, block: 'nearest', inline: 'center' });
        return;
    }catch(e){}

    // Fallback: manual centering (older WebViews)
    try{
        const cRect = card.getBoundingClientRect();
        const sRect = container.getBoundingClientRect();
        const delta = (cRect.left + cRect.width/2) - (sRect.left + sRect.width/2);
        container.scrollLeft += delta;
    }catch(e){}
}

function updateDash() {
    const cards = document.querySelectorAll('.game-card');
    cards.forEach((c, i) => c.classList.toggle('active', i === gameIdx));

    const title = document.getElementById('game-title');
    if (title) title.innerText = GAMES[gameIdx].name;

    // Stop using translateX hardcode (breaks responsive sizing)
    const tr = document.getElementById('track');
    if (tr) tr.style.transform = 'translateX(0px)';

    // Center the active card in the carousel
    __xsCenterSelectedCard('smooth');
}

        
        function actionEnter() {
            const game = GAMES[gameIdx];
            if(state === "LOGIN") confirmUser(activeUser);
            else if(game.type === "tutorial") { stats.tutorialOpens++; saveStats(); evaluateMilestones(); openModal('tutorial-modal'); }
            else if(game.type === "emu_folder") { openEmuFolder(game); }
            else if(game.type === "settings") openModal('settings-modal');
            else if(game.type === "custom") { stats.shopOpens++; saveStats(); evaluateMilestones(); openModal('custom-app-modal'); }
            else if(game.type === "achievements") { renderAchievements(); openModal('achievements-modal'); }
            else if(game.type === "roulette") { openRoulette(); }
            else if(game.type === "jukebox") { openJukebox(); }
            else if(game.type === "dino") startDinoFromConsole();

            else if(game.type === "files") { openXsDrive(); }

             else if(game.type === "folder") openSideloadFolder();
            else playGame(game.url);
        }


        function openModal(id) { document.getElementById(id).style.display = "flex"; }
        function closeModal(id) {
          try {
            const el = document.getElementById(id);
            if (el) el.style.display = "none";
          } catch(e){}

          // Anti-leak: ao fechar roleta no meio do giro, cancela RAF/animação
          if (id === 'roulette-modal') {
            try { __stopRouletteRuntime(); } catch(e){}
          }

          forceFullscreen();
        }
        
// Popup fallback for sites that block iframes (ex.: GAM.ONL)
let __popupWin = null;
let __externalUrl = null;
function __openPopup(url){
  try{ if(__popupWin && !__popupWin.closed) __popupWin.close(); }catch(e){}
  try{ __popupWin = window.open(url, "_blank"); }catch(e){ __popupWin = null; }
}

function closeGame(){
  try{
    const rt = document.getElementById('game-runtime');
    const gf = document.getElementById('game-frame');
    const ext = document.getElementById('external-runtime');
    if(ext) ext.style.display = "none";
    if(gf){ gf.style.display = "block"; gf.src = ""; }
    if(rt) rt.style.display = "none";
    clearInterval(playTimerInterval);
    sessionSeconds = 0;
    saveEconomy();
    try{ if(__popupWin && !__popupWin.closed) __popupWin.close(); }catch(e){}
    __popupWin = null;
    __externalUrl = null;
    forceFullscreen();
  }catch(e){}
}

        

        // =========================
        // XS Emulator Folders (PS1 / SNES / Arcade)
        // =========================
        let __emuFolder = null;
        function openEmuFolder(game){
            __emuFolder = game || null;
            const t = document.getElementById('emu-folder-title');
            const c = document.getElementById('emu-folder-cover');
            const d = document.getElementById('emu-folder-desc');
            if(t) t.textContent = (game && game.name ? game.name : 'EMULADOR').toUpperCase();
            if(c){
                c.src = (game && game.img) ? game.img : '';
                c.onerror = () => { c.src = 'https://placehold.jp/24/003791/ffffff/320x320.png?text=EMULADOR'; };
            }
            if(d){
                const label = (game && game.name) ? game.name : 'Emulador';
                d.innerHTML = `Pasta de emulador: <b>${label}</b><br>Abra em tela cheia. Use o botão <b>FECHAR JOGO</b> para sair.`;
            }
            openModal('emu-folder-modal');
        }
        function launchEmuFolder(){
            if(!__emuFolder || !__emuFolder.url) return;
            closeModal('emu-folder-modal');
            playGame(__emuFolder.url);
        }

        /* ======================
           XS DRIVE (Virtual File System)
           - Armazenamento: localStorage['xs_drive_v1']
           - Sem simplificar: robusto, com validação e lixeira
           ====================== */
        const XS_DRIVE_KEY = 'xs_drive_v1';

        let xsDriveFS = null;
        let xsDriveUI = { mode: 'drive', cwd: null, selected: null, dirty: false };
        let __xsDriveBound = false;

        function __xsDriveNow(){ return Date.now(); }
        function __xsDriveId(prefix){
            return (prefix || 'n') + '_' + Math.random().toString(36).slice(2, 9) + Math.random().toString(36).slice(2, 6);
        }
        function __xsDriveSafeName(name, fallback){
            const n = String(name || '').trim().replace(/\s+/g, ' ');
            return n.length ? n : (fallback || 'Novo');
        }
        function __xsDriveBytes(str){
            try { return new Blob([String(str || '')]).size; } catch(e){ return (String(str||'').length || 0); }
        }
        function __xsDriveHuman(bytes){
            const b = Math.max(0, bytes|0);
            if (b < 1024) return b + ' B';
            const kb = b / 1024;
            if (kb < 1024) return kb.toFixed(1) + ' KB';
            const mb = kb / 1024;
            if (mb < 1024) return mb.toFixed(2) + ' MB';
            return (mb/1024).toFixed(2) + ' GB';
        }

        function __xsDriveDefault(){
            const t = __xsDriveNow();
            const root = 'root';
            const notes = __xsDriveId('dir');
            const saves = __xsDriveId('dir');
            const exports = __xsDriveId('dir');
            const trash = __xsDriveId('dir');

            const readme = __xsDriveId('file');
            const mkDir = (id, name, parent) => ({ id, type:'dir', name, parent, children:[], createdAt:t, updatedAt:t });
            const mkFile = (id, name, parent, mime, content) => ({ id, type:'file', name, parent, mime: mime || 'text/plain', content: String(content||''), createdAt:t, updatedAt:t });

            const fs = {
                v: 1,
                root,
                sys: { notes, saves, exports, trash },
                nodes: {}
            };

            fs.nodes[root] = { id: root, type:'dir', name:'/', parent: null, children:[notes, saves, exports, trash], createdAt:t, updatedAt:t };
            fs.nodes[notes] = mkDir(notes, 'NOTES', root);
            fs.nodes[saves] = mkDir(saves, 'SAVES', root);
            fs.nodes[exports] = mkDir(exports, 'EXPORTS', root);
            fs.nodes[trash] = mkDir(trash, 'LIXEIRA', root);

            fs.nodes[readme] = mkFile(readme, 'README.txt', notes, 'text/plain',
`Bem-vindo ao XS DRIVE!

• PASTAS: crie pastas pra organizar notas, configs, saves.
• NOTAS: arquivos de texto editáveis aqui mesmo.
• UPLOAD: importa arquivos de texto (.txt/.json/.js/.css/.html) pro drive.
• BACKUP: exporta tudo do drive em um .json (pra migrar/recuperar).

Dica: use o XS DRIVE como "memória" do console — sem quebrar nada do sistema :)
`);
            fs.nodes[notes].children.push(readme);

            return fs;
        }

        function __xsDriveLoad(){
            try{
                const raw = localStorage.getItem(XS_DRIVE_KEY);
                if(!raw) return null;
                const parsed = JSON.parse(raw);
                if(!parsed || typeof parsed !== 'object') return null;
                if(!parsed.nodes || typeof parsed.nodes !== 'object') return null;
                if(!parsed.root || !parsed.nodes[parsed.root]) return null;
                // sanity: garante sys
                if(!parsed.sys || !parsed.sys.trash) parsed.sys = { ...(parsed.sys||{}), trash: __xsDriveId('dir') };
                return parsed;
            }catch(e){ return null; }
        }

        function __xsDriveSave(){
            try{ localStorage.setItem(XS_DRIVE_KEY, JSON.stringify(xsDriveFS)); }catch(e){}
        }

        function __xsDriveEnsure(){
            if(xsDriveFS) return xsDriveFS;
            xsDriveFS = __xsDriveLoad() || __xsDriveDefault();

            // repair: garante nós do sistema
            try{
                const t = __xsDriveNow();
                const root = xsDriveFS.root || 'root';
                if(!xsDriveFS.nodes[root]){
                    xsDriveFS.root = 'root';
                    xsDriveFS.nodes['root'] = { id:'root', type:'dir', name:'/', parent:null, children:[], createdAt:t, updatedAt:t };
                }
                if(!xsDriveFS.sys) xsDriveFS.sys = {};
                const ensureDir = (key, name) => {
                    let id = xsDriveFS.sys[key];
                    if(!id || !xsDriveFS.nodes[id] || xsDriveFS.nodes[id].type !== 'dir'){
                        id = __xsDriveId('dir');
                        xsDriveFS.sys[key] = id;
                        xsDriveFS.nodes[id] = { id, type:'dir', name, parent: xsDriveFS.root, children:[], createdAt:t, updatedAt:t };
                        try{
                            const r = xsDriveFS.nodes[xsDriveFS.root];
                            if(r && r.type==='dir' && !r.children.includes(id)) r.children.push(id);
                        }catch(e){}
                    }
                };
                ensureDir('notes','NOTES');
                ensureDir('saves','SAVES');
                ensureDir('exports','EXPORTS');
                ensureDir('trash','LIXEIRA');
            }catch(e){}

            __xsDriveSave();
            return xsDriveFS;
        }

        function __xsDriveNode(id){ try { return xsDriveFS.nodes[id]; } catch(e){ return null; } }
        function __xsDriveIsRoot(id){ return id === (xsDriveFS ? xsDriveFS.root : 'root'); }

        function __xsDriveChildren(dirId){
            const d = __xsDriveNode(dirId);
            if(!d || d.type !== 'dir') return [];
            const out = (d.children || []).map(cid => __xsDriveNode(cid)).filter(Boolean);
            out.sort((a,b)=>{
                if(a.type !== b.type) return a.type === 'dir' ? -1 : 1;
                return String(a.name||'').localeCompare(String(b.name||''), 'pt-BR');
            });
            return out;
        }

        function __xsDrivePath(id){
            const p = [];
            let cur = __xsDriveNode(id);
            let guard = 0;
            while(cur && guard++ < 64){
                p.push(cur);
                if(cur.parent == null) break;
                cur = __xsDriveNode(cur.parent);
            }
            return p.reverse();
        }

        function __xsDriveTouch(node){
            try{ node.updatedAt = __xsDriveNow(); }catch(e){}
        }

        function __xsDriveAttach(parentId, childId){
            const p = __xsDriveNode(parentId);
            const c = __xsDriveNode(childId);
            if(!p || p.type !== 'dir' || !c) return;
            if(!p.children) p.children = [];
            if(!p.children.includes(childId)) p.children.push(childId);
            c.parent = parentId;
            __xsDriveTouch(p);
            __xsDriveTouch(c);
        }

        function __xsDriveDetach(parentId, childId){
            const p = __xsDriveNode(parentId);
            if(!p || p.type !== 'dir' || !p.children) return;
            const i = p.children.indexOf(childId);
            if(i >= 0) p.children.splice(i, 1);
            __xsDriveTouch(p);
        }

        function __xsDriveDownload(filename, content, mime){
            try{
                const blob = new Blob([content], { type: mime || 'application/octet-stream' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename || 'download';
                document.body.appendChild(a);
                a.click();
                setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); a.remove(); }catch(e){} }, 800);
            }catch(e){}
        }

        function __xsDriveBindOnce(){
            if(__xsDriveBound) return;
            __xsDriveBound = true;

            const up = document.getElementById('xsDriveUploadInput');
            const imp = document.getElementById('xsDriveImportInput');

            if(up){
                up.addEventListener('change', async (ev)=>{
                    try{
                        const f = ev.target.files && ev.target.files[0];
                        ev.target.value = '';
                        if(!f) return;

                        const okText = (f.type.startsWith('text/') || f.type.includes('json') || f.name.match(/\.(txt|json|js|css|html|md)$/i));
                        if(!okText){
                            showToast('XS DRIVE','Upload bloqueado','Por segurança, só aceito arquivos de texto (.txt/.json/.js/.css/.html/.md).','folder');
                            playSysSound(140, 'sawtooth', 0.12);
                            return;
                        }

                        const text = await f.text();
                        __xsDriveEnsure();
                        const parent = xsDriveUI.cwd || xsDriveFS.root;
                        const id = __xsDriveId('file');
                        const mime = f.type || 'text/plain';
                        xsDriveFS.nodes[id] = { id, type:'file', name: __xsDriveSafeName(f.name,'Arquivo.txt'), parent, mime, content: String(text||''), createdAt: __xsDriveNow(), updatedAt: __xsDriveNow() };
                        __xsDriveAttach(parent, id);
                        __xsDriveSave();

                        try { stats.driveImports = (stats.driveImports||0)+1; saveStats(); } catch(e){}
                        try { evaluateMilestones(); } catch(e){}

                        showToast('XS DRIVE','Arquivo importado', f.name, 'folder');
                        playSysSound(820, 'sine', 0.12);
                        __xsDriveRender();
                    }catch(e){}
                });
            }

            if(imp){
                imp.addEventListener('change', async (ev)=>{
                    try{
                        const f = ev.target.files && ev.target.files[0];
                        ev.target.value = '';
                        if(!f) return;

                        const text = await f.text();
                        let parsed = null;
                        try { parsed = JSON.parse(text); } catch(e){ parsed = null; }
                        if(!parsed || typeof parsed !== 'object' || !parsed.nodes){
                            showToast('XS DRIVE','Import falhou','Arquivo inválido (precisa ser um backup do XS Drive).','folder');
                            playSysSound(140, 'sawtooth', 0.12);
                            return;
                        }

                        // backup interno (só pra não perder)
                        try{
                            const stamp = new Date().toISOString().replace(/[:.]/g,'-');
                            localStorage.setItem('xs_drive_backup_'+stamp, localStorage.getItem(XS_DRIVE_KEY) || '');
                        }catch(e){}

                        // aplica e repara estrutura
                        xsDriveFS = parsed;
                        __xsDriveEnsure(); // faz repair + save
                        xsDriveUI.mode = 'drive';
                        xsDriveUI.cwd = xsDriveFS.root;
                        xsDriveUI.selected = null;

                        try { stats.driveImports = (stats.driveImports||0)+1; saveStats(); } catch(e){}
                        try { evaluateMilestones(); } catch(e){}

                        showToast('XS DRIVE','Backup importado','Drive restaurado com sucesso','folder');
                        playSysSound(900, 'square', 0.12);
                        __xsDriveRender();
                    }catch(e){}
                });
            }
        }

        function __xsDrivePromptOpen(opts){
            try{
                const layer = document.getElementById('xsDrivePrompt');
                if(!layer) return;
                layer.style.display = 'flex';
                layer.dataset.mode = (opts && opts.multiline) ? 'textarea' : 'input';
                layer.dataset.ok = '1';

                const t = document.getElementById('xsDrivePromptTitle');
                const d = document.getElementById('xsDrivePromptDesc');
                const i = document.getElementById('xsDrivePromptInput');
                const ta = document.getElementById('xsDrivePromptTextarea');

                if(t) t.textContent = (opts && opts.title) ? opts.title : 'XS Prompt';
                if(d) d.innerHTML = (opts && opts.desc) ? opts.desc : '';

                if(i){
                    i.style.display = (opts && opts.multiline) ? 'none' : 'block';
                    i.value = (opts && typeof opts.value === 'string') ? opts.value : '';
                    i.placeholder = (opts && opts.placeholder) ? opts.placeholder : 'Digite aqui...';
                }
                if(ta){
                    ta.style.display = (opts && opts.multiline) ? 'block' : 'none';
                    ta.value = (opts && typeof opts.value === 'string') ? opts.value : '';
                    ta.placeholder = (opts && opts.placeholder) ? opts.placeholder : 'Conteúdo...';
                }

                layer.__ok = (opts && typeof opts.ok === 'function') ? opts.ok : null;
                layer.__cancel = (opts && typeof opts.cancel === 'function') ? opts.cancel : null;

                setTimeout(()=>{
                    try{
                        if(opts && opts.multiline){
                            if(ta) ta.focus();
                        } else {
                            if(i) i.focus();
                        }
                    }catch(e){}
                }, 40);
            }catch(e){}
        }

        function xsDrivePromptClose(){ try{ const l=document.getElementById('xsDrivePrompt'); if(l){ l.style.display='none'; l.__ok=null; l.__cancel=null; } }catch(e){} }
        function xsDrivePromptCancel(){ try{ const l=document.getElementById('xsDrivePrompt'); if(l && l.__cancel) l.__cancel(); }catch(e){} xsDrivePromptClose(); }
        function xsDrivePromptOk(){
            try{
                const l = document.getElementById('xsDrivePrompt');
                if(!l) return;
                const mode = l.dataset.mode || 'input';
                const i = document.getElementById('xsDrivePromptInput');
                const ta = document.getElementById('xsDrivePromptTextarea');
                const val = (mode === 'textarea') ? (ta ? ta.value : '') : (i ? i.value : '');
                if(l.__ok) l.__ok(val);
            }catch(e){}
            xsDrivePromptClose();
        }

        function __xsDriveRender(){
            try{
                __xsDriveEnsure();
                __xsDriveBindOnce();

                if(!xsDriveUI.cwd) xsDriveUI.cwd = xsDriveFS.root;

                const crumb = document.getElementById('xsDriveCrumb');
                const list = document.getElementById('xsDriveList');
                const title = document.getElementById('xsDriveFileTitle');
                const hint  = document.getElementById('xsDriveFileHint');
                const editor = document.getElementById('xsDriveEditor');
                const meta = document.getElementById('xsDriveMeta');

                const isTrashMode = xsDriveUI.mode === 'trash';
                const cwd = isTrashMode ? (xsDriveFS.sys && xsDriveFS.sys.trash ? xsDriveFS.sys.trash : xsDriveFS.root) : (xsDriveUI.cwd || xsDriveFS.root);

                // breadcrumb
                if(crumb){
                    const path = __xsDrivePath(cwd);
                    const segs = path.map((n, idx)=>{
                        const label = idx === 0 ? 'ROOT' : (n.name || '??');
                        return `<span class="xs-crumb" onclick="xsDriveGoTo('${n.id}')">${label}</span>`;
                    });
                    crumb.innerHTML = (isTrashMode ? `<span class="xs-crumb" onclick="xsDriveToggleTrash()">LIXEIRA</span><span class="xs-sep">•</span>` : '') + segs.join(`<span class="xs-sep">›</span>`);
                }

                // list
                if(list){
                    const items = __xsDriveChildren(cwd);
                    if(!items.length){
                        list.innerHTML = `<div style="padding:12px; color:#aab5cf; font-size:0.9rem;">${isTrashMode ? 'Lixeira vazia.' : 'Pasta vazia. Crie uma Nota ou Pasta :)'}</div>`;
                    } else {
                        list.innerHTML = items.map(n=>{
                            const icon = (n.type === 'dir') ? 'folder' : 'description';
                            const ext = (n.type === 'file') ? (String(n.name||'').split('.').pop().toUpperCase()) : 'DIR';
                            const tag = `<span class="tag">${ext}</span>`;
                            const size = (n.type === 'file') ? __xsDriveHuman(__xsDriveBytes(n.content||'')) : ((n.children||[]).length + ' itens');
                            const active = (xsDriveUI.selected === n.id) ? 'active' : '';
                            return `<div class="xs-drive-item ${active}" onclick="xsDriveOpen('${n.id}')">
                                <span class="material-icons">${icon}</span>
                                <div style="display:flex; flex-direction:column; gap:2px;">
                                    <div style="font-weight:800; color:#e9f0ff; font-size:0.92rem;">${(n.name||'Sem nome')}</div>
                                    <div style="opacity:.75; color:#aab5cf; font-size:0.78rem;">${size}</div>
                                </div>
                                <div class="meta">${tag}</div>
                            </div>`;
                        }).join('');
                    }
                }

                // editor panel
                const sel = xsDriveUI.selected ? __xsDriveNode(xsDriveUI.selected) : null;
                if(!sel || sel.type !== 'file'){
                    if(title) title.textContent = isTrashMode ? 'Lixeira' : 'Selecione um arquivo';
                    if(hint) hint.textContent = isTrashMode ? 'Arquivos aqui podem ser restaurados (Voltar) ou apagados (Excluir).' : 'Dica: crie uma Nota, edite e clique em Salvar.';
                    if(editor){ editor.value = ''; editor.placeholder = isTrashMode ? 'Nada selecionado na lixeira...' : 'Nada selecionado...'; }
                    if(meta) meta.innerHTML = `<span class="pill">Modo: ${isTrashMode ? 'LIXEIRA' : 'DRIVE'}</span><span class="pill">Itens: ${( __xsDriveNode(cwd) && __xsDriveNode(cwd).children ? __xsDriveNode(cwd).children.length : 0)}</span>`;
                } else {
                    if(title) title.textContent = sel.name || 'Arquivo';
                    if(hint) hint.textContent = sel.mime || 'text/plain';
                    if(editor){ editor.value = String(sel.content||''); editor.placeholder = 'Edite aqui...'; }
                    const created = sel.createdAt ? new Date(sel.createdAt).toLocaleString('pt-BR') : '—';
                    const updated = sel.updatedAt ? new Date(sel.updatedAt).toLocaleString('pt-BR') : '—';
                    const bytes = __xsDriveBytes(sel.content||'');
                    if(meta) meta.innerHTML = `
                        <span class="pill">Tamanho: ${__xsDriveHuman(bytes)}</span>
                        <span class="pill">Criado: ${created}</span>
                        <span class="pill">Atualizado: ${updated}</span>
                        <span class="pill">Modo: ${isTrashMode ? 'LIXEIRA' : 'DRIVE'}</span>
                    `;
                }

                // estado
                xsDriveUI.cwd = cwd;

            }catch(e){}
        }

        function openXsDrive(){
            __xsDriveEnsure();
            xsDriveUI.mode = 'drive';
            xsDriveUI.cwd = xsDriveFS.root;
            xsDriveUI.selected = null;
            openModal('drive-modal');
            __xsDriveRender();

            try { stats.filesOpens = (stats.filesOpens||0)+1; saveStats(); } catch(e){}
            try { evaluateMilestones(); } catch(e){}
        }

        function xsDriveGoTo(id){
            try{
                __xsDriveEnsure();
                const n = __xsDriveNode(id);
                if(!n || n.type !== 'dir') return;
                xsDriveUI.selected = null;
                xsDriveUI.cwd = id;
                __xsDriveRender();
                playSysSound(720, 'sine', 0.05);
            }catch(e){}
        }

        function xsDriveGoUp(){
            try{
                __xsDriveEnsure();
                const cwd = xsDriveUI.cwd || xsDriveFS.root;
                const n = __xsDriveNode(cwd);
                if(!n || !n.parent) return;
                if(xsDriveUI.mode === 'trash') return; // lixeira não sobe pro root pra não confundir
                xsDriveUI.selected = null;
                xsDriveUI.cwd = n.parent;
                __xsDriveRender();
                playSysSound(700, 'sine', 0.05);
            }catch(e){}
        }

        function xsDriveToggleTrash(){
            try{
                __xsDriveEnsure();
                if(xsDriveUI.mode === 'trash'){
                    xsDriveUI.mode = 'drive';
                    xsDriveUI.cwd = xsDriveFS.root;
                }else{
                    xsDriveUI.mode = 'trash';
                    xsDriveUI.cwd = (xsDriveFS.sys && xsDriveFS.sys.trash) ? xsDriveFS.sys.trash : xsDriveFS.root;
                }
                xsDriveUI.selected = null;
                __xsDriveRender();
                playSysSound(520, 'triangle', 0.06);
            }catch(e){}
        }

        function xsDriveOpen(id){
            try{
                __xsDriveEnsure();
                const n = __xsDriveNode(id);
                if(!n) return;
                if(n.type === 'dir'){
                    if(xsDriveUI.mode === 'trash') return; // mantém a lixeira "flat" pra não quebrar UX
                    xsDriveUI.cwd = id;
                    xsDriveUI.selected = null;
                    playSysSound(760, 'sine', 0.06);
                    __xsDriveRender();
                }else{
                    xsDriveUI.selected = id;
                    playSysSound(820, 'sine', 0.05);
                    __xsDriveRender();
                }
            }catch(e){}
        }

        function xsDriveNewFolder(){
            try{
                __xsDriveEnsure();
                const parent = (xsDriveUI.mode === 'trash') ? null : (xsDriveUI.cwd || xsDriveFS.root);
                if(!parent){
                    showToast('XS DRIVE','Ação bloqueada','Crie pastas fora da lixeira.','folder');
                    playSysSound(140, 'sawtooth', 0.12);
                    return;
                }
                __xsDrivePromptOpen({
                    title: 'Nova Pasta',
                    desc: 'Digite o nome da pasta:',
                    placeholder: 'Ex: Meus Saves',
                    value: '',
                    multiline: false,
                    ok: (val)=>{
                        const name = __xsDriveSafeName(val,'Nova Pasta');
                        const id = __xsDriveId('dir');
                        xsDriveFS.nodes[id] = { id, type:'dir', name, parent, children:[], createdAt: __xsDriveNow(), updatedAt: __xsDriveNow() };
                        __xsDriveAttach(parent, id);
                        __xsDriveSave();
                        showToast('XS DRIVE','Pasta criada', name, 'folder');
                        playSysSound(900,'square',0.08);
                        __xsDriveRender();
                    }
                });
            }catch(e){}
        }

        function xsDriveNewNote(){
            try{
                __xsDriveEnsure();
                const parent = (xsDriveUI.mode === 'trash') ? null : (xsDriveUI.cwd || xsDriveFS.root);
                if(!parent){
                    showToast('XS DRIVE','Ação bloqueada','Crie notas fora da lixeira.','folder');
                    playSysSound(140, 'sawtooth', 0.12);
                    return;
                }
                __xsDrivePromptOpen({
                    title: 'Nova Nota',
                    desc: 'Nome do arquivo (.txt opcional):',
                    placeholder: 'Ex: minha_lista.txt',
                    value: '',
                    multiline: false,
                    ok: (nameRaw)=>{
                        const base = __xsDriveSafeName(nameRaw,'Nova Nota');
                        const name = base.match(/\.[a-z0-9]+$/i) ? base : (base + '.txt');
                        __xsDrivePromptOpen({
                            title: 'Conteúdo inicial',
                            desc: 'Opcional: escreva algo pra começar.',
                            placeholder: 'Digite aqui...',
                            value: '',
                            multiline: true,
                            ok: (content)=>{
                                const id = __xsDriveId('file');
                                xsDriveFS.nodes[id] = { id, type:'file', name, parent, mime:'text/plain', content: String(content||''), createdAt: __xsDriveNow(), updatedAt: __xsDriveNow() };
                                __xsDriveAttach(parent, id);
                                xsDriveUI.selected = id;
                                __xsDriveSave();

                                try { stats.driveWrites = (stats.driveWrites||0)+1; saveStats(); } catch(e){}
                                try { evaluateMilestones(); } catch(e){}

                                showToast('XS DRIVE','Nota criada', name, 'folder');
                                playSysSound(980,'sine',0.09);
                                __xsDriveRender();
                            }
                        });
                    }
                });
            }catch(e){}
        }

        function xsDriveSaveFile(){
            try{
                __xsDriveEnsure();
                const id = xsDriveUI.selected;
                const n = id ? __xsDriveNode(id) : null;
                if(!n || n.type !== 'file'){
                    showToast('XS DRIVE','Nada pra salvar','Selecione um arquivo primeiro.','folder');
                    playSysSound(140, 'sawtooth', 0.12);
                    return;
                }
                if(xsDriveUI.mode === 'trash'){
                    showToast('XS DRIVE','Ação bloqueada','Restaure antes de editar.','folder');
                    playSysSound(140, 'sawtooth', 0.12);
                    return;
                }
                const editor = document.getElementById('xsDriveEditor');
                n.content = String(editor ? editor.value : '');
                n.mime = n.mime || 'text/plain';
                __xsDriveTouch(n);
                __xsDriveSave();

                try { stats.driveWrites = (stats.driveWrites||0)+1; saveStats(); } catch(e){}
                try { evaluateMilestones(); } catch(e){}

                showToast('XS DRIVE','Salvo', n.name, 'folder');
                playSysSound(1060,'square',0.07);
                __xsDriveRender();
            }catch(e){}
        }

        function xsDriveRename(){
            try{
                __xsDriveEnsure();
                const id = xsDriveUI.selected;
                const n = id ? __xsDriveNode(id) : null;
                if(!n){
                    showToast('XS DRIVE','Nada selecionado','Selecione um item.','folder');
                    playSysSound(140,'sawtooth',0.12);
                    return;
                }
                if(__xsDriveIsRoot(n.id) || (xsDriveFS.sys && Object.values(xsDriveFS.sys).includes(n.id))){
                    showToast('XS DRIVE','Bloqueado','Não renomeia pastas do sistema.','folder');
                    playSysSound(140,'sawtooth',0.12);
                    return;
                }
                __xsDrivePromptOpen({
                    title: 'Renomear',
                    desc: 'Novo nome:',
                    placeholder: n.type==='dir' ? 'Nova pasta' : 'arquivo.txt',
                    value: n.name || '',
                    multiline: false,
                    ok: (val)=>{
                        n.name = __xsDriveSafeName(val, n.name || 'Item');
                        __xsDriveTouch(n);
                        __xsDriveSave();
                        showToast('XS DRIVE','Renomeado', n.name, 'folder');
                        playSysSound(860,'sine',0.07);
                        __xsDriveRender();
                    }
                });
            }catch(e){}
        }

        function __xsDriveDeleteTree(id){
            const n = __xsDriveNode(id);
            if(!n) return;
            if(n.type === 'dir'){
                const kids = (n.children || []).slice();
                for(const k of kids) __xsDriveDeleteTree(k);
            }
            try{ delete xsDriveFS.nodes[id]; }catch(e){}
        }

        function xsDriveDelete(){
            try{
                __xsDriveEnsure();
                const id = xsDriveUI.selected;
                const n = id ? __xsDriveNode(id) : null;
                if(!n){
                    showToast('XS DRIVE','Nada selecionado','Selecione um item.','folder');
                    playSysSound(140,'sawtooth',0.12);
                    return;
                }
                if(__xsDriveIsRoot(n.id) || (xsDriveFS.sys && Object.values(xsDriveFS.sys).includes(n.id))){
                    showToast('XS DRIVE','Bloqueado','Não remove pastas do sistema.','folder');
                    playSysSound(140,'sawtooth',0.12);
                    return;
                }

                const inTrash = (xsDriveUI.mode === 'trash') || (n.parent === (xsDriveFS.sys && xsDriveFS.sys.trash));
                if(!inTrash){
                    // move pra lixeira
                    const trash = (xsDriveFS.sys && xsDriveFS.sys.trash) ? xsDriveFS.sys.trash : xsDriveFS.root;
                    const from = n.parent;
                    if(from) __xsDriveDetach(from, n.id);
                    __xsDriveAttach(trash, n.id);
                    xsDriveUI.selected = null;
                    __xsDriveSave();
                    showToast('XS DRIVE','Enviado pra lixeira', n.name, 'folder');
                    playSysSound(520,'triangle',0.08);
                    __xsDriveRender();
                }else{
                    // apagar definitivo
                    const from = n.parent;
                    if(from) __xsDriveDetach(from, n.id);
                    __xsDriveDeleteTree(n.id);
                    xsDriveUI.selected = null;
                    __xsDriveSave();
                    showToast('XS DRIVE','Apagado', 'Removido permanentemente', 'folder');
                    playSysSound(180,'sawtooth',0.12);
                    __xsDriveRender();
                }
            }catch(e){}
        }

        function xsDriveDownloadFile(){
            try{
                __xsDriveEnsure();
                const id = xsDriveUI.selected;
                const n = id ? __xsDriveNode(id) : null;
                if(!n || n.type !== 'file'){
                    showToast('XS DRIVE','Nada pra baixar','Selecione um arquivo.','folder');
                    playSysSound(140,'sawtooth',0.12);
                    return;
                }
                __xsDriveDownload(n.name || 'arquivo.txt', String(n.content||''), n.mime || 'text/plain');
                showToast('XS DRIVE','Download iniciado', n.name, 'folder');
                playSysSound(920,'square',0.06);
            }catch(e){}
        }

        function xsDriveUploadPick(){
            try{
                if(xsDriveUI.mode === 'trash'){
                    showToast('XS DRIVE','Ação bloqueada','Não faz upload dentro da lixeira.','folder');
                    playSysSound(140,'sawtooth',0.12);
                    return;
                }
                const up = document.getElementById('xsDriveUploadInput');
                if(up) up.click();
            }catch(e){}
        }

        function xsDriveExport(){
            try{
                __xsDriveEnsure();
                const stamp = new Date().toISOString().slice(0,19).replace('T','_').replace(/:/g,'-');
                const filename = `xs_drive_backup_${stamp}.json`;
                const payload = JSON.stringify(xsDriveFS, null, 2);
                __xsDriveDownload(filename, payload, 'application/json');

                try { stats.driveExports = (stats.driveExports||0)+1; saveStats(); } catch(e){}
                try { evaluateMilestones(); } catch(e){}

                showToast('XS DRIVE','Backup gerado', filename, 'folder');
                playSysSound(980,'sine',0.07);
            }catch(e){}
        }

        function xsDriveImportPick(){
            try{
                const imp = document.getElementById('xsDriveImportInput');
                if(imp) imp.click();
            }catch(e){}
        }

        // Exposição no padrão do projeto (evita conflito de escopo)
        window.openXsDrive = openXsDrive;
        window.xsDriveGoTo = xsDriveGoTo;
        window.xsDriveGoUp = xsDriveGoUp;
        window.xsDriveToggleTrash = xsDriveToggleTrash;
        window.xsDriveOpen = xsDriveOpen;
        window.xsDriveNewFolder = xsDriveNewFolder;
        window.xsDriveNewNote = xsDriveNewNote;
        window.xsDriveSaveFile = xsDriveSaveFile;
        window.xsDriveRename = xsDriveRename;
        window.xsDriveDelete = xsDriveDelete;
        window.xsDriveDownloadFile = xsDriveDownloadFile;
        window.xsDriveUploadPick = xsDriveUploadPick;
        window.xsDriveExport = xsDriveExport;
        window.xsDriveImportPick = xsDriveImportPick;
        window.xsDrivePromptClose = xsDrivePromptClose;
        window.xsDrivePromptCancel = xsDrivePromptCancel;
        window.xsDrivePromptOk = xsDrivePromptOk;

function openProfileEditor() { openModal('profile-modal'); document.getElementById('new-name').value = profiles[activeUser].name; tempAvatar = profiles[activeUser].avatar; document.getElementById('current-avatar-edit').src = `https://api.dicebear.com/7.x/avataaars/svg?seed=${tempAvatar}`; const grid = document.getElementById('avatar-grid'); grid.innerHTML = ""; avatarBases.forEach(base => { const img = document.createElement('img'); img.src = `https://api.dicebear.com/7.x/avataaars/svg?seed=${base}`; img.onclick = () => { tempAvatar = base + "_" + Math.floor(Math.random()*1000); document.getElementById('current-avatar-edit').src = `https://api.dicebear.com/7.x/avataaars/svg?seed=${tempAvatar}`; Array.from(grid.children).forEach(el => el.classList.remove('active')); img.classList.add('active'); }; grid.appendChild(img); });
                    const plus = document.createElement('div');
                    plus.className = 'avatar-plus';
                    plus.innerHTML = '<span class="material-icons">add</span>';
                    plus.title = 'Cloud: criar/vincular conta';
                    plus.onclick = () => { openCloudModal(); };
                    grid.appendChild(plus); }
        function saveProfile() { profiles[activeUser].name = document.getElementById('new-name').value || profiles[activeUser].name; profiles[activeUser].avatar = tempAvatar; localStorage.setItem('xs_profiles', JSON.stringify(profiles)); stats.avatarSaves++; saveStats(); checkAchievement('avatar_artist'); updateDashboardHeader(); closeModal('profile-modal'); document.getElementById(`av${activeUser}`).innerHTML = `<img src="https://api.dicebear.com/7.x/avataaars/svg?seed=${tempAvatar}" width="100%">`; document.getElementById(`name${activeUser}`).innerText = profiles[activeUser].name; }
        function updateDashboardHeader() { 
            const u = (profiles && profiles[activeUser]) ? profiles[activeUser] : { name: 'XUXUBI', avatar: 'xuxubi' };
            const seed = encodeURIComponent(u.avatar || 'xuxubi');
            const name = (u.name || 'XUXUBI').toUpperCase();
            const el = document.getElementById('user-display');
            if (!el) return;
            el.innerHTML = `<img src="https://api.dicebear.com/7.x/avataaars/svg?seed=${seed}" style="width:25px; height:25px; border-radius:5px; border:1px solid white;"> ${name}`;
        }

        function switchAvatarTab(tabId){
          if (!tabId) return;
          if (!currentAvTab) currentAvTab = 'face';
          if (tabId === currentAvTab) return;

          try { playSysSound(520, 'sine', 0.08); } catch(e) {}

          const modal = document.getElementById('profile-modal');
          if (!modal) { currentAvTab = tabId; return; }

          modal.querySelectorAll('.xsav-tab').forEach(btn=>{
            btn.classList.toggle('is-active', btn.dataset.tab === tabId);
          });
          modal.querySelectorAll('.xsav-panel').forEach(panel=>{
            panel.classList.toggle('is-active', panel.dataset.tab === tabId);
          });

          currentAvTab = tabId;
        }

        function changeTheme(themeName) { 
            const root = document.querySelector(':root'); 
            const themes = { 
                'midnight': 'radial-gradient(circle at top right, #2a004a, #0a001a)', 
                'emerald': 'radial-gradient(circle at top right, #004a2a, #001a0a)', 
                'ruby': 'radial-gradient(circle at top right, #4a0000, #1a0000)', 
                'gold': 'radial-gradient(circle at top right, #aa8800, #1a1a00)', 
                'cyber': 'linear-gradient(45deg, #004e92, #000428)', 
                'monolith': 'radial-gradient(circle at top right, #333, #000)', 
                'sunset': 'linear-gradient(to bottom, #870000, #190a05)',
                'matrix': 'linear-gradient(0deg, #000, #001a00)',
                'cotton': 'linear-gradient(to right, #fbc2eb, #a6c1ee)',
                'dracula': 'linear-gradient(to bottom, #282a36, #44475a)',
                'vaporwave': 'linear-gradient(135deg, #ff4fd8, #6b5bff, #00e5ff)', 
                'deepsea': 'radial-gradient(circle at top right, #003b5c, #000814)', 
                'marsrover': 'radial-gradient(circle at top right, #6b1e10, #120402)', 
                'forest': 'radial-gradient(circle at top right, #0a5b2b, #02150a)',
                'sakura': 'linear-gradient(135deg, #ffb7d5, #ffdfe9, #a6c1ee)',
                'cyberred': 'linear-gradient(135deg, #ff0033, #2b0006, #00e5ff)',
                'monogold': 'linear-gradient(135deg, #d6b45a, #3a2a05)',
                'arctic': 'radial-gradient(circle at top right, #c8f1ff, #001018)',
                'ultraviolet': 'radial-gradient(circle at top right, #7b2cff, #0b0016)',
                'desertstorm': 'radial-gradient(circle at top right, #caa46a, #1a1206)',
                'white': 'white'
            }; 
            root.style.setProperty('--bg-gradient', themes[themeName] || 'radial-gradient(circle at top right, #0044aa, #000a1a)');
            const accents = {
                'vaporwave': { glow:'#ff4fd8', blue:'#6b5bff' },
                'deepsea': { glow:'#00bcd4', blue:'#003b5c' },
                'marsrover': { glow:'#ff6b3d', blue:'#6b1e10' },
                'forest': { glow:'#38ff88', blue:'#0a5b2b' },
                'sakura': { glow:'#ff7eb6', blue:'#a6c1ee' },
                'cyberred': { glow:'#ff0033', blue:'#2b0006' },
                'monogold': { glow:'#ffd700', blue:'#3a2a05' },
                'arctic': { glow:'#7df0ff', blue:'#001018' },
                'ultraviolet': { glow:'#b15cff', blue:'#0b0016' },
                'desertstorm': { glow:'#ffcc80', blue:'#1a1206' },
                'gold': { glow:'#ffd700', blue:'#aa8800' },
                'matrix': { glow:'#38ff88', blue:'#001a00' },
                'cyber': { glow:'#00e5ff', blue:'#004e92' },
            };
            const a = accents[themeName] || { glow:'#00e5ff', blue:'#003791' };
            root.style.setProperty('--ps-glow', a.glow);
            root.style.setProperty('--ps-blue', a.blue);
if(themeName === 'white') {
                document.body.style.color = 'black';
                document.documentElement.style.setProperty('--glass', 'rgba(0,0,0,0.1)');
            } else {
                document.body.style.color = 'white';
                document.documentElement.style.setProperty('--glass', 'rgba(255,255,255,0.1)');
            }
        }
        
        function move(dir) { playSysSound(300, 'sine', 0.05); if(state === "LOGIN") { activeUser = (activeUser + dir + 2) % 2; document.getElementById('mu0').classList.toggle('selected', activeUser === 0); document.getElementById('mu1').classList.toggle('selected', activeUser === 1); } else if(state === "DASHBOARD") { gameIdx = (gameIdx + dir + GAMES.length) % GAMES.length; updateDash(); } }
        function startAudioEngine() { if(audioCtx.state === 'suspended') audioCtx.resume(); }
        window.addEventListener('keydown', (e) => { if(e.key === "ArrowRight") move(1); if(e.key === "ArrowLeft") move(-1); if(e.key === "Enter") actionEnter(); if(e.key === "Escape") { closeModal('profile-modal'); closeModal('settings-modal'); closeModal('tutorial-modal'); closeModal('sideload-folder-modal'); closeModal('achievements-modal'); closeModal('custom-app-modal'); closeModal('roulette-modal'); closeGame(); } });
    
// === INPUT MODE PROTECTION PATCH ===
function detectInputType() {
    const isTouch =
        "ontouchstart" in window ||
        navigator.maxTouchPoints > 0 ||
        navigator.msMaxTouchPoints > 0;

    const isGamepad = !!navigator.getGamepads;

    return {
        isTouch,
        isGamepad,
        isKeyboard: !isTouch
    };
}

function showInputWarning(mode) {
    const msg =
        mode === "keyboard"
            ? "Teclado não disponível neste dispositivo."
            : "Controle não detectado neste dispositivo.";

    const toast = document.getElementById("achievement-toast");

    document.getElementById("toast-icon").textContent = "warning";
    document.getElementById("toast-title").textContent = "ENTRADA INVÁLIDA";
    document.getElementById("toast-msg").textContent = msg;
    document.getElementById("toast-reward").style.display = "none";

    toast.classList.add("show");
    setTimeout(() => toast.classList.remove("show"), 3000);
}

function setInputMode(mode) {
    const input = detectInputType();

    if (input.isTouch && (mode === "keyboard" || mode === "gamepad")) {
        showInputWarning(mode);
        document.getElementById("sel-input").value = "touch";
        return;
    }

    systemSettings.inputMode = mode;
    localStorage.setItem("xs_settings", JSON.stringify(systemSettings));

    showAchievementToast(
        "input",
        "MODO DE CONTROLE",
        `Modo alterado para ${mode.toUpperCase()}`
    );
}

function validateSavedInputMode() {
    const input = detectInputType();

    if (input.isTouch && (systemSettings.inputMode === "keyboard" || systemSettings.inputMode === "gamepad")) {
        systemSettings.inputMode = "touch";
        localStorage.setItem("xs_settings", JSON.stringify(systemSettings));
    }
}
validateSavedInputMode();
// === END PATCH ===

</script>

<script>
/* =========================================================
   AVATAR MANUAL "POR PECAS" COM SETAS – CORES + MAIS ACESSÓRIOS + UI MAIS BONITA
   ✅ Trocar peças: cabelo, olhos, boca, acessórios, roupa, pele
   ✅ NOVO: cor do cabelo, cor da roupa, cor dos acessórios
   ✅ Preview atualiza na hora
   ✅ Responsivo: nada sai da tela (scroll interno)
   ✅ NÃO mexe no HTML base (injeta UI via JS)
   ========================================================= */

const AV_API = "https://api.dicebear.com/7.x/avataaars/svg";

const __AVATAR_DEFAULT__ = {
  top: "shortFlat",
  eyes: "default",
  mouth: "smile",
  accessories: "round",
  accessoriesOn: false,
  clothing: "hoodie",
  skinColor: "ffdbb4",
  hairColor: "2c1b18",
  clothingColor: "262e33",
  accessoriesColor: "262e33",
  frame: "frame_basic",
  fxMode: "none", // none | retro | mythic
  fxSeed: ""
};

let avatarConfig = { ...__AVATAR_DEFAULT__ };

const avatarOptions = {
  top: [
    "noHair",
    "shortFlat","shortRound","shortWaved","shortCurly",
    "theCaesar","theCaesarAndSidePart","shaggy","shaggyMullet",
    "frizzle","dreads01","dreads02","dreads","fro","froBand",
    "bigHair","bob","bun","curly","curvy","straight01","straight02",
    "straightAndStrand","longButNotTooLong","miaWallace",
    "shavedSides","sides",
    "hat","hijab","turban","winterHat1","winterHat02","winterHat03","winterHat04",
    "frida"
  ],
  eyes: [
    "default","happy","wink","winkWacky","surprised","side","squint",
    "closed","cry","eyeRoll","hearts","xDizzy"
  ],
  mouth: [
    "smile","twinkle","serious","sad","disbelief","eating",
    "grimace","screamOpen","tongue","default","concerned","vomit"
  ],
  accessories: [
    "round","prescription01","prescription02","sunglasses","wayfarers","eyepatch","kurt"
  ],
  clothing: [
    "hoodie","overall","shirtCrewNeck","shirtScoopNeck","shirtVNeck",
    "graphicShirt","collarAndSweater","blazerAndShirt","blazerAndSweater",
    "graphicShirt|skull","graphicShirt|pizza","graphicShirt|resist","graphicShirt|hola","graphicShirt|bear","graphicShirt|diamond","graphicShirt|bat","graphicShirt|cumbia","graphicShirt|deer"
  ],
  skinColor: [
    { label: "CLARA", value: "ffdbb4" },
    { label: "MÉDIA", value: "edb98a" },
    { label: "MORENA", value: "d08b5b" },
    { label: "ESCURA", value: "614335" },
    { label: "SOL", value: "f8d25c" },
    { label: "ALANJADA", value: "fd9841" },
    { label: "CASTANHA", value: "ae5d29" }
  ],
  hairColor: [
    { label: "PRETO", value: "2c1b18" },
    { label: "CINZA", value: "6d6e71" },
    { label: "CYAN", value: "00e5ff" },
    { label: "PINK", value: "ff3bd4" },
    { label: "LIME", value: "00ffb3" },
    { label: "CAST.", value: "4a2f27" },
    { label: "MARROM", value: "724133" },
    { label: "RUIVO", value: "b55239" },
    { label: "LOIRO", value: "d6b370" },
    { label: "BRANCO", value: "e8e1e1" },
    { label: "AZUL", value: "2f80ed" },
    { label: "ROXO", value: "8e44ad" }
  ],
  clothingColor: [
    { label: "PRETO", value: "262e33" },
    { label: "CYAN", value: "00e5ff" },
    { label: "PINK", value: "ff3bd4" },
    { label: "LIME", value: "00ffb3" },
    { label: "SUNSET", value: "ff4e50" },
    { label: "AZUL", value: "1f4fa3" },
    { label: "VERDE", value: "2e7d32" },
    { label: "VERM.", value: "b71c1c" },
    { label: "ROXO", value: "512da8" },
    { label: "ROSA", value: "d81b60" },
    { label: "AMAR.", value: "f9a825" },
    { label: "BRAN.", value: "f2f2f2" }
  ],
  accessoriesColor: [
    { label: "PRETO", value: "262e33" },
    { label: "CYAN", value: "00e5ff" },
    { label: "PINK", value: "ff3bd4" },
    { label: "LIME", value: "00ffb3" },
    { label: "PRATA", value: "b0b0b0" },
    { label: "DOUR.", value: "c8a951" },
    { label: "AZUL", value: "1565c0" },
    { label: "ROXO", value: "6a1b9a" },
    { label: "VERDE", value: "2e7d32" }
  ]
};

const labels = {
  top: "CABELO",
  hairColor: "COR CABELO",
  eyes: "OLHOS",
  mouth: "BOCA",
  accessories: "ACESSÓRIOS",
  accessoriesColor: "COR ACESS.",
  clothing: "ROUPA",
  clothingColor: "COR ROUPA",
  skinColor: "PELE",
  frame: "MOLDURA"

};

// --- MOLDURAS (algumas grátis, outras via Roleta XC) ---
const __FRAME_MASTER = [
  { id: 'frame_basic', label: 'BÁSICA', css: { border: '3px solid rgba(255,255,255,0.55)', shadow: '0 0 0 2px rgba(0,0,0,0.35) inset' }, free: true },
  { id: 'frame_steel', label: 'STEEL', css: { border: '3px solid rgba(176,176,176,0.95)', shadow: '0 0 18px rgba(176,176,176,0.15)' }, free: true },
  { id: 'frame_azure', label: 'AZURE', css: { border: '3px solid rgba(0,229,255,0.95)', shadow: '0 0 22px rgba(0,229,255,0.18)' }, free: false },
  { id: 'frame_arcade', label: 'ARCADE', css: { border: '3px solid rgba(200,120,255,0.95)', shadow: '0 0 24px rgba(200,120,255,0.18)' }, free: false },
  { id: 'frame_gold', label: 'OURO', css: { border: '3px solid rgba(255,215,0,0.98)', shadow: '0 0 26px rgba(255,215,0,0.18)' }, free: false },
  { id: 'frame_mythic', label: 'MÍTICA', css: { border: '3px solid rgba(255,59,212,0.98)', shadow: '0 0 30px rgba(255,59,212,0.22)' }, free: false }
];

function __getUnlockedFrameIds() {
  const inv = (typeof localStorage !== 'undefined') ? (function(){
    try { const a = JSON.parse(localStorage.getItem('xs_roulette_inv') || '[]'); return Array.isArray(a) ? a : []; } catch(e) { return []; }
  })() : [];

  const unlocked = new Set();
  // grátis
  __FRAME_MASTER.forEach(f => { if (f.free) unlocked.add(f.id); });

  // via roleta
  inv.forEach(id => {
    if (id === 'r_frame_azure') unlocked.add('frame_azure');
    if (id === 'e_frame_arcade') unlocked.add('frame_arcade');
    if (id === 'l_frame_gold') unlocked.add('frame_gold');
    if (id === 'm_frame_mythic') unlocked.add('frame_mythic');
  });
  return unlocked;
}

function __getFrameById(id) {
  return __FRAME_MASTER.find(f => f.id === id) || __FRAME_MASTER[0];
}

function __frameIdFromAvatarField(avatarField) {
  try {
    if (typeof avatarField === "string" && avatarField.trim().startsWith("{")) {
      const cfg = JSON.parse(avatarField);
      if (cfg && typeof cfg.frame === "string") return cfg.frame;
    }
  } catch(e) {}
  return "frame_basic";
}

function __applyFrameToImg(imgEl, avatarField) {
  if (!imgEl) return;
  try {
    const fr = __getFrameById(__frameIdFromAvatarField(avatarField));
    if (imgEl.classList) {
      if (fr.id === 'frame_mythic') imgEl.classList.add('xs-frame-mythic');
      else imgEl.classList.remove('xs-frame-mythic');
    }
    imgEl.style.border = fr.css.border;
    imgEl.style.boxShadow = fr.css.shadow;
  } catch(e) {}
}


function __applyFrameToPreview() {
  const preview = document.getElementById('current-avatar-edit');
  if (!preview) return;
  const fr = __getFrameById(avatarConfig.frame || 'frame_basic');
  if (preview.classList) {
    if (fr.id === 'frame_mythic') preview.classList.add('xs-frame-mythic');
    else preview.classList.remove('xs-frame-mythic');
  }
  preview.style.border = fr.css.border;
  preview.style.boxShadow = fr.css.shadow;
}

function __isHex6(v){ return /^[a-fA-F0-9]{6}$/.test(v); }

function __normalize(cfg) {
  const out = { ...__AVATAR_DEFAULT__ };
  if (!cfg || typeof cfg !== "object") return out;

  for (const k of Object.keys(out)) {
    if (k === "accessoriesOn") out.accessoriesOn = !!cfg.accessoriesOn;
    else if (typeof cfg[k] === "string" && cfg[k].trim()) out[k] = cfg[k].trim();
  }

  if (!avatarOptions.top.includes(out.top)) out.top = __AVATAR_DEFAULT__.top;
  if (!avatarOptions.eyes.includes(out.eyes)) out.eyes = __AVATAR_DEFAULT__.eyes;
  if (!avatarOptions.mouth.includes(out.mouth)) out.mouth = __AVATAR_DEFAULT__.mouth;
  if (!avatarOptions.accessories.includes(out.accessories)) out.accessories = __AVATAR_DEFAULT__.accessories;
  if (!avatarOptions.clothing.includes(out.clothing)) out.clothing = __AVATAR_DEFAULT__.clothing;

  if (!__isHex6(out.skinColor)) out.skinColor = __AVATAR_DEFAULT__.skinColor;
  if (!__isHex6(out.hairColor)) out.hairColor = __AVATAR_DEFAULT__.hairColor;
  if (!__isHex6(out.clothingColor)) out.clothingColor = __AVATAR_DEFAULT__.clothingColor;
  if (!__isHex6(out.accessoriesColor)) out.accessoriesColor = __AVATAR_DEFAULT__.accessoriesColor;

  
  try {
    const unlockedFrames = (typeof __getUnlockedFrameIds === 'function') ? __getUnlockedFrameIds() : ["frame_basic"];
    if (!unlockedFrames.includes(out.frame)) out.frame = unlockedFrames[0] || "frame_basic";
  } catch(e) { out.frame = out.frame || "frame_basic"; }
  return out;
}


function __hexFromHSL(h,s,l){
  // h:0..360, s/l:0..1
  h = ((h%360)+360)%360;
  const c = (1 - Math.abs(2*l - 1)) * s;
  const x = c * (1 - Math.abs((h/60)%2 - 1));
  const m = l - c/2;
  let r=0,g=0,b=0;
  if (h < 60) { r=c; g=x; b=0; }
  else if (h < 120) { r=x; g=c; b=0; }
  else if (h < 180) { r=0; g=c; b=x; }
  else if (h < 240) { r=0; g=x; b=c; }
  else if (h < 300) { r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  const R = Math.round((r+m)*255);
  const G = Math.round((g+m)*255);
  const B = Math.round((b+m)*255);
  const toHex = (v)=>v.toString(16).padStart(2,'0');
  return (toHex(R)+toHex(G)+toHex(B)).toLowerCase();
}

function __applyFx(c){
  // retorna um clone com cores "dinâmicas" sem alterar o original
  const out = { ...c };
  const mode = (out.fxMode || 'none');
  if (mode === 'retro') {
    const pal = ['00e5ff','ff3bd4','00ffb3','7c4dff','ffd54f'];
    const t = Math.floor(Date.now()/280);
    const seed = (out.fxSeed && out.fxSeed.length) ? out.fxSeed : (profiles && profiles[activeUser] ? String(activeUser) : '0');
    let acc = 0;
    for (let i=0;i<seed.length;i++) acc = (acc + seed.charCodeAt(i) * (i+3)) % 997;
    const idx = (t + acc) % pal.length;
    out.clothingColor = pal[idx];
    out.accessoriesColor = pal[(idx+2)%pal.length];
  } else if (mode === 'mythic') {
    const t = Date.now()/12;
    const h = (t % 360);
    out.clothingColor = __hexFromHSL(h, 1, 0.55);
    out.hairColor = __hexFromHSL((h+140)%360, 1, 0.52);
    out.accessoriesColor = __hexFromHSL((h+260)%360, 1, 0.58);
  }
  return out;
}

function __needsFx(cfg){
  return cfg && typeof cfg === 'object' && cfg.fxMode && cfg.fxMode !== 'none';
}

let __fxInterval = null;
function __ensureFxRefresh(){
  if (__fxInterval) return;
  __fxInterval = setInterval(()=>{
    try {
      // Preview editor
      const pv = document.getElementById('current-avatar-edit');
      if (pv && pv.offsetParent !== null) {
        pv.src = buildAvatarURL(avatarConfig);
        __applyFrameToPreview();
  try { __ensureFxRefresh(); } catch(e) {}
      }
      // Dashboard avatar (header)
      try { updateDashboardHeader(); } catch(e) {}
      // Login tiles
      try { __patchLoginAvatars(); } catch(e) {}
    } catch(e) {}
  }, 1000);
}
function buildAvatarURL(cfg) {
  const c = __normalize(cfg);
  const cx = __applyFx(c);

  const prob = c.accessoriesOn ? 100 : 0;

  let clothingType = c.clothing;
  let clothingGraphic = '';
  if (typeof clothingType === 'string' && clothingType.includes('|')) {
    const parts = clothingType.split('|');
    clothingType = parts[0] || clothingType;
    clothingGraphic = parts[1] || '';
  }

  const g1 = clothingGraphic ? `&clothingGraphic=${encodeURIComponent(clothingGraphic)}` : '';
  const g2 = clothingGraphic ? `&graphicType=${encodeURIComponent(clothingGraphic)}` : '';

  return (
    `${AV_API}?` +
    `top=${encodeURIComponent(cx.top)}` +
    `&eyes=${encodeURIComponent(cx.eyes)}` +
    `&mouth=${encodeURIComponent(cx.mouth)}` +
    `&clothing=${encodeURIComponent(clothingType)}` +
    g1 + g2 +
    `&accessories=${encodeURIComponent(cx.accessories)}` +
    `&accessoriesProbability=${prob}` +
    `&skinColor=${encodeURIComponent(cx.skinColor)}` +
    `&hairColor=${encodeURIComponent(cx.hairColor)}` +
    `&topColor=${encodeURIComponent(cx.hairColor)}` +
    `&clothingColor=${encodeURIComponent(cx.clothingColor)}` +
    `&clothesColor=${encodeURIComponent(cx.clothingColor)}` +
    `&accessoriesColor=${encodeURIComponent(cx.accessoriesColor)}` +
    `&backgroundColor=transparent` + (__needsFx(cx) ? `&ts=${Math.floor(Date.now()/360)}` : '')
  );
}

function __getProfileAvatarURL(avatarField) {
  if (typeof avatarField === "string" && avatarField.trim().startsWith("{")) {
    try { return buildAvatarURL(JSON.parse(avatarField)); } catch (e) {}
  }
  const seed = (avatarField && typeof avatarField === "string") ? avatarField : "xuxu";
  return `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(seed)}`;
}

function __setPreview() {
  const preview = document.getElementById("current-avatar-edit");
  if (!preview) return;
  preview.style.objectFit = "contain";
  preview.src = buildAvatarURL(avatarConfig);
  __applyFrameToPreview();
  try { __ensureFxRefresh(); } catch(e) {}
  preview.onerror = () => {
    const seed = (typeof profiles?.[activeUser]?.avatar === "string") ? profiles[activeUser].avatar : "xuxu";
    preview.src = `https://api.dicebear.com/7.x/avataaars/svg?seed=${encodeURIComponent(seed)}`;
  };
}

function __tapFeedback(){
  try { if (navigator.vibrate) navigator.vibrate(10); } catch(e){}
}

function __mkIconBtn(icon, small) {
  const b = document.createElement("button");
  b.type = "button";
  b.className = "game-btn";
  b.style.width = small ? "40px" : "44px";
  b.style.height = small ? "38px" : "40px";
  b.style.borderRadius = small ? "14px" : "16px";
  b.style.background = "linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06))";
  b.style.border = "1px solid rgba(255,255,255,0.20)";
  b.style.boxShadow = "0 6px 18px rgba(0,0,0,0.35)";
  b.style.color = "white";
  b.style.display = "flex";
  b.style.alignItems = "center";
  b.style.justifyContent = "center";
  b.style.cursor = "pointer";
  b.style.transition = "transform 0.08s";
  b.onmousedown = () => (b.style.transform = "scale(0.96)");
  b.onmouseup = () => (b.style.transform = "scale(1)");
  b.onmouseleave = () => (b.style.transform = "scale(1)");
  const s = document.createElement("span");
  s.className = "material-icons";
  s.style.fontSize = small ? "22px" : "24px";
  s.innerText = icon;
  b.appendChild(s);
  return b;
}

function __mkValuePill(part, small) {
  const val = document.createElement("div");
  val.id = `av-val-${part}`;
  val.style.fontSize = small ? "0.78rem" : "0.82rem";
  val.style.color = "#eaeaea";
  val.style.whiteSpace = "nowrap";
  val.style.overflow = "hidden";
  val.style.textOverflow = "ellipsis";
  val.style.padding = small ? "7px 8px" : "8px 10px";
  val.style.borderRadius = small ? "12px" : "14px";
  val.style.border = "1px solid rgba(255,255,255,0.12)";
  val.style.background = "rgba(0,0,0,0.28)";
  val.style.minWidth = "0";
  val.style.display = "flex";
  val.style.alignItems = "center";
  val.style.justifyContent = "space-between";
  val.style.gap = "10px";
  return val;
}

function __setVal(part) {
  const el = document.getElementById(`av-val-${part}`);
  if (!el) return;

  function setColor(label, hex) {
    el.innerHTML = "";
    const left = document.createElement("div");
    left.innerText = label;
    left.style.flex = "1";
    left.style.minWidth = "0";
    left.style.overflow = "hidden";
    left.style.textOverflow = "ellipsis";
    left.style.whiteSpace = "nowrap";

    const dot = document.createElement("div");
    dot.style.width = "16px";
    dot.style.height = "16px";
    dot.style.borderRadius = "50%";
    dot.style.border = "1px solid rgba(255,255,255,0.35)";
    dot.style.background = `#${hex}`;
    dot.style.boxShadow = "0 0 0 4px rgba(255,255,255,0.06) inset";

    el.appendChild(left);
    el.appendChild(dot);
  }

  if (part === "skinColor") {
    const found = avatarOptions.skinColor.find(x => x.value === avatarConfig.skinColor);
    setColor(found ? found.label : avatarConfig.skinColor, avatarConfig.skinColor);
    return;
  }
  if (part === "hairColor") {
    const found = avatarOptions.hairColor.find(x => x.value === avatarConfig.hairColor);
    setColor(found ? found.label : avatarConfig.hairColor, avatarConfig.hairColor);
    return;
  }
  if (part === "clothingColor") {
    const found = avatarOptions.clothingColor.find(x => x.value === avatarConfig.clothingColor);
    setColor(found ? found.label : avatarConfig.clothingColor, avatarConfig.clothingColor);
    return;
  }
  if (part === "accessoriesColor") {
    const found = avatarOptions.accessoriesColor.find(x => x.value === avatarConfig.accessoriesColor);
    setColor(found ? found.label : avatarConfig.accessoriesColor, avatarConfig.accessoriesColor);
    return;
  }

  if (part === "frame") {
    const fr = __getFrameById(avatarConfig.frame || 'frame_basic');
    el.innerHTML = fr.label;
    return;
  }

  if (part === "frame") {
    const unlocked = Array.from(__getUnlockedFrameIds());
    const list = __FRAME_MASTER.filter(f => unlocked.includes(f.id));
    const ids = list.map(f => f.id);
    let i = ids.indexOf(avatarConfig.frame || 'frame_basic');
    if (i < 0) i = 0;
    i = (i + dir + ids.length) % ids.length;
    avatarConfig.frame = ids[i];
    __setVal('frame');
    __applyFrameToPreview();
  try { __ensureFxRefresh(); } catch(e) {}
    return;
  }
  if (part === "accessories") {
    el.innerHTML = (avatarConfig.accessoriesOn ? avatarConfig.accessories : "SEM");
    return;
  }
  el.innerHTML = avatarConfig[part];
}

function __cycle(part, dir) {
  __tapFeedback();

  if (part === "frame") {
    const unlocked = (typeof __getUnlockedFrameIds === 'function') ? Array.from(__getUnlockedFrameIds()) : ['frame_basic'];
    const ids = (typeof __FRAME_MASTER !== 'undefined' ? __FRAME_MASTER : []).filter(f => unlocked.includes(f.id)).map(f => f.id);
    if (!ids.length) return;
    let i = ids.indexOf(avatarConfig.frame);
    if (i < 0) i = 0;
    i = (i + dir + ids.length) % ids.length;
    avatarConfig.frame = ids[i];
    __setVal('frame');
    __setPreview();
    return;
  }

  if (part === "skinColor" || part === "hairColor" || part === "clothingColor" || part === "accessoriesColor") {
    // Conquista: mudou cor
    if (part === "hairColor" || part === "clothingColor" || part === "accessoriesColor") { checkAchievement('stylist_color'); }
    const list = avatarOptions[part].map(x => x.value);
    let i = list.indexOf(avatarConfig[part]);
    if (i < 0) i = 0;
    i = (i + dir + list.length) % list.length;
    avatarConfig[part] = list[i];
    __setVal(part);
    __setPreview();
    return;
  }

  if (part === "accessories") {
    const list = avatarOptions.accessories;
    if (!avatarConfig.accessoriesOn) {
      avatarConfig.accessoriesOn = true;
      avatarConfig.accessories = list[0];
    } else {
      let i = list.indexOf(avatarConfig.accessories);
      if (i < 0) i = 0;
      i = (i + dir + list.length) % list.length;
      avatarConfig.accessories = list[i];
    }
    __setVal("accessories");
    __setPreview();
    const t = document.getElementById("av-toggle-accessories");
    if (t) t.innerText = avatarConfig.accessoriesOn ? "ATIVADO" : "DESLIGADO";
    return;
  }

  const list = avatarOptions[part];
  let i = list.indexOf(avatarConfig[part]);
  if (i < 0) i = 0;
  i = (i + dir + list.length) % list.length;
  avatarConfig[part] = list[i];
  __setVal(part);
  __setPreview();
}

function __renderCustomizerUI() {
  const grid = document.getElementById("avatar-grid");
  if (!grid) return;

  // Não deixar CSS/JS do customizer vazar para fora do modal
  const modal = document.getElementById("profile-modal");
  if (!modal) return;

  const small = window.innerWidth <= 420;
  if (!currentAvTab) currentAvTab = 'face';

  // Limpa área
  grid.replaceChildren();
  grid.style.display = "block";
  grid.style.maxHeight = small ? "52vh" : "58vh";
  grid.style.overflowY = "auto";
  grid.style.overflowX = "hidden";
  grid.style.paddingRight = "6px";

  // Tip
  const tip = document.createElement("div");
  tip.className = "xsav-tip";
  tip.innerText = "Troque as peças e veja na hora";
  grid.appendChild(tip);

  // Abas
  const tabs = [
    { id: "face",  label: "ROSTO"  },
    { id: "hair",  label: "CABELO" },
    { id: "style", label: "ESTILO" },
    { id: "extra", label: "EXTRA" }
  ];

  const tabsBar = document.createElement("div");
  tabsBar.className = "xsav-tabs";
  tabs.forEach(t=>{
    const b = document.createElement("button");
    b.type = "button";
    b.className = "xsav-tab" + (t.id === currentAvTab ? " is-active" : "");
    b.dataset.tab = t.id;
    b.innerText = t.label;
    b.onclick = () => { switchAvatarTab(t.id); };
    tabsBar.appendChild(b);
  });
  grid.appendChild(tabsBar);

  // Pane
  const pane = document.createElement("div");
  pane.className = "xsav-pane";
  grid.appendChild(pane);

  const partsByTab = {
    face:  ["skinColor","eyes","mouth"],
    hair:  ["top","hairColor"],
    style: ["clothing","clothingColor"],
    extra: ["frame","accessories","accessoriesColor"]
  };

  const autoSave = () => {
    try {
      profiles[activeUser].avatar = JSON.stringify(__normalize(avatarConfig));
      localStorage.setItem('xs_profiles', JSON.stringify(profiles));
    } catch(e) {}
  };

  const mkRow = (part) => {
    const row = document.createElement("div");
    row.className = "xsav-row";

    const lab = document.createElement("div");
    lab.className = "xsav-label";
    lab.innerText = (labels && labels[part]) ? labels[part] : part.toUpperCase();

    const left = document.createElement("button");
    left.type = "button";
    left.className = "game-btn xsav-arrow";
    left.innerHTML = '<span class="material-icons">chevron_left</span>';

    const val = document.createElement("div");
    val.id = `av-val-${part}`;
    val.className = "xsav-pill";

    const right = document.createElement("button");
    right.type = "button";
    right.className = "game-btn xsav-arrow";
    right.innerHTML = '<span class="material-icons">chevron_right</span>';

    left.onclick = () => {
      __tapFeedback();
      try { playSysSound(360, 'sine', 0.07); } catch(e) {}
      __cycle(part, -1);
      autoSave();
    };
    right.onclick = () => {
      __tapFeedback();
      try { playSysSound(360, 'sine', 0.07); } catch(e) {}
      __cycle(part, 1);
      autoSave();
    };

    row.appendChild(lab);
    row.appendChild(left);
    row.appendChild(val);
    row.appendChild(right);

    return row;
  };

  // Cria painéis
  Object.entries(partsByTab).forEach(([tabId, parts])=>{
    const panel = document.createElement("div");
    panel.className = "xsav-panel" + (tabId === currentAvTab ? " is-active" : "");
    panel.dataset.tab = tabId;

    parts.forEach(part=>{
      // Linha padrão
      panel.appendChild(mkRow(part));
      try { __setVal(part); } catch(e) {}

      // Toggle de acessórios (no EXTRA)
      if (part === "accessories") {
        const toggle = document.createElement("div");
        toggle.className = "xsav-toggle";

        const tlab = document.createElement("div");
        tlab.className = "xsav-label";
        tlab.innerText = "ATIVAR ACESSÓRIOS";

        const tbtn = document.createElement("button");
        tbtn.type = "button";
        tbtn.id = "av-toggle-accessories";
        tbtn.className = "game-btn xsav-toggle-btn";
        tbtn.innerText = avatarConfig.accessoriesOn ? "ATIVADO" : "DESLIGADO";

        tbtn.onclick = () => {
          __tapFeedback();
          try { playSysSound(360, 'sine', 0.07); } catch(e) {}
          avatarConfig.accessoriesOn = !avatarConfig.accessoriesOn;
          __setVal("accessories");
          __setPreview();
          tbtn.innerText = avatarConfig.accessoriesOn ? "ATIVADO" : "DESLIGADO";
          autoSave();
        };

        toggle.appendChild(tlab);
        toggle.appendChild(tbtn);
        panel.appendChild(toggle);
      }
    });

    pane.appendChild(panel);
  });

  // Footer (reset)
  const footer = document.createElement("div");
  footer.className = "xsav-footer";

  const reset = document.createElement("button");
  reset.type = "button";
  reset.className = "game-btn";
  reset.style.width = "100%";
  reset.style.height = "46px";
  reset.style.borderRadius = "18px";
  reset.style.background = "rgba(0,55,145,0.40)";
  reset.style.border = "1px solid rgba(255,255,255,0.22)";
  reset.style.color = "white";
  reset.style.fontWeight = "bold";
  reset.style.letterSpacing = "1px";
  reset.style.cursor = "pointer";
  reset.style.boxShadow = "0 12px 30px rgba(0,0,0,0.35) inset";
  reset.innerText = "RESETAR AVATAR";

  reset.onclick = () => {
    __tapFeedback();
    try { playSysSound(520, 'sine', 0.10); } catch(e) {}
    avatarConfig = { ...__AVATAR_DEFAULT__ };
    __applyFrameToPreview();
    try { __ensureFxRefresh(); } catch(e) {}
    __setPreview();
    // Atualiza valores visíveis
    ["skinColor","eyes","mouth","top","hairColor","clothing","clothingColor","frame","accessories","accessoriesColor"].forEach(p=>{
      try { __setVal(p); } catch(e) {}
    });
    const t = document.getElementById("av-toggle-accessories");
    if (t) t.innerText = avatarConfig.accessoriesOn ? "ATIVADO" : "DESLIGADO";
    autoSave();
  };

  footer.appendChild(reset);
  grid.appendChild(footer);
}

function __syncRouletteUnlocksToAvatarOptions() {
  try {
    const inv = JSON.parse(localStorage.getItem(__RKEY.inv) || '[]');
    const byId = {};
    (typeof __ROULETTE_ITEMS !== 'undefined' ? __ROULETTE_ITEMS : []).forEach(it => byId[it.id] = it);

    const addColor = (arr, hex) => {
      if (!hex || typeof hex !== 'string') return;
      const v = hex.replace('#','').toLowerCase();
      if (!__isHex6(v)) return;
      if (arr.some(o => (o.value||'').toLowerCase() === v)) return;
      arr.unshift({ label: ('XC-' + v.slice(0,3)).toUpperCase(), value: v });
    };

    inv.forEach(id => {
      const it = byId[id];
      if (!it || !it.unlock) return;
      if (it.unlock.hairColor) it.unlock.hairColor.forEach(h => addColor(avatarOptions.hairColor, h));
      if (it.unlock.clothingColor) it.unlock.clothingColor.forEach(h => addColor(avatarOptions.clothingColor, h));
      if (it.unlock.accessoriesColor) it.unlock.accessoriesColor.forEach(h => addColor(avatarOptions.accessoriesColor, h));
    });
  } catch(e) {}
}

function __equipRouletteItem(it) {
  if (!it) return;
  __syncRouletteUnlocksToAvatarOptions();

  if (it.kind === 'preset' && it.preset) {
    Object.keys(it.preset).forEach(k => { avatarConfig[k] = it.preset[k]; });
  }
  if (it.kind === 'palette' && it.unlock) {
    if (it.unlock.hairColor && it.unlock.hairColor[0]) avatarConfig.hairColor = (it.unlock.hairColor[0]+'').replace('#','');
    if (it.unlock.clothingColor && it.unlock.clothingColor[0]) avatarConfig.clothingColor = (it.unlock.clothingColor[0]+'').replace('#','');
    if (it.unlock.accessoriesColor && it.unlock.accessoriesColor[0]) avatarConfig.accessoriesColor = (it.unlock.accessoriesColor[0]+'').replace('#','');
  }
  if ((it.kind === 'frame' || it.unlock?.frame) && it.unlock && it.unlock.frame && it.unlock.frame[0]) {
    avatarConfig.frame = it.unlock.frame[0];
  }

  avatarConfig = __normalize(avatarConfig);
  __setPreview();
  __applyFrameToPreview();
  try { __ensureFxRefresh(); } catch(e) {}

  // atualiza labels/controles se o editor estiver aberto
  try {
    const pm = document.getElementById('profile-modal');
    if (pm && pm.style.display === 'flex') {
      const keys = ['top','hairColor','eyes','mouth','accessories','accessoriesColor','clothing','clothingColor','skinColor','frame'];
      keys.forEach(k => { try { if (typeof __setVal === 'function') __setVal(k); } catch(e) {} });
    }
  } catch(e) {}

  // Salva no perfil automaticamente
  try {
    profiles[activeUser].avatar = JSON.stringify(__normalize(avatarConfig));
    localStorage.setItem('xs_profiles', JSON.stringify(profiles));
    updateDashboardHeader();
    document.getElementById(`av${activeUser}`).innerHTML = `<img src="${__getProfileAvatarURL(profiles[activeUser].avatar)}" width="100%">`;
    document.getElementById(`name${activeUser}`).innerText = profiles[activeUser].name;
    __patchLoginAvatars();
  } catch(e) {}
}

/* --------- Hooks no seu sistema (sem mudar HTML) --------- */

function __patchLoginAvatars() {
  try {
    document.getElementById('name0').innerText = profiles[0].name;
    document.getElementById('av0').innerHTML = `<img src="${__getProfileAvatarURL(profiles[0].avatar)}" width="100%">`;
    try { __applyFrameToImg(document.querySelector('#av0 img'), profiles[0].avatar); } catch(e) {}
    document.getElementById('name1').innerText = profiles[1].name;
    document.getElementById('av1').innerHTML = `<img src="${__getProfileAvatarURL(profiles[1].avatar)}" width="100%">`;
    try { __applyFrameToImg(document.querySelector('#av1 img'), profiles[1].avatar); } catch(e) {}
  } catch (e) {}
}

const __oldOpenProfileEditor = openProfileEditor;
openProfileEditor = function () {
  // Mantém o fluxo original do modal (não mexe no boot)
  __oldOpenProfileEditor();

  // Carrega avatarConfig (JSON) ou padrão
  const raw = profiles[activeUser].avatar;
  if (typeof raw === "string" && raw.trim().startsWith("{")) {
    try { avatarConfig = __normalize(JSON.parse(raw)); }
    catch { avatarConfig = { ...__AVATAR_DEFAULT__ }; }
  } else {
    avatarConfig = { ...__AVATAR_DEFAULT__ };
  }

  // Variável usada por partes antigas do código (compat)
  try { window.tempAvatar = profiles[activeUser].avatar; } catch(e){}

  // Sincroniza unlocks da roleta (se existir)
  if (typeof __syncRouletteUnlocksToAvatarOptions === 'function') __syncRouletteUnlocksToAvatarOptions();

  // Aba inicial
  currentAvTab = 'face';

  // Preview e moldura
  __setPreview();
  __applyFrameToPreview();
  try { __ensureFxRefresh(); } catch(e) {}

  // UI nova (abas + controles)
  __renderCustomizerUI();
};

saveProfile = function () {
  // Commit final (nome + avatarConfig) no perfil
  profiles[activeUser].name = document.getElementById('new-name').value || profiles[activeUser].name;
  profiles[activeUser].avatar = JSON.stringify(__normalize(avatarConfig));
  try { window.tempAvatar = profiles[activeUser].avatar; } catch(e){}

  localStorage.setItem('xs_profiles', JSON.stringify(profiles));

  // Stats / conquistas (mantém compatibilidade se existir)
  try {
    stats.avatarSaves = (stats.avatarSaves || 0) + 1;
    saveStats();
    checkAchievement('avatar_artist');
  } catch(e) {}

  updateDashboardHeader();
  closeModal('profile-modal');

  // Atualiza cards / login
  try {
    document.getElementById(`av${activeUser}`).innerHTML = `<img src="${__getProfileAvatarURL(profiles[activeUser].avatar)}" width="100%">`;
    document.getElementById(`name${activeUser}`).innerText = profiles[activeUser].name;
  } catch(e) {}

  try { __patchLoginAvatars && __patchLoginAvatars(); } catch(e) {}
};

updateDashboardHeader = function () {
  const ud = document.getElementById('user-display');
  if (!ud) return;
  ud.innerHTML =
    `<img src="${__getProfileAvatarURL(profiles[activeUser].avatar)}" style="width:25px; height:25px; border-radius:5px;"> ${profiles[activeUser].name.toUpperCase()}`;
  try { __applyFrameToImg(ud.querySelector('img'), profiles[activeUser].avatar); } catch(e) {}
};

(function(){
  const __oldOnload = window.onload;
  window.onload = function() {
    if (typeof __oldOnload === "function") __oldOnload();
    __patchLoginAvatars();
  };
})();

        /* =========================================================
           MINIGAME NATIVO: BIXIN EXPLORADOR (XC)
           - 1 botão (pular): toque/clique/espaço/(A)
           - Dificuldade progressiva (velocidade + spawn)
           - Recompensa XC só no final (com limite por janela)
           ========================================================= */
        
    
    const __DINO_RUN__ = (() => {
        // ===== Bixin Explorador: Neon Cart + Tiro (v5.11) =====
        // - Carrinho com avatar (fallback slime)
        // - Barras vermelhas quebráveis (colidir = quebra + lentidao)
        // - Barras cinzas solidas (colidir = game over)
        // - Inimigos voadores: aperte TIRO antes de chegar, senao MORRE
        // - Touch UI (PULAR/TIRO) aparece apenas em modo toque
        // - Esconde os controles mobile do console durante o jogo (evita "texto bugado")
        // - Recompensa XC apenas no final: cap 50 / 15 min (janela), salva em xs_coins + saveEconomy()

        const CAP_PER_WINDOW = 120;
        const WINDOW_MS = 15 * 60 * 1000;
        const LS_WIN_START = "xs_dino_window_start";
        const LS_WIN_AMT   = "xs_dino_window_amount";

        const LS_PENDING   = "xs_dino_pending_xc";

        const LS_TUT_SEEN = "xs_bixin_tutorial_seen_v1";

        const state = {
            running: false,
            phase: "idle", // idle | playing | over
            raf: 0,
            lastT: 0,
            startT: 0,

            canvas: null,
            ctx: null,
            w: 0,
            h: 0,
            dpr: 1,

            groundY: 0,
            distPx: 0,
            coinsPicked: 0,
            
            coinMult: 1,        // multiplicador de moedas (resetável)
            nextMultAt: 100,     // próxima meta de distância (m) para aumentar mult
            jumpPressT: 0,       // timestamp do último input de pulo (para Red Dash)
            dashBoostT: 0,       // tempo restante do boost (Red Dash)
            dashBoostFactor: 1.22,
kills: 0,

            // feel
            speed: 0,
            speedBase: 360,
            speedGrow: 12,
            speedMax: 1050,
            gravity: 2100,
            jumpV: 820,
            slowTimer: 0,
            slowFactor: 0.72,

            // shooting
            shootCd: 0,
            shotFx: 0,
            jumpFx: 0,          // feedback de pulo

            landFx: 0,          // impacto ao aterrissar
            redBumps: 0,         // conta batidas em blocos vermelhos
            // timer curto pra desenhar laser
            lastShotX: 0,
            lastShotY: 0,
            lastShotTX: 0,
            lastShotTY: 0,

            player: { x: 0, y: 0, w: 56, h: 56, vy: 0, onGround: true },
            obstacles: [],
            coins: [],
            enemies: [],
            particles: [],
            stripes: [],

            accent: "#00e5ff",
            bgA: "#001028",
            bgB: "#000000",
            shake: 0,
            img: new Image(),
            imgOk: false,

            gpLatchA: false,
            gpLatchB: false,
            listenersBound: false,

            // hook do console
            hooked: false,
            origActionEnter: null,

            // Touch UI & console mobile controls
            lastInput: "touch",
            mcPrevDisplay: null,
            setTouchUI: null
        };

        function _now(){ return performance.now(); }
        function _rand(a,b){ return a + Math.random()*(b-a); }
        function _distM(){ return Math.max(0, Math.floor(state.distPx / 18)); }
        function _coinMult(){ return Math.max(1, (state.coinMult|0) || 1); }



        // ===== Música (chiptune) — 3 faixas, aleatória a cada gameplay =====
        const _MUSIC_TRACKS = [
            // 1) "Truth-ish" (melancólica, lenta)
            { bpm: 84, seq: (function(){
                const L = [74,72,71,69, 71,69,67,66, 67,69,71,72, 71,69,67,66,
                           62,64,66,67, 66,64,62,60, 62,64,66,69, 67,66,64,62];
                const B = [50,50,48,48, 47,47,45,45, 43,43,45,45, 47,47,48,48,
                           43,43,45,45, 47,47,48,48, 50,50,52,52, 50,50,48,48];
                return L.map((m,i)=>({ l:m, b:B[i], k:(i%8==0), h:(i%4==2) }));
            })() },

            // 2) "Perces-ish" (caverna/eco, médio)
            { bpm: 96, seq: (function(){
                const L = [69,69,71,72, 74,72,71,69, 67,67,69,71, 72,71,69,67,
                           66,66,67,69, 71,69,67,66, 64,64,66,67, 69,67,66,64];
                const B = [45,45,45,45, 43,43,43,43, 40,40,40,40, 43,43,43,43,
                           38,38,38,38, 40,40,40,40, 43,43,43,43, 45,45,45,45];
                return L.map((m,i)=>({ l:(i%2?m:null), b:B[i], k:(i%8==0), h:(i%2==1) }));
            })() },

            // 3) "Ice Cave-ish" (fria/lofi, mais lenta)
            { bpm: 78, seq: (function(){
                const L = [62,64,66,67, 69,67,66,64, 62,60,62,64, 66,64,62,60,
                           57,59,60,62, 64,62,60,59, 57,55,57,59, 60,59,57,55];
                const B = [38,38,40,40, 41,41,43,43, 38,38,40,40, 41,41,43,43,
                           36,36,38,38, 40,40,41,41, 43,43,41,41, 40,40,38,38];
                return L.map((m,i)=>({ l:m, b:(i%2?B[i]:B[i]-12), k:(i%16==0), h:(i%4==3) }));
            })() },
        ];

        const _music = { ctx:null, master:null, timer:null, playing:false, step:0, t:0, noiseBuf:null };

        function _musicEnsure(){
            if (_music.ctx) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return;
            try {
                _music.ctx = new AC();
            } catch(e){
                _music.ctx = null;
                return;
            }
            _music.master = _music.ctx.createGain();
            _music.master.gain.value = 0.14; // volume baixo (neon melancólico)
            _music.master.connect(_music.ctx.destination);
        }

        function _musicUnlock(){
            _musicEnsure();
            if (!_music.ctx) return;
            if (_music.ctx.state === "suspended") _music.ctx.resume().catch(()=>{});
        }

        function _musicStop(){
            if (_music.timer) { try { clearInterval(_music.timer); } catch(e){} _music.timer = null; }
            _music.playing = false;
            _music.step = 0;
        }

        function _m2f(m){ return 440 * Math.pow(2, (m - 69) / 12); }

        function _noiseBuffer(){
            if (_music.noiseBuf) return _music.noiseBuf;
            const ctx = _music.ctx;
            const dur = 1.0;
            const buf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * dur), ctx.sampleRate);
            const d = buf.getChannelData(0);
            for (let i=0; i<d.length; i++) d[i] = (Math.random()*2-1);
            _music.noiseBuf = buf;
            return buf;
        }

        function _schedTone(t, midi, dur, type, vol){
            if (!_music.ctx) return;
            if (midi === null || midi === undefined) return;
            const ctx = _music.ctx;
            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(_m2f(midi), t);

            g.gain.setValueAtTime(0.0001, t);
            g.gain.exponentialRampToValueAtTime(Math.max(0.0001, vol), t + 0.012);
            g.gain.exponentialRampToValueAtTime(0.0001, t + Math.max(0.02, dur));

            osc.connect(g);
            g.connect(_music.master);

            osc.start(t);
            osc.stop(t + dur + 0.03);
        }

        function _schedNoise(t, dur, vol, hpHz){
            if (!_music.ctx) return;
            const ctx = _music.ctx;
            const src = ctx.createBufferSource();
            src.buffer = _noiseBuffer();

            let node = src;
            if (hpHz){
                const hp = ctx.createBiquadFilter();
                hp.type = "highpass";
                hp.frequency.setValueAtTime(hpHz, t);
                node.connect(hp);
                node = hp;
            }

            const g = ctx.createGain();
            g.gain.setValueAtTime(Math.max(0.0001, vol), t);
            g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

            node.connect(g);
            g.connect(_music.master);

            src.start(t);
            src.stop(t + dur + 0.02);
        }

        function _musicStartRandom(){
            _musicUnlock();
            _musicStop();
            if (!_music.ctx) return;

            const pick = Math.floor(Math.random() * _MUSIC_TRACKS.length);
            state.musicPick = pick;

            const tr = _MUSIC_TRACKS[pick];
            const stepDur = 60 / tr.bpm / 2; // colcheia

            _music.playing = true;
            _music.step = 0;
            _music.t = _music.ctx.currentTime + 0.06;

            _music.timer = setInterval(() => {
                if (!_music.playing || !state.running || !_music.ctx) return;
                const now = _music.ctx.currentTime;
                while (_music.t < now + 0.25) {
                    const s = tr.seq[_music.step % tr.seq.length] || {};
                    // lead (square) + bass (triangle) + hihat/kick (noise)
                    _schedTone(_music.t, s.l, stepDur*0.98, "square", 0.06);
                    _schedTone(_music.t, s.b, stepDur*0.98, "triangle", 0.05);
                    if (s.h) _schedNoise(_music.t, stepDur*0.22, 0.020, 6500);
                    if (s.k) _schedNoise(_music.t, stepDur*0.18, 0.028, 120);

                    _music.t += stepDur;
                    _music.step++;
                }
            }, 45);
        }


        function _setCanvasSize(){
            const c = state.canvas;
            const rect = c.getBoundingClientRect();
            state.dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            state.w = Math.max(1, Math.floor(rect.width));
            state.h = Math.max(1, Math.floor(rect.height));
            c.width  = Math.floor(state.w * state.dpr);
            c.height = Math.floor(state.h * state.dpr);
            state.ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
            state.ctx.imageSmoothingEnabled = false;

            state.groundY = state.h - Math.max(58, Math.floor(state.h * 0.17));
            const base = Math.min(state.h, state.w);
            const sz = Math.max(52, Math.floor(base * 0.11));
            state.player.w = sz;
            state.player.h = sz;
            state.player.x = Math.max(56, Math.floor(state.w * 0.085));
            state.player.y = state.groundY - state.player.h;

            state.stripes = [];
            const stripeH = Math.max(6, Math.floor(state.h * 0.018));
            const stripeGap = Math.max(18, Math.floor(state.h * 0.055));
            const laneY = state.groundY + Math.max(10, Math.floor(state.h * 0.05));
            for(let x=0; x<state.w+200; x+=stripeGap){
                state.stripes.push({x, y: laneY, w: Math.max(20, Math.floor(state.w*0.08)), h: stripeH});
            }
        }

        function _loadCharacter(){
            state.imgOk = false;
            const slimePng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAeUlEQVR4nO3SvQrCQBBA0dfGxCnoB1icgg1JDlXGgWeAHxBBb05kK8SYRAN75yYoLjtDlvrfOs+SEExHplU8XJH558SrFlxph8Y5iBpO+Ci8wBepVWAlKMkKUA0FgBOP/MNI4SpUFL0p9TwCTgBcUXlty//HZiAiWRQXwhLSN2/HAtXyi500c2twS8AAAAASUVORK5CYII=";

            try {
                if (typeof __getProfileAvatarURL === "function" && typeof profiles !== "undefined") {
                    const avatarField = profiles?.[activeUser]?.avatar;
                    const url = __getProfileAvatarURL(avatarField);
                    state.img.crossOrigin = "anonymous";
                    state.img.src = url;
                } else {
                    state.img.src = slimePng;
                }
            } catch(e) {
                state.img.src = slimePng;
            }

            state.img.onload = () => { state.imgOk = true; };
            state.img.onerror = () => { state.imgOk = false; state.img.src = slimePng; };
        }

        function _reset(){
            state.didGameOver = false;
            state.distPx = 0;
            state.coinsPicked = 0;
            state.coinMult = 1;
            state.nextMultAt = 100;
            state.redBumps = 0;
            state.dashBoostT = 0;
            state.jumpPressT = 0;
            state.kills = 0;
            state.obstacles.length = 0;
            state.coins.length = 0;
            state.enemies.length = 0;
            state.particles.length = 0;

            state.speed = state.speedBase;
            state.slowTimer = 0;
            state.shake = 0;

            state.shootCd = 0;
            state.shotFx = 0;

            state.player.vy = 0;
            state.player.onGround = true;
            state.player.y = state.groundY - state.player.h;

            state._obsT = 0;
            state._coinT = 0;
            state._enemyT = 0;
            state._nextObs = _rand(0.75, 1.25);
            state._nextCoin = _rand(1.0, 2.4);
            state._nextEnemy = _rand(2.2, 3.4);

            const over = document.getElementById("dino-game-over");
            if (over) over.style.display = "none";
            const cap = document.getElementById("dino-cap-note");
            if (cap) cap.textContent = "";
        }

        function _phaseColors(elapsed){
            if (elapsed >= 60) {
                state.accent = "#ff0055";
                state.bgA = "#050008";
                state.bgB = "#000000";
            } else if (elapsed >= 30) {
                state.accent = "#a000ff";
                state.bgA = "#050012";
                state.bgB = "#000000";
            } else {
                state.accent = "#00e5ff";
                state.bgA = "#001028";
                state.bgB = "#000000";
            }
        }

        function _spawnObstacle(){
            const hMin = Math.max(18, Math.floor(state.h * 0.07));
            const hMax = Math.max(34, Math.floor(state.h * 0.15));
            const oH = Math.floor(_rand(hMin, hMax));
            const oW = Math.max(36, Math.floor(state.w * _rand(0.045, 0.075)));
            const type = (Math.random() < 0.33) ? "solid" : "breakable";
            state.obstacles.push({
                x: state.w + oW + 30,
                y: state.groundY - oH,
                w: oW,
                h: oH,
                type,
                hp: (type === "breakable") ? 2 : 999
            });
        }

        function _spawnCoin(){
            const r = Math.max(9, Math.floor(Math.min(state.w, state.h) * 0.014));
            const yBase = state.groundY - state.player.h - r - Math.max(12, Math.floor(state.h * 0.04));
            const y = Math.floor(yBase - _rand(0, Math.max(18, state.player.h * 0.85)));
            state.coins.push({ x: state.w + 20, y, r });
        }

        function _spawnEnemy(){
            const s = Math.max(28, Math.floor(Math.min(state.w, state.h) * 0.055));
            const yTop = Math.max(14, Math.floor(state.h * 0.18));
            const yBot = state.groundY - state.player.h - Math.max(28, Math.floor(state.h * 0.12));

            const groundSpawn = (Math.random() < 0.50);
            if (groundSpawn) {
                // inimigo terrestre (espinhos) no chão
                state.enemies.push({
                    x: state.w + s + 40,
                    y: state.groundY - s,
                    w: s,
                    h: s,
                    ground: true,
                    spMul: 1.2,
                    color: "#ff5500"
                });
                return;
            }

            // inimigo voador
            const y = Math.floor(_rand(yTop, Math.max(yTop+10, yBot)));
            state.enemies.push({
                x: state.w + s + 40,
                y,
                w: s,
                h: s,
                wob: _rand(0, Math.PI*2),
                ground: false
            });
        }

        function _spawnParticles(cx, cy, color, n=10){
            for (let i=0; i<n; i++){
                const ang = Math.random() * Math.PI * 2;
                const spd = _rand(170, 520);
                state.particles.push({
                    x: cx, y: cy,
                    vx: Math.cos(ang) * spd,
                    vy: Math.sin(ang) * spd - 180,
                    life: _rand(0.35, 0.7),
                    size: Math.max(2, Math.floor(Math.min(state.w, state.h) * 0.008)),
                    color
                });
            }
        }

        function _aabb(ax,ay,aw,ah,bx,by,bw,bh){
            return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
        }

        function _circleRect(cx,cy,cr,rx,ry,rw,rh){
            const nx = Math.max(rx, Math.min(cx, rx+rw));
            const ny = Math.max(ry, Math.min(cy, ry+rh));
            const dx = cx-nx, dy = cy-ny;
            return (dx*dx + dy*dy) <= cr*cr;
        }

        function _jumpOrRestart(){
            if (!state.running) return;

            // registra qualquer tentativa de pulo (mesmo no ar) para Red Dash
            try { state.jumpPressT = _now(); } catch(e){}
            // se tutorial estiver aberto, começar ao apertar pular
            if (state.phase === "tutorial") {
                try {
                    const tut = document.getElementById("dino-tutorial");
                    if (tut) tut.style.display = "none";
                } catch(e){}
                state.startT = _now();
                state.lastT = 0;
                state.phase = "playing";
                try { _musicStartRandom(); } catch(e){}
                return;
            }

            // reinicio se estiver em game over
            if (state.phase === "over") {
                _reset();
                state.phase = "playing";
                state.startT = _now();
                return;
            }
            if (state.phase !== "playing") return;

            // REWRITE: ground-check robusto (resolve casos em que onGround fica 'falso' por precisão / dt)
            const groundTop = state.groundY - state.player.h;
            const nearGround = (state.player.y >= groundTop - 1.5) && (state.player.vy >= -40);

            if (state.player.onGround || nearGround) {
                // garante que está exatamente no chão antes de pular
                if (state.player.y > groundTop) state.player.y = groundTop;
                state.player.vy = -state.jumpV;
                state.player.onGround = false;
                state.jumpFx = 0.14; // feedback rápido (desenhado em _draw)
                try { playSysSound(520, "square", 0.08); } catch(e){}
            }
        }
        try{ window.__DINO_LOCAL_JUMP__ = _jumpOrRestart; }catch(e){}


        function _shoot(){
            if (!state.running) return;
            if (state.phase !== "playing") return;
            if (state.shootCd > 0) return;

            state.shootCd = 0.22;
            state.shotFx = 0.08;

            const gunX = state.player.x + state.player.w - 2;
            const baseY = state.player.y + state.player.h;
            const gunY = baseY - Math.max(20, Math.floor(state.player.h*0.55));

            // acha inimigo mais proximo dentro do alcance
            const range = Math.max(220, Math.floor(state.w * 0.55));
            let bestI = -1;
            let bestX = 1e9;
            for (let i=0; i<state.enemies.length; i++){
                const e = state.enemies[i];
                if (e.x < state.player.x + state.player.w) continue;
                const dx = e.x - gunX;
                if (dx <= range && e.x < bestX) { bestX = e.x; bestI = i; }
            }

            if (bestI >= 0) {
                const e = state.enemies[bestI];
                state.lastShotX = gunX;
                state.lastShotY = gunY;
                state.lastShotTX = e.x + e.w/2;
                state.lastShotTY = e.y + e.h/2;

                state.enemies.splice(bestI, 1);
                state.kills += 1;
                state.coinsPicked += _coinMult(); // ganha moedas por kill (multiplica a cada 100m)
                try { playSysSound(980, "sine", 0.05); } catch(e){}
                _spawnParticles(e.x + e.w/2, e.y + e.h/2, "#ffd700", 14);
                try { playSysSound(820, "sawtooth", 0.06); } catch(e){}
            } else {
                // se não tiver inimigo, tenta destruir bloco vermelho (breakable) com 2 tiros
                let bestOi = -1;
                let bestOx = 1e9;
                for (let i=0; i<state.obstacles.length; i++){
                    const o = state.obstacles[i];
                    if (o.type !== "breakable") continue;
                    if (o.x + o.w < gunX) continue; // já passou
                    const dx = o.x - gunX;
                    if (dx <= range && o.x < bestOx) { bestOx = o.x; bestOi = i; }
                }

                if (bestOi >= 0) {
                    const o = state.obstacles[bestOi];
                    if (o.hp == null) o.hp = 2;
                    o.hp -= 1;

                    state.lastShotX = gunX;
                    state.lastShotY = gunY;
                    state.lastShotTX = o.x + o.w/2;
                    state.lastShotTY = o.y + o.h/2;

                    _spawnParticles(o.x + o.w/2, o.y + o.h/2, "#ff2b5e", 10);
                    try { playSysSound(720, "square", 0.05); } catch(e){}

                    if (o.hp <= 0) {
                        state.obstacles.splice(bestOi, 1);
                        state.shake = Math.max(state.shake, 0.12);
                        _spawnParticles(o.x + o.w/2, o.y + o.h/2, "#ff2b5e", 18);
                        try { playSysSound(640, "sawtooth", 0.05); } catch(e){}
                    }
                } else {
                    // tiro no vazio
                    state.lastShotX = gunX;
                    state.lastShotY = gunY;
                    state.lastShotTX = gunX + range;
                    state.lastShotTY = gunY - 10;
                    try { playSysSound(520, "sine", 0.04); } catch(e){}
                }
            }
        }

        function _setTouchUI(on){
            const el = document.getElementById("dino-touch-ui");
            if (!el) return;
            el.style.display = on ? "block" : "none";
        }
        function _tutorialBindOnce(){
            if (state._tutBound) return;
            state._tutBound = true;
            const tut = document.getElementById("dino-tutorial");
            if (!tut) return;

            const btnSkip = document.getElementById("dino-tut-skip");
            const btnStart = document.getElementById("dino-tut-start");

            function hide(markSeen){
                try { if (markSeen) localStorage.setItem(LS_TUT_SEEN, "1"); } catch(e){}
                tut.style.display = "none";
                // não conta tempo do tutorial
                state.startT = _now();
                state.lastT = 0;
                state.phase = "playing";
                // música começa aqui para garantir gesto do usuário
                try { _musicStartRandom(); } catch(e){}
            }

            if (btnSkip) btnSkip.addEventListener("pointerdown", (e)=>{ try{e.preventDefault();e.stopPropagation();}catch(_){} hide(true); }, {passive:false});
            if (btnStart) btnStart.addEventListener("pointerdown", (e)=>{ try{e.preventDefault();e.stopPropagation();}catch(_){} hide(false); }, {passive:false});

            // clique fora também começa
            tut.addEventListener("pointerdown", (e)=>{
                // se tocar no fundo, inicia sem marcar como visto
                const t = e.target;
                if (t && (t.id === "dino-tutorial")) {
                    try{e.preventDefault();e.stopPropagation();}catch(_){}
                    hide(false);
                }
            }, {passive:false});
        }

        function _tutorialShowIfNeeded(){
            const tut = document.getElementById("dino-tutorial");
            if (!tut) return false;
            let seen = false;
            try { seen = (localStorage.getItem(LS_TUT_SEEN) === "1"); } catch(e){}
            if (seen) return false;

            _tutorialBindOnce();
            tut.style.display = "block";
            state.phase = "tutorial";
            return true;
        }


        function _bindInputsOnce(){
            if (state.listenersBound) return;
            state.listenersBound = true;

            state.setTouchUI = _setTouchUI;

            const isTouchCapable = ("ontouchstart" in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
            if (isTouchCapable) {
                state.lastInput = "touch";
                _setTouchUI(true);
            } else {
                _setTouchUI(false);
            
            // destrava áudio / música no primeiro gesto (mobile exige gesto do usuário)
            if (!state.__musicGesture) {
                state.__musicGesture = true;
                const unlock = (ev) => {
                    try { _musicUnlock(); } catch(e){}
                    // se ainda não estiver tocando, inicia agora
                    try {
                        if (state.running && !_music.playing) _musicStartRandom();
                    } catch(e){}
                    try {
                        window.removeEventListener("pointerdown", unlock, true);
                        window.removeEventListener("touchstart", unlock, true);
                        window.removeEventListener("keydown", unlock, true);
                    } catch(e){}
                };
                try {
                    window.addEventListener("pointerdown", unlock, { capture:true, passive:true });
                    window.addEventListener("touchstart", unlock, { capture:true, passive:true });
                    window.addEventListener("keydown", unlock, { capture:true, passive:true });
                } catch(e){}
            }

        }

            // teclado (bind 1x / remove no stop)
            if (!state.__keysBound) {
                state.__keysBound = true;
                state.__onKeyDown = (e) => {
                if (!state.running) return;
                state.lastInput = "kbd";
                _setTouchUI(false);

                if (e.code === "Space" || e.code === "ArrowUp" || e.code === "Enter") {
                    e.preventDefault();
                    _jumpOrRestart();
                } else if (e.code === "KeyX" || e.code === "KeyF" || e.code === "ControlRight" || e.code === "ControlLeft") {
                    e.preventDefault();
                    _shoot();
                }
            };
                window.addEventListener("keydown", state.__onKeyDown, { passive: false });
            }

            const canvas = document.getElementById("dino-canvas");
            const overlay = document.getElementById("dino-game-over");

            const onTap = (e) => {
                if (!state.running) return;
                if (e.pointerType === "touch") {
                    state.lastInput = "touch";
                    _setTouchUI(true);
                }
                e.preventDefault();
                _jumpOrRestart();
            };

            // toque no canvas/overlay = pulo (bind 1x / remove no stop)
            if (!state.__tapBound) {
                state.__tapBound = true;
                state.__onTap = onTap;
                canvas.addEventListener("pointerdown", state.__onTap, { passive: false });
                overlay.addEventListener("pointerdown", state.__onTap, { passive: false });
            }

            // botoes touch (PULAR/TIRO) - multiplos eventos para funcionar em qualquer android/webview
            const btnJump = document.getElementById("dino-btn-jump");
            const btnFire = document.getElementById("dino-btn-fire");

            function bindTouch(btn, fn){
                if (!btn) return;
                // evita empilhar listeners em restarts (anti-leak)
                if (btn.__xsDinoBound) return;
                btn.__xsDinoBound = true;
                const h = (ev) => { if (!state.running) return; state.lastInput = "touch"; _setTouchUI(true); ev.preventDefault(); ev.stopPropagation(); fn(); };
                btn.addEventListener("pointerdown", h, { passive: false });
                btn.addEventListener("touchstart", h, { passive: false });
                btn.addEventListener("mousedown", h, { passive: false });
                btn.addEventListener("click", (ev) => { if (!state.running) return; ev.preventDefault(); ev.stopPropagation(); fn(); }, { passive: false });
            }

            bindTouch(btnJump, _jumpOrRestart);
            bindTouch(btnFire, _shoot);

            
            // FIX EXTRA: Alguns navegadores mobile não disparam eventos no botão de PULAR (canto direito).
            // Então adicionamos um listener em CAPTURE com hit-test pelo retângulo do botão.
            state._touchLatchAt = 0;
            function _tryJumpFromPoint(x, y, ev){
                const now = performance.now();
                if (now - state._touchLatchAt < 80) return; // evita duplo disparo
                const jb = document.getElementById("dino-btn-jump");
                if (!jb) return;
                const r = jb.getBoundingClientRect();
                if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) {
                    state._touchLatchAt = now;
                    try { ev.preventDefault(); ev.stopPropagation(); } catch(e){}
                    _jumpOrRestart();
                }
            }

            // Fallback ULTIMO: se tocar no canto DIREITO inferior (zona do PULAR), pula mesmo assim.
            function _tryJumpFromZone(x, y, ev){
                const w = window.innerWidth || state.w;
                const h = window.innerHeight || state.h;
                // zona: direita 45% e parte de baixo 40%
                if (x < w * 0.55) return;
                if (y < h * 0.60) return;

                // se estiver em cima do TIRO, nao pula
                const fb = document.getElementById("dino-btn-fire");
                if (fb){
                    const fr = fb.getBoundingClientRect();
                    if (x >= fr.left && x <= fr.right && y >= fr.top && y <= fr.bottom) return;
                }

                const now = performance.now();
                if (now - state._touchLatchAt < 80) return;
                state._touchLatchAt = now;
                try { ev.preventDefault(); ev.stopPropagation(); } catch(e){}
                _jumpOrRestart();
            }

            if (!state.__docTouchBound) {
                state.__docTouchBound = true;
                state.__onDocTouch = (ev) => {
                if (!state.running) return;
                if (!ev.touches || !ev.touches[0]) return;
                state.lastInput = "touch";
                _setTouchUI(true);
                const t = ev.touches[0];
                _tryJumpFromPoint(t.clientX, t.clientY, ev);
                _tryJumpFromZone(t.clientX, t.clientY, ev);
            };
                document.addEventListener("touchstart", state.__onDocTouch, { passive: false, capture: true });
            }

            if (!state.__docPtrBound) {
                state.__docPtrBound = true;
                state.__onDocPtr = (ev) => {
                if (!state.running) return;
                if (ev.pointerType !== "touch") return;
                state.lastInput = "touch";
                _setTouchUI(true);
                _tryJumpFromPoint(ev.clientX, ev.clientY, ev);
                _tryJumpFromZone(ev.clientX, ev.clientY, ev);
            };
                document.addEventListener("pointerdown", state.__onDocPtr, { passive: false, capture: true });
            }

            // expõe atalhos globais (caso o console precise)
            try { window.__DINO_JUMP__ = _jumpOrRestart; window.__DINO_SHOOT__ = _shoot; } catch(e){}
// resize (bind 1x / remove no stop)
            if (!state.__resizeBound) {
                state.__resizeBound = true;
                state.__onResize = () => {
                if (!state.running) return;
                _setCanvasSize();
            };
                window.addEventListener("resize", state.__onResize);
            }
}

        function _update(dt){
            const elapsed = (_now() - state.startT) / 1000;
            _phaseColors(elapsed);

            state.speed = Math.min(state.speedMax, state.speed + state.speedGrow * dt);

            if (state.slowTimer > 0) {
                state.slowTimer -= dt;
                if (state.slowTimer < 0) state.slowTimer = 0;
            }
            // boost do Red Dash
            if (state.dashBoostT > 0) {
                state.dashBoostT -= dt;
                if (state.dashBoostT < 0) state.dashBoostT = 0;
            }
            const boost = (state.dashBoostT > 0 ? state.dashBoostFactor : 1);
            const effSpeed = state.speed * (state.slowTimer > 0 ? state.slowFactor : 1) * boost;

            state.distPx += effSpeed * dt;
            // progressão do multiplicador por distância (a cada 100m)
            const _distNow = _distM();
            if (_distNow >= state.nextMultAt) {
                const steps = Math.floor((_distNow - state.nextMultAt) / 100) + 1;
                state.coinMult = Math.min(99, (state.coinMult|0) + steps);
                state.nextMultAt += 100 * steps;
                try { playSysSound(420, "sine", 0.03); } catch(e){}
            }
            // cooldown tiro
            if (state.shootCd > 0) state.shootCd = Math.max(0, state.shootCd - dt);
            
            if (state.jumpFx > 0) state.jumpFx = Math.max(0, state.jumpFx - dt);
            if (state.landFx > 0) state.landFx = Math.max(0, state.landFx - dt);
if (state.shotFx > 0) state.shotFx = Math.max(0, state.shotFx - dt);

            for (const s of state.stripes) {
                s.x -= effSpeed * dt * 0.65;
                if (s.x + s.w < -60) s.x = state.w + _rand(20, 160);
            }

            // spawns
            state._obsT += dt;
            state._coinT += dt;
            state._enemyT += dt;

            const tighten = Math.min(0.42, elapsed / 210);
            const obsInterval = Math.max(0.42, state._nextObs * (1 - tighten));
            const coinInterval = Math.max(0.85, state._nextCoin * (1 - tighten * 0.5));
            const enemyInterval = Math.max(1.15, state._nextEnemy * (1 - tighten*0.35));

            if (state._obsT >= obsInterval) {
                _spawnObstacle();
                state._obsT = 0;
                state._nextObs = _rand(0.68, 1.18);
            }
            if (state._coinT >= coinInterval) {
                if (Math.random() < 0.92) _spawnCoin();
                state._coinT = 0;
                state._nextCoin = _rand(1.0, 2.6);
            }
            if (state._enemyT >= enemyInterval) {
                if (Math.random() < 0.85) _spawnEnemy();
                state._enemyT = 0;
                state._nextEnemy = _rand(2.0, 3.6);
            }

            // fisica player
            const wasOnGround = state.player.onGround;
            const prevY = state.player.y;
            const prevBottom = prevY + state.player.h;
            // reavalia onGround a cada frame (necessário para plataformas)
            state.player.onGround = false;
            state.player.vy += state.gravity * dt;
            state.player.y += state.player.vy * dt;
            const groundTop = state.groundY - state.player.h;

            // colisão com o chão (com tolerância)
            if (state.player.y >= groundTop) {
                state.player.y = groundTop;
                state.player.vy = 0;
                state.player.onGround = true;
            }
            // impacto ao tocar o chão (peso)
            if (!wasOnGround && state.player.onGround) {
                state.landFx = 0.16;
            }
 else if (state.player.vy >= 0 && state.player.y >= groundTop - 1.5) {
                // snap suave: resolve micro-gap que pode impedir o "onGround"
                state.player.y = groundTop;
                state.player.vy = 0;
                state.player.onGround = true;
            }

            // obstaculos
            for (let i = state.obstacles.length - 1; i >= 0; i--) {
                const o = state.obstacles[i];
                o.x -= effSpeed * dt;

                if (o.x + o.w < -80) {
                    state.obstacles.splice(i, 1);
                    continue;
                }

                if (_aabb(state.player.x, state.player.y, state.player.w, state.player.h, o.x, o.y, o.w, o.h)) {
                    if (o.type === "solid") {
                        // BLOCO CINZA: plataforma. Nunca morre por estar em cima.
                        // Regra: se o player estiver em cima (com tolerância), apenas "snapa" e segue.
                        const px1 = state.player.x;
                        const px2 = state.player.x + state.player.w;
                        const ox1 = o.x;
                        const ox2 = o.x + o.w;

                        const overlapX = (px2 > ox1 + 2) && (px1 < ox2 - 2);

                        const curBottom = state.player.y + state.player.h;
                        const topY = o.y;

                        // Janela generosa para considerar "em cima"
                        const onTopNow = overlapX && (curBottom <= topY + 10) && (curBottom >= topY - 8);

                        // Landing vindo de cima (ou quase em cima)
                        if (overlapX && state.player.vy >= -2 && (prevBottom <= topY + 12) && (curBottom >= topY - 10)) {
                            state.player.y = topY - state.player.h;
                            state.player.vy = 0;
                            state.player.onGround = true;
                            state.player.justLanded = 0.10; // efeito de peso/impacto
                            continue;
                        }

                        // Já está em cima: mantém alinhado e NÃO morre
                        if (onTopNow) {
                            state.player.y = topY - state.player.h;
                            state.player.vy = Math.min(0, state.player.vy);
                            state.player.onGround = true;
                            continue;
                        }

                        // Fora do topo => batida lateral/por baixo: game over
                        try { _gameOver(); } catch(e) { try { console.error("[BIXIN] gameOver error:", e); } catch(_){} try { state.phase = "over"; } catch(_){} }
                        return;
                    } else {
                        // BLOCO VERMELHO (breakable): pode acionar RED DASH (super pulo) quando caindo + pressionando pulo
                        // Direção (para penalidade gravíssima: só conta batida lateral)
                        const px1 = state.player.x;
                        const px2 = state.player.x + state.player.w;
                        const ox1 = o.x;
                        const ox2 = o.x + o.w;
                        const overlapX = (px2 > ox1 + 4) && (px1 < ox2 - 4);

                        const prevBottom2 = prevBottom; // já calculado acima
                        const curBottom2 = state.player.y + state.player.h;

                        // vindo de cima (landing / queda)
                        const fromAbove = overlapX && (prevBottom2 <= o.y + 14) && (curBottom2 >= o.y - 10) && (state.player.vy >= -2);

                        // buffer curto de input (vale para teclado e touch)
                        const jumpBuffered = (state.jumpPressT && (_now() - state.jumpPressT) <= 140);

                        // RED DASH: queda + pulo pressionado + vindo de cima => super pulo, boost, partículas e +1x mult
                        if (fromAbove && state.player.vy > 40 && jumpBuffered) {
                            state.obstacles.splice(i, 1);

                            // "snapa" no topo antes do impulso
                            state.player.y = o.y - state.player.h;
                            state.player.vy = -state.jumpV * 1.3;
                            state.player.onGround = false;

                            state.jumpFx = 0.18;
                            state.shake = 0.26;

                            // boost curto de velocidade
                            state.dashBoostT = Math.max(state.dashBoostT, 0.60);
                            state.speed = Math.min(state.speedMax, state.speed + 160);

                            // explosão de partículas (usa sistema existente)
                            _spawnParticles(o.x + o.w/2, o.y + o.h/2, "#ff2b5e", 60);
                            _spawnParticles(o.x + o.w/2, o.y + o.h/2, state.accent, 26);
                            _spawnParticles(o.x + o.w/2, o.y + o.h/2, "#ffffff", 10);

                            // +1x no multiplicador
                            state.coinMult = Math.min(99, (state.coinMult|0) + 1);

                            try { playSysSound(920, "square", 0.10); } catch(e){}
                            try { showToast("RED DASH!", `MULT x${state.coinMult}`, null, "flash_on"); } catch(e){}
                            continue;
                        }

                        // Pisou em cima do bloco vermelho (sem Red Dash): funciona como plataforma
                        const onTopNowRed = overlapX && (curBottom2 <= o.y + 10) && (curBottom2 >= o.y - 8);

                        if (onTopNowRed) {
                            state.player.y = o.y - state.player.h;
                            state.player.vy = Math.min(0, state.player.vy);
                            state.player.onGround = true;
                            continue;
                        }

                        // Landing vindo de cima (sem dash): pisa e segue
                        if (fromAbove) {
                            state.player.y = o.y - state.player.h;
                            state.player.vy = 0;
                            state.player.onGround = true;
                            state.player.justLanded = 0.10;
                            state.landFx = Math.max(state.landFx || 0, 0.08);
                            try { playSysSound(260, "triangle", 0.05); } catch(e){}
                            continue;
                        }

                        // Quebra padrão (sem Red Dash): quebra + lentidão
                        state.obstacles.splice(i, 1);
                        state.slowTimer = 1.6;
                        state.shake = 0.17;
                        _spawnParticles(o.x + o.w/2, o.y + o.h/2, "#ff2b5e", 12);
                        try { playSysSound(220, "square", 0.10); } catch(e){}

                        // Penalidade gravíssima: 2 batidas LATERAIS (não vindas de cima)
                        if (!fromAbove) {
                            state.redBumps += 1;
                            if (state.redBumps >= 2) {
                                state.redBumps = 0;
                                if (state.coinsPicked > 0) state.coinsPicked -= 1;

                                // reseta multiplicador para 1x e adia próxima meta
                                state.coinMult = 1;
                                state.nextMultAt = (Math.floor(_distM() / 100) + 1) * 100;

                                state.jumpFx = 0.10; // usa o fx existente como "alerta"
                                try { playSysSound(120, "triangle", 0.10); } catch(e){}
                                try { showToast("PENALIDADE", "MULT x1", null, "report_problem"); } catch(e){}
                            }
                        }
                        continue;
                    }
                }
            }

            // moedas
            for (let i = state.coins.length - 1; i >= 0; i--) {
                const c = state.coins[i];
                c.x -= effSpeed * dt;

                if (c.x + c.r < -60) {
                    state.coins.splice(i, 1);
                    continue;
                }

                if (_circleRect(c.x, c.y, c.r, state.player.x, state.player.y, state.player.w, state.player.h)) {
                    state.coinsPicked += _coinMult();
                    state.coins.splice(i, 1);
                    try { playSysSound(980, "sine", 0.06); } catch(e){}
                }
            }

            // inimigos (voadores e terrestres)
            for (let i = state.enemies.length - 1; i >= 0; i--) {
                const e = state.enemies[i];
                const isGround = !!e.ground;
                const spMul = (e.spMul || 1);

                e.x -= effSpeed * dt * 1.06 * spMul;

                if (!isGround) {
                    // IA de perseguição suave no eixo Y conforme se aproxima do jogador
                    e.wob = (e.wob || 0) + dt * 3.2;
                    e.y += Math.sin(e.wob) * dt * 18;

                    const distX = Math.max(0, e.x - state.player.x);
                    const chase = Math.max(0, Math.min(1, 1 - distX / (state.w * 0.65)));
                    e.y += (state.player.y - e.y) * (0.02 * chase);

                    // clamp para não grudar no chão / teto
                    const yMin = Math.max(10, Math.floor(state.h * 0.14));
                    const yMax = state.groundY - state.player.h - Math.max(26, Math.floor(state.h * 0.10));
                    if (e.y < yMin) e.y = yMin;
                    if (e.y > yMax) e.y = yMax;
                } else {
                    // trava no chão
                    e.y = state.groundY - e.h;
                }

                if (e.x + e.w < -120) {
                    state.enemies.splice(i, 1);
                    continue;
                }

                // HITBOX realista: usa apenas colisão e reduz 20% para permitir 'raspar'
                const shrink = 0.80;
                const ex = e.x + e.w * (1 - shrink) * 0.5;
                const ey = e.y + e.h * (1 - shrink) * 0.5;
                const ew = e.w * shrink;
                const eh = e.h * shrink;

                if (_aabb(state.player.x, state.player.y, state.player.w, state.player.h, ex, ey, ew, eh)) {
                    if (isGround) {
                        const overlapX = (state.player.x + state.player.w) > ex && state.player.x < (ex + ew);
                        const fromAbove = overlapX && (prevBottom <= (e.y + 10)) && ((state.player.y + state.player.h) >= e.y) && (state.player.vy >= -2);

                        // buffer curto de input (vale para teclado e touch)
                        const jumpBuffered = (state.jumpPressT && (_now() - state.jumpPressT) <= 140);

                        // RED DASH no inimigo terrestre: cair + pulo no timing => impulso + explosão
                        if (fromAbove && state.player.vy > 40 && jumpBuffered) {
                            state.enemies.splice(i, 1);

                            state.player.y = e.y - state.player.h;
                            state.player.vy = -state.jumpV * 1.3;
                            state.player.onGround = false;

                            state.jumpFx = 0.18;
                            state.shake = 0.26;

                            // boost curto de velocidade
                            state.dashBoostT = Math.max(state.dashBoostT, 0.55);
                            state.speed = Math.min(state.speedMax, state.speed + 140);

                            // explosão de partículas (usa sistema existente)
                            _spawnParticles(e.x + e.w/2, e.y + e.h/2, "#ff2b5e", 60);
                            _spawnParticles(e.x + e.w/2, e.y + e.h/2, state.accent, 26);
                            _spawnParticles(e.x + e.w/2, e.y + e.h/2, "#ffffff", 10);

                            try { playSysSound(880, "square", 0.10); } catch(_e){}
                            continue;
                        }

                        // pisou em cima (sem Red Dash) => quica e destrói
                        if (fromAbove && state.player.vy > 10) {
                            state.enemies.splice(i, 1);

                            state.player.y = e.y - state.player.h;
                            state.player.vy = -state.jumpV * 0.92;
                            state.player.onGround = false;

                            _spawnParticles(e.x + e.w/2, e.y + e.h/2, (e.color || "#ff5500"), 22);
                            try { playSysSound(720, "square", 0.07); } catch(_e){}
                            continue;
                        }
                    }

                    // colisão direta => game over
                    try { _gameOver(); } catch(e) { try { console.error("[DINO] gameOver error:", e); } catch(_){} try { const overEl=document.getElementById("dino-game-over"); if (overEl){ overEl.style.display="block"; overEl.style.zIndex="999999"; } } catch(_e){} }
                    return;
                }
            }

            // particulas
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += (state.gravity * 0.55) * dt;
                p.life -= dt;
                if (p.life <= 0) state.particles.splice(i, 1);
            }

            if (state.shake > 0) {
                state.shake -= dt;
                if (state.shake < 0) state.shake = 0;
            }

            // gamepad
            const pads = navigator.getGamepads?.() || [];
            const p0 = pads[0];
            if (p0?.buttons) {
                // A = pulo
                if (p0.buttons[0] && p0.buttons[0].pressed) {
                    if (!state.gpLatchA) {
                        state.lastInput = "pad";
                        _setTouchUI(false);
                        _jumpOrRestart();
                        state.gpLatchA = true;
                    }
                } else {
                    state.gpLatchA = false;
                }
                // B = tiro
                if (p0.buttons[1] && p0.buttons[1].pressed) {
                    if (!state.gpLatchB) {
                        state.lastInput = "pad";
                        _setTouchUI(false);
                        _shoot();
                        state.gpLatchB = true;
                    }
                } else {
                    state.gpLatchB = false;
                }
            }
        }
            // caps anti-lag: evita crescimento infinito de arrays em sessões longas
            try {
                if (state.particles.length > 420) state.particles.splice(0, state.particles.length - 420);
                if (state.enemies.length > 120) state.enemies.splice(0, state.enemies.length - 120);
                if (state.obstacles.length > 120) state.obstacles.splice(0, state.obstacles.length - 120);
                if (state.coins.length > 180) state.coins.splice(0, state.coins.length - 180);
                if (state.stripes.length > 300) state.stripes.splice(0, state.stripes.length - 300);
            } catch(e) {}


        function _drawPixelRect(x,y,w,h,fill,inner){
            const ctx = state.ctx;
            ctx.fillStyle = "rgba(0,0,0,0.35)";
            ctx.fillRect(Math.floor(x)-2, Math.floor(y)-2, Math.floor(w)+4, Math.floor(h)+4);
            ctx.fillStyle = fill;
            ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
            ctx.fillStyle = inner;
            ctx.fillRect(Math.floor(x)+2, Math.floor(y)+2, Math.max(1, Math.floor(w)-4), Math.max(1, Math.floor(h)-4));
        }

        function _draw(){
            const ctx = state.ctx;
            const w = state.w, h = state.h;

            ctx.save();

            if (state.shake > 0) {
                const mag = 10 * (state.shake / 0.17);
                ctx.translate((Math.random()*2-1)*mag, (Math.random()*2-1)*mag);
            }

            // bg
            const g = ctx.createLinearGradient(0,0,0,h);
            g.addColorStop(0, state.bgA);
            g.addColorStop(1, state.bgB);
            ctx.fillStyle = g;
            ctx.fillRect(0,0,w,h);

            // scanlines
            ctx.globalAlpha = 0.12;
            ctx.fillStyle = "#ffffff";
            const slGap = Math.max(4, Math.floor(h*0.02));
            for(let y=0; y<h; y+=slGap) ctx.fillRect(0, y, w, 1);
            ctx.globalAlpha = 1;

            // grid
            ctx.globalAlpha = 0.14;
            ctx.strokeStyle = state.accent;
            ctx.lineWidth = 1;
            ctx.beginPath();
            const gridGap = Math.max(26, Math.floor(h*0.12));
            for (let yy = 0; yy < h; yy += gridGap) { ctx.moveTo(0,yy); ctx.lineTo(w,yy); }
            ctx.stroke();
            ctx.globalAlpha = 1;

            // ground neon
            ctx.save();
            ctx.shadowColor = state.accent;
            ctx.shadowBlur = Math.max(8, Math.floor(h*0.03));
            ctx.strokeStyle = state.accent;
            ctx.lineWidth = Math.max(2, Math.floor(h*0.012));
            ctx.beginPath();
            ctx.moveTo(0, state.groundY);
            ctx.lineTo(w, state.groundY);
            ctx.stroke();
            ctx.restore();

            // road stripes
            ctx.fillStyle = "rgba(255,255,255,0.20)";
            for (const s of state.stripes) ctx.fillRect(Math.floor(s.x), Math.floor(s.y), Math.floor(s.w), Math.floor(s.h));

            // coins
            for (const c of state.coins) {
                ctx.save();
                ctx.shadowColor = "#ffd700";
                ctx.shadowBlur = Math.max(6, Math.floor(h*0.02));
                ctx.fillStyle = "#ffd700";
                ctx.fillRect(Math.floor(c.x-c.r), Math.floor(c.y-c.r), Math.floor(c.r*2), Math.floor(c.r*2));
                ctx.fillStyle = "rgba(255,255,255,0.8)";
                ctx.fillRect(Math.floor(c.x-c.r+2), Math.floor(c.y-c.r+2), Math.max(2, Math.floor(c.r*0.75)), Math.max(2, Math.floor(c.r*0.75)));
                ctx.restore();
            }

            // enemies
            for (const e of state.enemies) {
                ctx.save();

                if (e.ground) {
                    // inimigo terrestre: bloco com espinhos (laranja)
                    ctx.shadowColor = e.color || "#ff5500";
                    ctx.shadowBlur = Math.max(12, Math.floor(h*0.035));

                    _drawPixelRect(e.x, e.y, e.w, e.h, e.color || "#ff5500", "rgba(0,0,0,0.22)");

                    // espinhos (triângulos no topo)
                    ctx.fillStyle = "rgba(0,0,0,0.32)";
                    const spikes = Math.max(3, Math.floor(e.w / 10));
                    const step = e.w / spikes;
                    for (let k = 0; k < spikes; k++) {
                        const sx = e.x + k * step;
                        ctx.beginPath();
                        ctx.moveTo(sx, e.y);
                        ctx.lineTo(sx + step * 0.5, e.y - Math.max(6, e.h * 0.18));
                        ctx.lineTo(sx + step, e.y);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // brilho
                    ctx.fillStyle = "rgba(255,255,255,0.22)";
                    ctx.fillRect(Math.floor(e.x + e.w*0.12), Math.floor(e.y + e.h*0.15), Math.max(2, Math.floor(e.w*0.12)), Math.max(2, Math.floor(e.h*0.70)));
                } else {
                    // inimigo voador: neon rosa
                    ctx.shadowColor = "#ff2d6e";
                    ctx.shadowBlur = Math.max(10, Math.floor(h*0.03));
                    _drawPixelRect(e.x, e.y, e.w, e.h, "rgba(255,45,110,0.78)", "rgba(0,0,0,0.20)");
                    // olhos
                    ctx.fillStyle = "rgba(255,255,255,0.85)";
                    ctx.fillRect(Math.floor(e.x + e.w*0.25), Math.floor(e.y + e.h*0.33), Math.max(2, Math.floor(e.w*0.15)), Math.max(2, Math.floor(e.h*0.12)));
                    ctx.fillRect(Math.floor(e.x + e.w*0.60), Math.floor(e.y + e.h*0.33), Math.max(2, Math.floor(e.w*0.15)), Math.max(2, Math.floor(e.h*0.12)));
                }

                ctx.restore();
            }

            // obstacles
            for (const o of state.obstacles) {
                if (o.type === "solid") {
                    _drawPixelRect(o.x, o.y, o.w, o.h, "rgba(190,190,190,0.75)", "rgba(70,70,70,0.35)");
                } else {
                    const hp = (o.hp == null) ? 2 : o.hp;
                    const fill = (hp <= 1) ? "rgba(255,70,120,0.78)" : "rgba(255,40,90,0.85)";
                    ctx.save();
                    ctx.shadowColor = "#ff2b5e";
                    ctx.shadowBlur = Math.max(10, Math.floor(h*0.03));
                    _drawPixelRect(o.x, o.y, o.w, o.h, fill, "rgba(0,0,0,0.20)");
                    // rachadura simples quando está com 1 HP
                    if (hp <= 1) {
                        ctx.globalAlpha = 0.55;
                        ctx.strokeStyle = "rgba(255,255,255,0.55)";
                        ctx.lineWidth = Math.max(1, Math.floor(h*0.004));
                        ctx.beginPath();
                        ctx.moveTo(o.x + o.w*0.15, o.y + o.h*0.25);
                        ctx.lineTo(o.x + o.w*0.55, o.y + o.h*0.45);
                        ctx.lineTo(o.x + o.w*0.35, o.y + o.h*0.78);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            // particles
            for (const p of state.particles) {
                ctx.save();
                ctx.globalAlpha = Math.max(0, Math.min(1, p.life / 0.7));
                ctx.shadowColor = p.color;
                ctx.shadowBlur = Math.max(6, Math.floor(h*0.02));
                ctx.fillStyle = p.color;
                ctx.fillRect(Math.floor(p.x), Math.floor(p.y), p.size, p.size);
                ctx.restore();
            }

            // player cart
            const px = state.player.x;
            const pw = state.player.w;
            const baseY = state.player.y + state.player.h; // bottom do player (no chão = groundY)

            // animação: leve balanço + inclinação por velocidade vertical + peso ao aterrissar
            const tms = _now();
            const bob = (state.player.onGround ? Math.sin(tms/95) * 1.4 : Math.sin(tms/140) * 0.6);
            const baseYb = baseY + bob;

            const tiltRaw = (-state.player.vy / 1100); // sobe inclina pra cima, desce inclina pra baixo
            const tilt = Math.max(-0.22, Math.min(0.22, tiltRaw));
            const impact = (state.landFx > 0 ? (state.landFx / 0.16) : 0);
            const sx = 1 + impact * 0.18;
            const sy = 1 - impact * 0.30;

            const pivotX = px + pw * 0.52;
            const pivotY = baseYb - Math.max(18, Math.floor(state.player.h*0.35)) - Math.max(7, Math.floor(pw*0.16)) * 0.2;

            ctx.save();
            ctx.translate(pivotX, pivotY);
            ctx.rotate(tilt);
            ctx.scale(sx, sy);
            ctx.translate(-pivotX, -pivotY);
            const wheel = Math.max(7, Math.floor(pw*0.16));
            const bodyH = Math.max(16, Math.floor(state.player.h*0.35));
            const bodyY = baseYb - bodyH - wheel + 2;

            // wheels
            ctx.fillStyle = "rgba(0,0,0,0.75)";
            ctx.fillRect(Math.floor(px + 6), Math.floor(baseYb - wheel), wheel, wheel);
            ctx.fillRect(Math.floor(px + pw - wheel - 6), Math.floor(baseYb - wheel), wheel, wheel);
            ctx.fillStyle = "rgba(255,255,255,0.25)";
            ctx.fillRect(Math.floor(px + 8), Math.floor(baseYb - wheel + 2), Math.max(2,wheel-4), Math.max(2,wheel-4));
            ctx.fillRect(Math.floor(px + pw - wheel - 4), Math.floor(baseYb - wheel + 2), Math.max(2,wheel-4), Math.max(2,wheel-4));


            // faíscas neon (bem visíveis) nas rodas quando está no chão
            if (state.player.onGround) {
                ctx.save();
                const spin = Math.floor((_now() / 18)) % 100000;
                ctx.globalAlpha = 0.95;
                ctx.fillStyle = "rgba(0,229,255,0.98)";
                ctx.shadowColor = "rgba(0,229,255,0.95)";
                ctx.shadowBlur = Math.max(26, Math.floor(h*0.065));

                const sy = Math.floor(baseYb - 2);
                const count = 14;

                // rodas esquerda e direita
                for (let k=0; k<count; k++){
                    const dx = (spin + k*9) % 38;
                    const dy = (k % 5);
                    // esquerda (traz pra trás)
                    ctx.fillRect(Math.floor(px + 14 - dx), sy - dy, 2 + (k%2), 1 + ((k+1)%2));
                    // direita (traz pra trás)
                    ctx.fillRect(Math.floor(px + pw - 14 - dx), sy - ((dy+2)%5), 2 + ((k+1)%2), 1 + (k%2));
                }
                ctx.restore();
            }
            // body
            ctx.save();
            ctx.shadowColor = state.accent;
            ctx.shadowBlur = Math.max(10, Math.floor(h*0.03));
            _drawPixelRect(px, bodyY, pw, bodyH, state.accent, "rgba(0,0,0,0.18)");
            ctx.restore();

            // cabin
            ctx.fillStyle = "rgba(0,0,0,0.35)";
            ctx.fillRect(Math.floor(px + pw*0.55), Math.floor(bodyY - bodyH*0.25), Math.floor(pw*0.30), Math.floor(bodyH*0.32));
            ctx.fillStyle = "rgba(255,255,255,0.18)";
            ctx.fillRect(Math.floor(px + pw*0.55 + 2), Math.floor(bodyY - bodyH*0.25 + 2), Math.max(2, Math.floor(pw*0.30)-4), Math.max(2, Math.floor(bodyH*0.32)-4));

            // gun
            ctx.save();
            ctx.shadowColor = "#ffd700";
            ctx.shadowBlur = Math.max(8, Math.floor(h*0.02));
            ctx.fillStyle = "rgba(255,215,0,0.85)";
            const gunW = Math.max(10, Math.floor(pw*0.22));
            const gunH = Math.max(4, Math.floor(bodyH*0.22));
            const gunX = Math.floor(px + pw - gunW - 2);
            const gunY = Math.floor(bodyY - gunH - 2);
            ctx.fillRect(gunX, gunY, gunW, gunH);
            ctx.restore();

            // head/avatar
            const headW = Math.floor(pw*0.72);
            const headH = Math.floor(state.player.h*0.72);
            const headX = Math.floor(px + (pw-headW)/2);
            const headY = Math.floor(bodyY - headH + Math.max(2, Math.floor(bodyH*0.10)));

            if (state.imgOk) {
                try { ctx.drawImage(state.img, headX, headY, headW, headH); }
                catch(e){ state.imgOk = false; }
            }
            if (!state.imgOk) {
                ctx.save();
                ctx.shadowColor = "#00ff88";
                ctx.shadowBlur = Math.max(8, Math.floor(h*0.02));
                ctx.fillStyle = "#00ff88";
                ctx.fillRect(headX, headY, headW, headH);
                ctx.fillStyle = "rgba(0,0,0,0.25)";
                ctx.fillRect(headX+3, headY+3, Math.max(2,headW-6), Math.max(2,headH-6));
                ctx.restore();
            }

            // feedback do pulo (glow rápido)
            if (state.jumpFx > 0) {
                const a = Math.min(1, state.jumpFx / 0.14);
                ctx.save();
                ctx.globalAlpha = a;
                ctx.strokeStyle = state.accent;
                ctx.lineWidth = Math.max(2, Math.floor(h*0.01));
                ctx.shadowColor = state.accent;
                ctx.shadowBlur = Math.max(12, Math.floor(h*0.04));
                const cx = state.player.x + state.player.w*0.55;
                const cy = state.player.y + state.player.h*0.30;
                const r = state.player.w * (0.40 + (1-a)*0.10);
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI*2);
                ctx.stroke();
                ctx.restore();
            }


            // shot FX (laser)
            if (state.shotFx > 0) {
                ctx.save();
                ctx.globalAlpha = Math.min(1, state.shotFx / 0.08);
                ctx.strokeStyle = "#ffd700";
                ctx.lineWidth = Math.max(2, Math.floor(h*0.01));
                ctx.shadowColor = "#ffd700";
                ctx.shadowBlur = Math.max(10, Math.floor(h*0.03));
                ctx.beginPath();
                ctx.moveTo(state.lastShotX, state.lastShotY);
                ctx.lineTo(state.lastShotTX, state.lastShotTY);
                ctx.stroke();
                ctx.restore();
            }

            
            ctx.restore();

// HUD min
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = "rgba(255,255,255,0.80)";
            ctx.font = `${Math.max(12, Math.floor(h*0.03))}px monospace`;
            const dist = _distM();
            const mult = _coinMult();
            ctx.fillText(`DIST ${dist}  MOEDAS ${state.coinsPicked}  x${mult}  K ${state.kills}`, 14, 24);
            // cooldown tiro
            if (state.shootCd > 0) {
                ctx.fillText(`TIRO...`, 14, 46);
            }
            ctx.restore();

            ctx.restore();
        }

        function _loop(t){
            if (!state.running) return;
            if (!state.lastT) state.lastT = t;
            const dt = Math.min(0.033, Math.max(0.001, (t - state.lastT) / 1000));
            state.lastT = t;

            try {
                if (state.phase === "playing") _update(dt);
            } catch(err) {
                try { console.error("[DINO] update error:", err); } catch(e){}
                try { _gameOver(); } catch(e) { try { console.error("[DINO] gameOver error:", e); } catch(_){} try { const overEl=document.getElementById("dino-game-over"); if (overEl){ overEl.style.display="block"; overEl.style.zIndex="999999"; } } catch(_e){} }
            }

            try { _draw(); }
            catch(err) { try { console.error("[DINO] draw error:", err); } catch(e){} }

            state.raf = requestAnimationFrame(_loop);
        }

        
                function _settlePending(){
            // Versões antigas podiam guardar XC pendente. Como o limite foi desativado,
            // creditamos tudo imediatamente e limpamos o registro.
            let pending = parseInt(localStorage.getItem(LS_PENDING) || "0", 10);
            if (!pending || pending <= 0) return;

            const before = (typeof userCoins !== "undefined")
                ? (userCoins|0)
                : parseInt(localStorage.getItem("xs_coins") || "0", 10);

            const credit = Math.max(0, pending|0);
            localStorage.removeItem(LS_PENDING);

            if (credit <= 0) return;

            const after = before + credit;

            if (typeof userCoins !== "undefined") userCoins = after;
            localStorage.setItem("xs_coins", String(after));

            // limpa rastros do limitador antigo
            try { localStorage.removeItem(LS_WIN_START); localStorage.removeItem(LS_WIN_AMT); } catch(e) {}

            try { saveEconomy(); } catch(e) { try { updateCoinDisplay(); } catch(e2){} }

            try { playSysSound(620, "sine", 0.08); } catch(e){}
            try { showToast("XC PENDENTE", `+${credit} XC creditado`, null, "savings"); } catch(e){}
        }


                function _awardXC(rawEarned){
            // Limite desativado: credita 100% do ganho imediatamente.
            const allowed = Math.max(0, Math.floor(rawEarned || 0));

            const before = (typeof userCoins !== "undefined")
                ? (userCoins|0)
                : parseInt(localStorage.getItem("xs_coins") || "0", 10);

            const after = before + allowed;

            if (allowed > 0) {
                if (typeof userCoins !== "undefined") userCoins = after;
                localStorage.setItem("xs_coins", String(after));
                try { saveEconomy(); } catch(e) { try { updateCoinDisplay(); } catch(e2){} }
            } else {
                try { updateCoinDisplay(); } catch(e) {}
            }

            // garante que a nota de limite não apareça
            try {
                const capEl = document.getElementById("dino-cap-note");
                if (capEl) capEl.textContent = (allowed === 0) ? "Sem moedas desta vez — tenta mais!" : "";
            } catch(e) {}

            // limpa rastros do limitador antigo
            try { localStorage.removeItem(LS_PENDING); localStorage.removeItem(LS_WIN_START); localStorage.removeItem(LS_WIN_AMT); } catch(e) {}

            return { allowed, before, after };
        }
        function _flyCoin(fromEl, toEl){
            try{
                const stream = document.getElementById("dino-coin-stream");
                if (!stream || !fromEl || !toEl) return;
                const fr = fromEl.getBoundingClientRect();
                const tr = toEl.getBoundingClientRect();

                const sx = fr.left + fr.width*0.5;
                const sy = fr.top  + fr.height*0.5;
                const tx = tr.left + tr.width*0.5;
                const ty = tr.top  + tr.height*0.5;

                const coin = document.createElement("div");
                coin.className = "coinFly";
                stream.appendChild(coin);

                const jitter = (v)=> v + (Math.random()*2-1)*18;
                const c1x = jitter((sx + tx)/2);
                const c1y = jitter(Math.min(sy, ty) - 80);

                const startT = performance.now();
                const dur = 720 + Math.random()*260;

                function bez(t,a,b,c,d){
                    const mt = 1-t;
                    return mt*mt*mt*a + 3*mt*mt*t*b + 3*mt*t*t*c + t*t*t*d;
                }
                function easeOut(t){ return 1 - Math.pow(1-t, 3); }

                function step(now){
                    const p = Math.min(1, (now - startT)/dur);
                    const e = easeOut(p);

                    const x = bez(e, sx, c1x, c1x, tx);
                    const y = bez(e, sy, c1y, c1y, ty);

                    const pulse = 0.9 + 0.25*Math.sin((now-startT)/90);
                    const scale = (0.75 + 0.45*(1-p)) * pulse;

                    coin.style.opacity = (p < 0.08) ? String(p/0.08) : (p > 0.92 ? String((1-p)/0.08) : "1");
                    coin.style.transform = `translate(${x-7}px, ${y-7}px) scale(${scale})`;

                    if (p < 1) requestAnimationFrame(step);
                    else { try { coin.remove(); } catch(e){} }
                }
                requestAnimationFrame(step);
            }catch(e){}
        }

        function _coinStreamBurst(runEl, walletEl, intensity, durationMs){
            const n = Math.max(6, Math.min(36, Math.floor(intensity || 14)));
            const interval = Math.max(26, Math.floor(durationMs / n));
            let c = 0;
            const timer = setInterval(()=>{
                c++;
                _flyCoin(runEl, walletEl);
                if (c >= n) clearInterval(timer);
            }, interval);
        }

function _animateNumbers(earnedShown, totalBefore, totalAfter, runCoins){
            const earnedEl = document.getElementById("dino-coins-earned");
            const totalEl  = document.getElementById("dino-total-coins");
            const runEl    = document.getElementById("dino-run-coins");
            const lineEl   = document.getElementById("dino-convert-line");

            const run0 = Math.max(0, Math.floor(runCoins || 0));

            let spawnCount = 0;
            const walletEl = document.getElementById('coin-val') || totalEl;
            const spawnTotal = Math.max(10, Math.min(30, Math.ceil(run0/2)));

            let t0 = _now();
            const dur = 980;

            // estado inicial
            if (runEl) runEl.textContent = String(run0);
            if (lineEl) lineEl.textContent = `Convertendo ${run0} moedas → +0 XC…`;

            function step(){
                // pequeno burst inicial para dar sensação de \"transferência\"
                if (spawnCount === 0 && run0 > 0) {
                    try { _coinStreamBurst(runEl || earnedEl, walletEl || totalEl, Math.min(18, Math.max(10, Math.ceil(run0/3))), dur); } catch(e){}
                }

                const p = Math.min(1, (_now() - t0) / dur);
                const ease = 1 - Math.pow(1 - p, 3);

                const eVal = Math.floor(earnedShown * ease);
                const tVal = Math.floor(totalBefore + (totalAfter - totalBefore) * ease);

                // efeito "moedas virando XC": moedas descem até 0 enquanto XC sobe
                const runLeft = Math.max(0, Math.ceil(run0 * (1 - ease)));


                // moedas pulsando e indo para a carteira durante a conversão
                const shouldSpawn = Math.floor(spawnTotal * ease);
                while (spawnCount < shouldSpawn) {
                    try { _flyCoin(runEl || earnedEl, walletEl || totalEl); } catch(e){}
                    spawnCount++;
                }

                if (earnedEl) earnedEl.textContent = String(eVal);
                if (totalEl)  totalEl.textContent  = String(tVal);
                if (runEl)    runEl.textContent    = String(runLeft);
                if (lineEl)   lineEl.textContent   = `Convertendo ${run0} moedas → +${eVal} XC…`;

                if (p < 1) requestAnimationFrame(step);
                else {
                    if (earnedEl) earnedEl.textContent = String(earnedShown);
                    if (totalEl)  totalEl.textContent  = String(totalAfter);
                                        if (lineEl)   lineEl.textContent   = `Conversão concluída: +${earnedShown} XC`;
                }
            }
            requestAnimationFrame(step);
        }

        function _gameOver(){
            // Game Over robusto: sempre mostra a tela mesmo se algo der erro
            if (state.didGameOver) return;
            state.didGameOver = true;
            state.phase = "over";

            const safeEl = (id) => { try { return document.getElementById(id); } catch(e){ return null; } };
            const setTxt = (id, v) => { const el = safeEl(id); if (el) el.textContent = String(v); };

            // garante que o painel aparece SEMPRE (mesmo se a parte de economia falhar)
            const overEl = safeEl("dino-game-over");
            if (overEl) {
                overEl.style.display = "block";
                try { overEl.style.zIndex = "999999"; } catch(e){}
            }

            let distance = 0;
            let earnedAllowed = 0;
            let before = 0;
            let after  = 0;

            try {
                distance = Math.max(0, Math.floor(state.distPx / 18));
                const elapsed = Math.max(0.1, (_now() - state.startT) / 1000);
                const tier = Math.min(25, Math.floor(elapsed / 18));

                // ganho balanceado: tempo + moedas + kills (bem pouco) + tier
                let raw = Math.floor(Math.pow(elapsed, 0.92) / 3.1)
                        + Math.floor((state.coinsPicked || 0) * 0.85)
                        + Math.floor((state.kills || 0) * 0.35)
                        + Math.floor(tier * 0.55);

                raw = Math.max(0, Math.min(160, raw));

                const r = _awardXC(raw);
                earnedAllowed = r.allowed;
                before = r.before;
                after  = r.after;

                                // info (limite desativado)
                                const capNoteEl = safeEl("dino-cap-note");
                                if (capNoteEl) capNoteEl.textContent = (raw === 0) ? "Sem moedas desta vez — tenta mais!" : "";
            } catch(err) {
                try { console.error("[DINO] gameOver compute error:", err); } catch(e){}
                // fallback: não premia, mas ainda mostra
                distance = Math.max(0, Math.floor(state.distPx / 18));
                try {
                    before = (typeof userCoins !== "undefined") ? (userCoins|0) : 0;
                    after  = before;
                } catch(e) { before = 0; after = 0; }
            }

            // Atualiza UI (sempre)
            setTxt("dino-final-score", distance);

            // garante os valores iniciais visíveis
            try {
                const runEl = safeEl("dino-run-coins");
                if (runEl) runEl.textContent = String(Math.max(0, Math.floor(state.coinsPicked || 0)));
                const lineEl = safeEl("dino-convert-line");
                if (lineEl) lineEl.textContent = "Convertendo…";
            } catch(e){}

            // Anima números com segurança
            try {
                _animateNumbers(earnedAllowed, before, after, state.coinsPicked);
            } catch(err) {
                try { console.error("[DINO] animateNumbers error:", err); } catch(e){}
                // fallback texto direto
                setTxt("dino-coins-earned", earnedAllowed);
                setTxt("dino-total-coins", after);
                const runEl = safeEl("dino-run-coins"); if (runEl) runEl.textContent = "0";
                const lineEl = safeEl("dino-convert-line"); if (lineEl) lineEl.textContent = `Conversão concluída: +${earnedAllowed} XC`;
            }

            try { playSysSound(160, "sine", 0.14); } catch(e){}
        }

        function startFromConsole(){
            forceFullscreen();
            try { playSysSound(800, "sine", 0.25); } catch(e){}


            // tenta creditar XC pendente (se o limite por janela permitiu)
            try { _settlePending(); } catch(e){}
            // Hook actionEnter (botao ✕ do console) para PULAR dentro do jogo
            if (!state.hooked && typeof window !== "undefined" && typeof window.actionEnter === "function") {
                state.origActionEnter = window.actionEnter;
                window.actionEnter = function() {
                    try {
                        const cont = document.getElementById("dino-game-container");
                        const visible = cont && cont.style.display !== "none";
                        if (state.running && visible) { _jumpOrRestart(); return; }
                    } catch(e) {}
                    return state.origActionEnter();
                };
                state.hooked = true;
            }

            // esconde controles do console (evita bug de texto nos botoes)
            try {
                const mc = document.getElementById("mobile-controls");
                if (mc) { state.mcPrevDisplay = mc.style.display; mc.style.display = "none"; }
            } catch(e) {}

            const rt = document.getElementById("game-runtime");
            const frame = document.getElementById("game-frame");
            const cont = document.getElementById("dino-game-container");

            rt.style.display = "block";
            cont.style.display = "block";
            frame.style.display = "none";
            frame.src = "";

            try { clearInterval(playTimerInterval); } catch(e){}
            try {
                playTimerInterval = setInterval(() => {
                    playTime++;
                    sessionSeconds++;
                    if (playTime % 5 === 0) evaluateMilestones();
                    if (playTime % 60 === 0) saveEconomy();
                    if (playTime % 30 === 0) awardSpinsFromPlaytime();
                }, 1000);
            } catch(e){}

            state.canvas = document.getElementById("dino-canvas");
            state.ctx = state.canvas.getContext("2d");
            _setCanvasSize();
            _bindInputsOnce();
            _loadCharacter();

            // touch UI so quando for touch-capable (e se nao tiver teclado/controle)
            try {
                const isTouchCapable = ("ontouchstart" in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
                _setTouchUI(!!isTouchCapable);
                state.lastInput = isTouchCapable ? "touch" : "kbd";
            } catch(e) {}

            state.running = true;
            state.phase = "playing";
            state.lastT = 0;
            state.startT = _now();
            _reset();

            // Tutorial (se necessário) antes de começar de verdade
            let tutShown = false;
            try { tutShown = _tutorialShowIfNeeded(); } catch(e) { tutShown = false; }
            if (!tutShown) {
                // inicia música (aleatória) na entrada do gameplay
                try { _musicStartRandom(); } catch(e){}
            }
            cancelAnimationFrame(state.raf);
            state.raf = requestAnimationFrame(_loop);
        }

        return {
            startFromConsole,
            stop: () => {
                state.running = false;
                cancelAnimationFrame(state.raf);

                // --- Anti-leak: remove listeners globais e reseta arrays pesados
                try { if (state.__onKeyDown) window.removeEventListener("keydown", state.__onKeyDown); } catch(e){}
                try { if (state.__onResize) window.removeEventListener("resize", state.__onResize); } catch(e){}
                try { if (state.__onDocTouch) document.removeEventListener("touchstart", state.__onDocTouch, true); } catch(e){}
                try { if (state.__onDocPtr) document.removeEventListener("pointerdown", state.__onDocPtr, true); } catch(e){}
                try {
                    const canvas = document.getElementById("dino-canvas");
                    const overlay = document.getElementById("dino-game-over");
                    if (canvas && state.__onTap) canvas.removeEventListener("pointerdown", state.__onTap);
                    if (overlay && state.__onTap) overlay.removeEventListener("pointerdown", state.__onTap);
                } catch(e){}

                state.__keysBound = false;
                state.__resizeBound = false;
                state.__docTouchBound = false;
                state.__docPtrBound = false;
                state.__tapBound = false;

                try {
                    state.obstacles.length = 0;
                    state.coins.length = 0;
                    state.enemies.length = 0;
                    state.particles.length = 0;
                    state.stripes.length = 0;
                } catch(e){}
try { _musicStop(); } catch(e){}
// restaura actionEnter original
                if (state.hooked && state.origActionEnter && typeof window !== "undefined") {
                    try { window.actionEnter = state.origActionEnter; } catch(e) {}
                    state.hooked = false;
                }
                // restaura controles do console
                try {
                    const mc = document.getElementById("mobile-controls");
                    if (mc) mc.style.display = (state.mcPrevDisplay ?? "");
                } catch(e) {}
                // esconde touch UI
                try { _setTouchUI(false); } catch(e) {}
            }
        };
    })();
function startDinoFromConsole() { __DINO_RUN__.startFromConsole(); }

        // Sobrescreve closeGame para também parar o Dino nativo
        function closeGame() {
            // 1) Para o minigame nativo (se estiver rodando)
            try { __DINO_RUN__.stop(); } catch(e){}

            // 2) Fecha runtime de jogo + reseta iframe + reseta modo "nova aba"
            try{
                const rt = document.getElementById('game-runtime');
                const gf = document.getElementById('game-frame');
                const ext = document.getElementById('external-runtime');

                // garante que o overlay de "Abrindo em nova aba" não fique preso
                try { if (ext) ext.style.display = "none"; } catch(e){}

                // fecha popup externo (quando site bloqueia iframe)
                try { if (typeof __popupWin !== 'undefined' && __popupWin && !__popupWin.closed) __popupWin.close(); } catch(e){}
                try { __popupWin = null; } catch(e){}
                try { __externalUrl = null; } catch(e){}

                // reseta iframe
                try { if (gf) { gf.src = ""; gf.style.display = "block"; } } catch(e){}

                // esconde container do Dino (caso tenha ficado visível)
                try { const dinoCont = document.getElementById('dino-game-container'); if (dinoCont) dinoCont.style.display = 'none'; } catch(e){}

                try { if (rt) rt.style.display = "none"; } catch(e){}

                // timers/economia
                try { clearInterval(playTimerInterval); } catch(e){}
                try { sessionSeconds = 0; } catch(e){}
                try { saveEconomy(); } catch(e){}
                try { forceFullscreen(); } catch(e){}
            }catch(e){}
        }




        // =========================
        // CLOUD MEMORY (JSONBin) — contas e vínculo entre consoles
        // =========================
        let cloudCfg = (() => {
            try { return JSON.parse(localStorage.getItem('xs_cloud_cfg') || 'null') || { apiKey:'', binId:'' }; }
            catch(e){ return { apiKey:'', binId:'' }; }
        })();
        let cloudUser = localStorage.getItem('xs_cloud_user') || '';

        function cloudNorm(u){ return (u||'').trim().toLowerCase(); }
        function openCloudModal(){
            try{
                document.getElementById('cloudApiKey').value = cloudCfg.apiKey || '';
                document.getElementById('cloudBinId').value = cloudCfg.binId || '';
                cloudSwitchTab('create');
                openModal('cloud-modal');
                playSysSound(520, 'sine', 0.08);
            }catch(e){}
        }

        function cloudSwitchTab(which){
            const c = document.getElementById('cloudTabCreate');
            const l = document.getElementById('cloudTabLink');
            const pc = document.getElementById('cloudPaneCreate');
            const pl = document.getElementById('cloudPaneLink');
            if(which === 'link'){
                c.classList.remove('active'); l.classList.add('active');
                pc.style.display='none'; pl.style.display='block';
            } else {
                l.classList.remove('active'); c.classList.add('active');
                pl.style.display='none'; pc.style.display='block';
            }
        }

        function cloudSaveConfig(){
            const apiKey = (document.getElementById('cloudApiKey').value||'').trim();
            const binId  = (document.getElementById('cloudBinId').value||'').trim();
            cloudCfg = { apiKey, binId };
            localStorage.setItem('xs_cloud_cfg', JSON.stringify(cloudCfg));
            showToast('CLOUD', 'Config salva no console', null, 'cloud_done');
            playSysSound(660,'sine',0.06);
        }

        async function cloudSha256Hex(str){
            const enc = new TextEncoder().encode(str);
            const buf = await crypto.subtle.digest('SHA-256', enc);
            return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
        }
        async function cloudPassHash(u,p){
            // pepper simples pra não ficar trivial
            return await cloudSha256Hex(`${u}::${p}::XS_CLOUD_V1_PEPPER`);
        }

        function cloudSnapshot(){
            const kv = {};
            try{
                Object.keys(localStorage).forEach(k=>{
                    if(!k || !k.startsWith('xs_')) return;
                    if(k === 'xs_cloud_cfg' || k === 'xs_cloud_user') return;
                    kv[k] = localStorage.getItem(k);
                });
            }catch(e){}
            return { v:1, ts: Date.now(), kv };
        }
        function cloudApplySnapshot(snap){
            if(!snap || !snap.kv) throw new Error('snapshot inválido');
            // remove chaves xs_ atuais (menos config cloud)
            Object.keys(localStorage).forEach(k=>{
                if(k && k.startsWith('xs_') && k !== 'xs_cloud_cfg') localStorage.removeItem(k);
            });
            Object.entries(snap.kv).forEach(([k,v])=>{
                if(k && k.startsWith('xs_')) localStorage.setItem(k, v);
            });
        }

        function cloudHeaders(extra={}){
            if(!cloudCfg.apiKey) throw new Error('Sem API Key');
            return Object.assign({ 'X-Master-Key': cloudCfg.apiKey }, extra);
        }

        async function cloudGetDb(){
            if(!cloudCfg.binId) throw new Error('Sem Bin ID');
            const url = `https://api.jsonbin.io/v3/b/${cloudCfg.binId}/latest?meta=false`;
            const r = await fetch(url, { method:'GET', headers: cloudHeaders() });
            if(!r.ok) throw new Error('Falha ao ler banco (verifique API Key/Bin ID)');
            return await r.json();
        }
        async function cloudPutDb(db){
            if(!cloudCfg.binId) throw new Error('Sem Bin ID');
            const url = `https://api.jsonbin.io/v3/b/${cloudCfg.binId}`;
            const r = await fetch(url, {
                method:'PUT',
                headers: cloudHeaders({ 'Content-Type':'application/json', 'X-Bin-Versioning':'false' }),
                body: JSON.stringify(db)
            });
            if(!r.ok) throw new Error('Falha ao salvar banco');
            return await r.json();
        }

        async function cloudCreateDb(){
            try{
                const apiKey = (document.getElementById('cloudApiKey').value||'').trim();
                cloudCfg.apiKey = apiKey;
                if(!cloudCfg.apiKey){ showToast('CLOUD','Cole sua API Key primeiro', null, 'warning'); return; }

                const url = 'https://api.jsonbin.io/v3/b';
                const body = { schema:'xs_cloud_v1', users:{} };
                const r = await fetch(url, {
                    method:'POST',
                    headers: { 'Content-Type':'application/json', 'X-Master-Key': cloudCfg.apiKey, 'X-Bin-Private':'true', 'X-Bin-Name':'XUXUBISTATION Cloud' },
                    body: JSON.stringify(body)
                });
                if(!r.ok) throw new Error('Não consegui criar o banco');
                const j = await r.json();
                const id = (j && j.metadata && j.metadata.id) ? j.metadata.id : '';
                if(!id) throw new Error('Sem Bin ID na resposta');
                cloudCfg.binId = id;
                localStorage.setItem('xs_cloud_cfg', JSON.stringify(cloudCfg));
                document.getElementById('cloudBinId').value = id;
                showToast('CLOUD', 'Banco criado! (Bin ID salvo)', null, 'cloud');
                playSysSound(740,'sine',0.08);
            }catch(e){
                showToast('CLOUD', e.message || 'erro', null, 'error');
            }
        }

        async function cloudCreateAccount(){
            try{
                cloudSaveConfig(); // pega campos atuais
                const u = cloudNorm(document.getElementById('cloudUserCreate').value);
                const p = (document.getElementById('cloudPassCreate').value||'').trim();
                if(!u || !p){ showToast('CLOUD','Preencha usuário e senha', null, 'warning'); return; }
                if(!cloudCfg.apiKey){ showToast('CLOUD','Cole sua API Key', null, 'warning'); return; }
                if(!cloudCfg.binId){
                    await cloudCreateDb();
                    if(!cloudCfg.binId) return;
                }

                const db = await cloudGetDb().catch(()=>({ schema:'xs_cloud_v1', users:{} }));
                if(!db.users) db.users = {};
                if(db.users[u]){ showToast('CLOUD','Usuário já existe', null, 'warning'); return; }

                const passHash = await cloudPassHash(u,p);
                db.schema = db.schema || 'xs_cloud_v1';
                db.users[u] = {
                    passHash,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    state: cloudSnapshot()
                };

                await cloudPutDb(db);
                cloudUser = u;
                localStorage.setItem('xs_cloud_user', cloudUser);
                showToast('CLOUD', 'Conta criada e vinculada!', null, 'verified_user');
                playSysSound(880,'sine',0.08);
                closeModal('cloud-modal');
            }catch(e){
                showToast('CLOUD', e.message || 'erro', null, 'error');
            }
        }

        async function cloudLinkAccount(){
            try{
                cloudSaveConfig();
                const u = cloudNorm(document.getElementById('cloudUserLink').value);
                const p = (document.getElementById('cloudPassLink').value||'').trim();
                if(!u || !p){ showToast('CLOUD','Preencha usuário e senha', null, 'warning'); return; }
                if(!cloudCfg.apiKey || !cloudCfg.binId){ showToast('CLOUD','Cole API Key e Bin ID', null, 'warning'); return; }

                const db = await cloudGetDb();
                if(!db.users || !db.users[u]){ showToast('CLOUD','Conta não encontrada', null, 'error'); return; }
                const passHash = await cloudPassHash(u,p);
                if(db.users[u].passHash !== passHash){ showToast('CLOUD','Senha incorreta', null, 'error'); return; }

                cloudUser = u;
                localStorage.setItem('xs_cloud_user', cloudUser);

                const snap = db.users[u].state;
                cloudApplySnapshot(snap);

                showToast('CLOUD', 'Vinculado! Reiniciando com seu save...', null, 'cloud_done');
                playSysSound(920,'sine',0.09);
                setTimeout(()=>location.reload(), 700);
            }catch(e){
                showToast('CLOUD', e.message || 'erro', null, 'error');
            }
        }

        async function cloudPullNow(){
            try{
                cloudSaveConfig();
                if(!cloudCfg.apiKey || !cloudCfg.binId){ showToast('CLOUD','Cole API Key e Bin ID', null, 'warning'); return; }
                if(!cloudUser){ showToast('CLOUD','Nenhuma conta cloud logada', null, 'warning'); return; }
                const db = await cloudGetDb();
                if(!db.users || !db.users[cloudUser]){ showToast('CLOUD','Conta não encontrada no banco', null, 'error'); return; }
                const snap = db.users[cloudUser].state;
                cloudApplySnapshot(snap);
                showToast('CLOUD', 'Baixado! Reiniciando...', null, 'download_done');
                setTimeout(()=>location.reload(), 650);
            }catch(e){
                showToast('CLOUD', e.message || 'erro', null, 'error');
            }
        }

        async function cloudPushNow(){
            if(!cloudUser) return;
            if(!cloudCfg.apiKey || !cloudCfg.binId) return;
            try{
                const db = await cloudGetDb();
                if(!db.users) db.users = {};
                if(!db.users[cloudUser]) return;
                db.users[cloudUser].state = cloudSnapshot();
                db.users[cloudUser].updatedAt = new Date().toISOString();
                await cloudPutDb(db);
            }catch(e){}
        }

        let __cloudPushT = null;
        function cloudQueuePush(){
            if(!cloudUser) return;
            if(!cloudCfg.apiKey || !cloudCfg.binId) return;
            clearTimeout(__cloudPushT);
            __cloudPushT = setTimeout(()=>cloudPushNow(), 1200);
        }

        function cloudLogout(){
            cloudUser = '';
            localStorage.removeItem('xs_cloud_user');
            showToast('CLOUD', 'Saiu da conta', null, 'logout');
            playSysSound(360,'sine',0.06);
        }

        // Hook: sempre que salvar economia/config/perfil, manda pro cloud (se logado)
        (function(){
            try{
                const __se = saveEconomy;
                saveEconomy = function(){ __se(); cloudQueuePush(); };
            }catch(e){}
            try{
                const __ss = saveSettings;
                saveSettings = function(){ __ss(); cloudQueuePush(); };
            }catch(e){}
            try{
                const __sp = saveProfile;
                saveProfile = function(){ __sp(); cloudQueuePush(); };
            }catch(e){}
        })();


// ===========================
//  XS MEMORY CARD OFFLINE (.xsb)
//  - Exporta/importa saves sem internet
// ===========================
const __XS_MEM_HEADER_V1__ = "XUXUBISTATION_XS_MEMORYCARD_V1";
const __XS_MEM_HEADER_V2__ = "XUXUBISTATION_XS_MEMORYCARD_V2";

/* =========================
   XS MEMORY CARD V2
   - Checksum (CRC32) + assinatura
   - Versão + migração (V1 -> V2)
   - Exportar por perfil (com opção Console Completo)
   - Resumo + confirmação antes de importar
   ========================= */

function __xsSafeJSONParse__(txt, fallback){
    try { return JSON.parse(String(txt)); } catch(e){ return fallback; }
}

function __xsB64Encode__(str){
    try { return btoa(unescape(encodeURIComponent(String(str)))); }
    catch(e){ try { return btoa(String(str)); } catch(e2){ return ""; } }
}
function __xsB64Decode__(b64){
    const s = atob(String(b64||""));
    try { return decodeURIComponent(escape(s)); }
    catch(e){ return s; }
}

// CRC32 (assinatura simples e offline-friendly)
function __xsCrc32__(str){
    let crc = 0 ^ (-1);
    for (let i = 0; i < str.length; i++){
        crc = (crc >>> 8) ^ __xsCrcTable__[(crc ^ str.charCodeAt(i)) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
}
const __xsCrcTable__ = (function(){
    const table = new Uint32Array(256);
    for (let n = 0; n < 256; n++){
        let c = n;
        for (let k = 0; k < 8; k++){
            c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
        }
        table[n] = c >>> 0;
    }
    return table;
})();

function __xsHex8__(num){
    return ("00000000" + (num >>> 0).toString(16)).slice(-8).toUpperCase();
}

function __xsNowStamp__(){
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,"0");
    return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
}

function __xsSanitizeFilePart__(s){
    return String(s||"")
        .replace(/[^\w\-]+/g, "_")
        .replace(/_+/g, "_")
        .replace(/^_+|_+$/g, "")
        .slice(0, 28) || "XS";
}

function __xsGetProfiles__(){
    if (typeof profiles !== "undefined" && Array.isArray(profiles)) return profiles;
    return __xsSafeJSONParse__(localStorage.getItem("xs_profiles")||"[]", []);
}

function __xsGetSnapshot__(){
    // tenta salvar o estado atual, se existirem funções já no console
    try { if (typeof saveEconomy === "function") saveEconomy(); } catch(e) {}
    try { if (typeof saveSettings === "function") saveSettings(); } catch(e) {}

    const snap = {
        profiles: (typeof profiles !== "undefined") ? profiles : __xsSafeJSONParse__(localStorage.getItem("xs_profiles")||"[]", []),
        userCoins: (typeof userCoins !== "undefined") ? userCoins : parseInt(localStorage.getItem("xs_coins")||"0",10),
        systemSettings: (typeof systemSettings !== "undefined") ? systemSettings : __xsSafeJSONParse__(localStorage.getItem("xs_settings")||"{}", {}),
        sideloadedGames: (typeof sideloadedGames !== "undefined") ? sideloadedGames : __xsSafeJSONParse__(localStorage.getItem("xs_sideloads")||"[]", []),
        purchasedItems: (typeof purchasedItems !== "undefined") ? purchasedItems : __xsSafeJSONParse__(localStorage.getItem("xs_purchased")||"[]", []),
        achievements: (typeof achievements !== "undefined") ? achievements : __xsSafeJSONParse__(localStorage.getItem("xs_achievements")||"[]", []),
        stats: (typeof stats !== "undefined") ? stats : __xsSafeJSONParse__(localStorage.getItem("xs_stats")||"{}", {}),
        playTime: (typeof playTime !== "undefined") ? playTime : parseInt(localStorage.getItem("xs_playtime")||"0",10),
        ytPlaylist: (typeof ytPlaylist !== "undefined") ? ytPlaylist : __xsSafeJSONParse__(localStorage.getItem("xs_ytPlaylist")||"[]", []),
    };

    return snap;
}

function __xsBuildMem__(opts){
    const snap = __xsGetSnapshot__();
    const allProfiles = Array.isArray(snap.profiles) ? snap.profiles : [];
    const profileIndex = (opts && Number.isFinite(opts.profileIndex)) ? (opts.profileIndex|0) : null;
    const exportAll = !!(opts && opts.exportAll);

    let chosenProfile = null;
    let outProfiles = allProfiles;

    if (!exportAll && profileIndex !== null && allProfiles[profileIndex]){
        chosenProfile = allProfiles[profileIndex];
        outProfiles = [ chosenProfile ];
    }

    const mem = {
        profiles: outProfiles,
        userCoins: snap.userCoins,
        systemSettings: snap.systemSettings,
        sideloadedGames: snap.sideloadedGames,
        purchasedItems: snap.purchasedItems,
        achievements: snap.achievements,
        stats: snap.stats,
        playTime: snap.playTime,
        ytPlaylist: snap.ytPlaylist,
        meta: {
            v: 2,
            header: __XS_MEM_HEADER_V2__,
            exportedAt: Date.now(),
            exportedAtISO: new Date().toISOString(),
            profileOnly: !exportAll,
            profileIndex: (!exportAll && profileIndex !== null) ? profileIndex : null,
            profileName: chosenProfile && chosenProfile.name ? String(chosenProfile.name) : (exportAll ? "CONSOLE_COMPLETO" : null),
            profilesExported: Array.isArray(outProfiles) ? outProfiles.length : 0,
        }
    };

    return mem;
}

function __xsBuildFileText__(mem){
    const payloadStr = JSON.stringify(mem);
    const payloadB64 = __xsB64Encode__(payloadStr);
    const crc = __xsHex8__(__xsCrc32__(payloadB64));
    // Formato V2:
    // 1) HEADER
    // 2) BASE64(JSON)
    // 3) CRC32(BASE64)
    return __XS_MEM_HEADER_V2__ + "\n" + payloadB64 + "\n" + crc;
}

function __xsDownloadText__(content, filename){
    const blob = new Blob([content], { type: "application/octet-stream" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ try{ URL.revokeObjectURL(a.href); }catch(e){} try{ a.remove(); }catch(e){} }, 0);
}

function __xsOpenExportModal__(){
    const list = document.getElementById("xs-memory-export-list");
    if (!list) {
        // fallback: export console completo direto
        __xsExportNow__({ exportAll:true });
        return;
    }

    list.innerHTML = "";
    const ps = __xsGetProfiles__();
    const btnStylePrimary = 'width:100%; background:rgba(0,229,255,0.14); border:1px solid rgba(0,229,255,0.35);';
    const btnStyleNormal  = 'width:100%; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.18);';

    // Console completo
    const allBtn = document.createElement("button");
    allBtn.className = "game-btn";
    allBtn.setAttribute("style", btnStylePrimary);
    allBtn.innerHTML = '<span class="material-icons" style="vertical-align:middle; margin-right:8px;">inventory_2</span>CONSOLE COMPLETO (TODOS PERFIS)';
    allBtn.onclick = ()=> __xsExportNow__({ exportAll:true });
    list.appendChild(allBtn);

    // Perfis
    if (Array.isArray(ps) && ps.length){
        ps.forEach((p, idx)=>{
            const b = document.createElement("button");
            b.className = "game-btn";
            b.setAttribute("style", btnStyleNormal);
            const n = (p && p.name) ? p.name : ("Perfil " + (idx+1));
            b.innerHTML = `<span class="material-icons" style="vertical-align:middle; margin-right:8px;">person</span>PERFIL: ${String(n).replace(/</g,"&lt;")}`;
            b.onclick = ()=> __xsExportNow__({ profileIndex: idx, exportAll:false });
            list.appendChild(b);
        });
    } else {
        const empty = document.createElement("div");
        empty.style.color = "#aaa";
        empty.style.fontSize = "0.85rem";
        empty.style.lineHeight = "1.35";
        empty.innerHTML = "Nenhum perfil encontrado. Você pode criar um usuário e tentar novamente.";
        list.appendChild(empty);
    }

    try { playSysSound(660, "square", 0.10); } catch(e) {}
    openModal("xs-memory-export-modal");
}

// Função pública (botões chamam isso)
function exportXSMemory(){
    // Export por perfil (com opção de console completo)
    __xsOpenExportModal__();
}

// Realiza exportação
function __xsExportNow__(opts){
    try { closeModal("xs-memory-export-modal"); } catch(e) {}
    try { closeModal("create-modal"); } catch(e) {}

    try{
        const mem = __xsBuildMem__(opts || {});
        const profName = mem && mem.meta && mem.meta.profileName ? mem.meta.profileName : "CONSOLE";
        const filename = `XUXUBISTATION_XS_${__xsSanitizeFilePart__(profName)}_${__xsNowStamp__()}.xsb`;
        const content = __xsBuildFileText__(mem);

        __xsDownloadText__(content, filename);

        try { showToast("MEMORY CARD", "Memory Card gravado!", filename, "save"); } catch(e) {}
        try { playSysSound(880, "square", 0.18); } catch(e) {}
    }catch(err){
        try { showToast("MEMORY CARD", "Falha ao gravar", String(err && err.message ? err.message : err), "error"); } catch(e) {}
        try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
    }
}

// ===== Importação com resumo/confirm =====
let __xsPendingImport__ = null;
let __xsPendingImportInput__ = null;

function __xsFmtDate__(ms){
    try {
        const d = new Date(ms);
        if (!isFinite(d.getTime())) return "-";
        return d.toLocaleString();
    } catch(e){ return "-"; }
}

function __xsCount__(v){
    if (!v) return 0;
    if (Array.isArray(v)) return v.length;
    if (typeof v === "object") return Object.keys(v).length;
    return 1;
}

function __xsOpenImportSummary__(mem, inputEl){
    __xsPendingImport__ = mem || null;
    __xsPendingImportInput__ = inputEl || null;

    const box = document.getElementById("xs-memory-import-summary");
    if (box){
        const profNames = (mem && Array.isArray(mem.profiles)) ? mem.profiles.map(p=> (p && p.name) ? p.name : "Perfil").slice(0,4) : [];
        const profLabel = profNames.length ? profNames.join(", ") + (mem.profiles.length > 4 ? "..." : "") : "Nenhum";

        const exportedAt = (mem && mem.meta && mem.meta.exportedAt) ? __xsFmtDate__(mem.meta.exportedAt) : "-";
        const ver = (mem && mem.meta && mem.meta.v) ? mem.meta.v : (mem && mem.meta && mem.meta.version) ? mem.meta.version : "?";

        box.innerHTML = `
            <div style="margin-bottom:8px; color:#aaa; font-size:0.82rem;">Resumo do arquivo:</div>
            <div style="display:grid; grid-template-columns: 1fr; gap:6px;">
                <div><b>Versão:</b> V${ver}</div>
                <div><b>Exportado em:</b> ${exportedAt}</div>
                <div><b>Perfis:</b> ${__xsCount__(mem.profiles)} (${profLabel})</div>
                <div><b>XC (Coins):</b> ${Number(mem.userCoins||0) | 0}</div>
                <div><b>Itens comprados:</b> ${__xsCount__(mem.purchasedItems)}</div>
                <div><b>Achievements:</b> ${__xsCount__(mem.achievements)}</div>
                <div><b>Jogos sideload:</b> ${__xsCount__(mem.sideloadedGames)}</div>
                <div><b>PlayTime:</b> ${Number(mem.playTime||0) | 0} s</div>
                <div><b>YT Playlist:</b> ${__xsCount__(mem.ytPlaylist)}</div>
            </div>
        `;
    }

    try { playSysSound(520, "square", 0.10); } catch(e) {}
    openModal("xs-memory-import-modal");
}

function __xsCancelImport__(){
    try { closeModal("xs-memory-import-modal"); } catch(e) {}
    __xsPendingImport__ = null;
    try { if (__xsPendingImportInput__) __xsPendingImportInput__.value = ""; } catch(e) {}
    __xsPendingImportInput__ = null;
    try { showToast("MEMORY CARD", "Importação cancelada", null, "info"); } catch(e) {}
    try { playSysSound(520, "square", 0.10); } catch(e) {}
}

function __xsWriteLocalStorageFromMem__(mem){
    // backup de emergência (não é download, é interno)
    try{
        const backupMem = __xsBuildMem__({ exportAll:true });
        const backupText = __xsBuildFileText__(backupMem);
        localStorage.setItem("xs_memory_backup_v2", backupText);
    }catch(e){}

    localStorage.setItem("xs_profiles", JSON.stringify(mem.profiles || []));
    localStorage.setItem("xs_coins", String((mem.userCoins|0) || 0));
    localStorage.setItem("xs_settings", JSON.stringify(mem.systemSettings || {}));
    localStorage.setItem("xs_sideloads", JSON.stringify(mem.sideloadedGames || []));
    localStorage.setItem("xs_purchased", JSON.stringify(mem.purchasedItems || []));
    localStorage.setItem("xs_achievements", JSON.stringify(mem.achievements || []));
    localStorage.setItem("xs_stats", JSON.stringify(mem.stats || {}));
    localStorage.setItem("xs_playtime", String((mem.playTime|0) || 0));

    localStorage.setItem("xs_ytPlaylist", JSON.stringify(mem.ytPlaylist || []));
}

function __xsConfirmImport__(){
    try{
        const mem = __xsPendingImport__;
        if (!mem) {
            try { showToast("MEMORY CARD", "Nada para importar", null, "error"); } catch(e) {}
            try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
            return;
        }

        __xsWriteLocalStorageFromMem__(mem);

        try { showToast("MEMORY CARD", "Memory Card importado!", "Reiniciando...", "system_update_alt"); } catch(e) {}
        try { playSysSound(880, "square", 0.18); } catch(e) {}

        try { if (__xsPendingImportInput__) __xsPendingImportInput__.value = ""; } catch(e) {}
        __xsPendingImportInput__ = null;
        __xsPendingImport__ = null;

        try { closeModal("xs-memory-import-modal"); } catch(e) {}
        setTimeout(()=>{ try { location.reload(); } catch(e) {} }, 250);
    }catch(err){
        try { showToast("MEMORY CARD", "Falha ao importar", String(err && err.message ? err.message : err), "error"); } catch(e) {}
        try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
        try { if (__xsPendingImportInput__) __xsPendingImportInput__.value = ""; } catch(e) {}
        __xsPendingImportInput__ = null;
        __xsPendingImport__ = null;
        try { closeModal("xs-memory-import-modal"); } catch(e) {}
    }
}

// Função pública (input file onchange chama isso)
function importXSMemory(event){
    const input = event && event.target;
    const file = input && input.files && input.files[0] ? input.files[0] : null;
    if (!file) return;

    const reader = new FileReader();
    reader.onerror = () => {
        try { showToast("MEMORY CARD", "Falha ao ler o arquivo", null, "error"); } catch(e) {}
        try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
        try { if (input) input.value = ""; } catch(e) {}
    };

    reader.onload = () => {
        try{
            const text = String(reader.result || "").replace(/\r\n/g, "\n").trim();
            const lines = text.split("\n").filter(Boolean);

            if (lines.length < 2){
                try { showToast("MEMORY CARD", "Arquivo inválido", "Formato incompleto", "error"); } catch(e) {}
                try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
                try { if (input) input.value = ""; } catch(e) {}
                return;
            }

            const header = String(lines[0] || "").trim();
            let payloadB64 = String(lines[1] || "").trim();
            let mem = null;

            if (header === __XS_MEM_HEADER_V2__){
                // valida checksum
                if (lines.length < 3){
                    try { showToast("MEMORY CARD", "Arquivo V2 inválido", "Faltando assinatura (CRC)", "error"); } catch(e) {}
                    try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
                    try { if (input) input.value = ""; } catch(e) {}
                    return;
                }
                const crcFile = String(lines[2]||"").trim().toUpperCase();
                const crcCalc = __xsHex8__(__xsCrc32__(payloadB64));
                if (crcFile !== crcCalc){
                    try { showToast("MEMORY CARD", "Assinatura inválida", "Arquivo corrompido ou alterado", "error"); } catch(e) {}
                    try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
                    try { if (input) input.value = ""; } catch(e) {}
                    return;
                }
                const jsonStr = __xsB64Decode__(payloadB64);
                mem = __xsSafeJSONParse__(jsonStr, null);
                if (!mem || typeof mem !== "object"){
                    try { showToast("MEMORY CARD", "Falha ao decodificar", "JSON inválido", "error"); } catch(e) {}
                    try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
                    try { if (input) input.value = ""; } catch(e) {}
                    return;
                }
                // garante meta
                mem.meta = mem.meta || {};
                mem.meta.v = mem.meta.v || 2;
            } else if (header === __XS_MEM_HEADER_V1__){
                // Migração V1 -> V2 (sem checksum)
                const jsonStr = __xsB64Decode__(payloadB64);
                mem = __xsSafeJSONParse__(jsonStr, null);
                if (!mem || typeof mem !== "object"){
                    try { showToast("MEMORY CARD", "Falha ao decodificar", "JSON inválido (V1)", "error"); } catch(e) {}
                    try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
                    try { if (input) input.value = ""; } catch(e) {}
                    return;
                }
                mem.meta = mem.meta || {};
                mem.meta.v = 1;
                mem.meta.migratedTo = 2;
                mem.meta.migratedAt = Date.now();
            } else {
                try { showToast("MEMORY CARD", "Cabeçalho inválido", header || "desconhecido", "error"); } catch(e) {}
                try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
                try { if (input) input.value = ""; } catch(e) {}
                return;
            }

            // validações mínimas (mantém tolerante)
            mem.profiles = Array.isArray(mem.profiles) ? mem.profiles : [];
            mem.userCoins = Number(mem.userCoins || 0) | 0;
            mem.playTime = Number(mem.playTime || 0) | 0;
            mem.systemSettings = (mem.systemSettings && typeof mem.systemSettings === "object") ? mem.systemSettings : {};
            mem.sideloadedGames = Array.isArray(mem.sideloadedGames) ? mem.sideloadedGames : [];
            mem.purchasedItems = Array.isArray(mem.purchasedItems) ? mem.purchasedItems : [];
            mem.achievements = Array.isArray(mem.achievements) ? mem.achievements : [];
            mem.stats = (mem.stats && typeof mem.stats === "object") ? mem.stats : {};

            // Abre resumo + confirmação
            __xsOpenImportSummary__(mem, input);
        }catch(err){
            try { showToast("MEMORY CARD", "Falha ao importar", String(err && err.message ? err.message : err), "error"); } catch(e) {}
            try { playSysSound(140, "sawtooth", 0.20); } catch(e) {}
            try { if (input) input.value = ""; } catch(e) {}
        }
    };

    reader.readAsText(file);
}


</script>


<div id="dino-coin-stream" style="position:fixed; inset:0; pointer-events:none; z-index:99999; overflow:hidden;"></div>

    <div id="jukebox-modal" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-header">
                <h2>JUKEBOX</h2>
                <button class="game-btn" onclick="closeModal('jukebox-modal')">X</button>
            </div>
            <div class="jb2-wrap">
                <div class="jb2-top">
                    <div class="jb2-now">
                        <div class="jb2-label">TOCANDO AGORA</div>
                        <div id="jb2Title" class="jb2-title">—</div>
                        <div id="jb2Sub" class="jb2-sub">Escolha uma música na lista ou use os botões.</div>
                    </div>
                    <div class="jb2-controls">
                        <button class="jb2-btn" id="jb2Prev" title="Anterior">⟨</button>
                        <button class="jb2-btn main" id="jb2Play" title="Play/Pause">▶</button>
                        <button class="jb2-btn" id="jb2Next" title="Próxima">⟩</button>
                        <div class="jb2-vol" title="Volume da música">
                            <span class="material-icons" style="font-size:20px; opacity:0.9;">volume_up</span>
                            <input id="jb2Vol" type="range" min="0" max="1" step="0.01" value="0.55">
                            <span id="jb2VolTxt" style="font-size:0.85rem; color:#ddd; min-width:42px; text-align:right;">55%</span>
                        </div>
                    </div>
                </div>

                <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:2px; flex-wrap:wrap;">
                    <div style="font-size:0.78rem; color:#9aa;">Músicas curtas em loop (menos grave, mais clareza).</div>
                    <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
                        <button class="game-btn xs-music-open" id="xsOpenMusicBrowserBtn"><span class="material-icons" style="vertical-align:middle; margin-right:8px;">library_music</span>ABRIR PLAYER DE MÚSICA</button>
<button class="game-btn" id="jb2Random">Aleatória</button>
                    </div>
                </div>

                <div id="jb2List" class="jb2-list"></div>
            </div>
        </div>
    </div>
</div>

    <!-- XS Music Browser (Ouvirmusica) -->
    <div id="xs-music-browser" aria-hidden="true">
        <div class="xs-music-window" role="dialog" aria-modal="true" aria-label="Player de Música">
            <div class="xs-music-bar">
                <div class="xs-music-title">
                    <span class="material-icons" style="font-size:20px;">library_music</span>
                    <span>PLAYER DE MÚSICA</span>
                </div>
                <div class="xs-music-viewtoggle" id="xsMusicViewToggle" title="Visual do player">
                    <button type="button" id="xsMusicViewPortrait">Vertical</button>
                    <button type="button" id="xsMusicViewLandscape">Horizontal</button>
                </div>
                <div class="xs-music-actions">
                    <button class="game-btn" id="xsMusicMinBtn"><span class="material-icons" style="vertical-align:middle; margin-right:6px;">remove</span>MINIMIZAR</button>
                    <button class="game-btn" id="xsMusicCloseBtn" style="background:rgba(255,60,60,0.18); border:1px solid rgba(255,60,60,0.35);">
                        <span class="material-icons" style="vertical-align:middle; margin-right:6px;">stop_circle</span>PARAR E FECHAR
                    </button>
                </div>
            </div>
            <div class="xs-music-frameSlot" id="xsMusicFrameSlot">
                <iframe id="xsMusicFrame" src="https://www.ouvirmusica.com.br/" title="Ouvirmusica"
                    referrerpolicy="no-referrer"
                    allow="autoplay; encrypted-media; clipboard-read; clipboard-write; fullscreen"
                    loading="eager" allowfullscreen></iframe>
            </div>
        </div>
    </div>


<script>
/* =========================
   XS MUSIC BROWSER (binder)
   - Evita sobrescrever funções já existentes
   ========================= */
(function(){
  if (window.__xsMusicBrowserBinder__) return;
  window.__xsMusicBrowserBinder__ = true;

  function bindOnce(el, ev, fn){
    if(!el) return;
    const k = "xsBound_" + ev;
    try{ if(el.dataset && el.dataset[k]) return; }catch(e){}
    el.addEventListener(ev, fn, {passive:true});
    try{ if(el.dataset) el.dataset[k] = "1"; }catch(e){}
  }

  window.addEventListener("DOMContentLoaded", ()=>{
    const openBtn = document.getElementById("xsOpenMusicBrowserBtn");
    const minBtn = document.getElementById("xsMusicMinBtn");
    const closeBtn = document.getElementById("xsMusicCloseBtn");

    bindOnce(openBtn, "click", ()=>{ try{ window.xsOpenMusicBrowser && window.xsOpenMusicBrowser(); }catch(e){} });
    bindOnce(minBtn, "click", ()=>{ try{ window.xsMinimizeMusicBrowser && window.xsMinimizeMusicBrowser(); }catch(e){} });
    bindOnce(closeBtn, "click", ()=>{ try{ window.xsStopAndCloseMusicBrowser && window.xsStopAndCloseMusicBrowser(); }catch(e){} });
  });
})();
</script>


<script>
/* =========================
   XS Responsive Kernel (Device Detection)
   - Global: window.isMobile (boolean)
   - Classes on <html>: xs-mobile / xs-desktop / xs-gamepad
   ========================= */
(function(){
  const root = document.documentElement;

  // Global flags
  window.isMobile = false;
  window.xsHasGamepad = false;

  function uaLooksMobile(ua){
    ua = (ua || "").toLowerCase();
    return /(android|iphone|ipad|ipod|iemobile|blackberry|opera mini|webos)/i.test(ua);
  }

  function computeIsMobile(){
    const widthMobile = window.innerWidth < 900;
    const uaMobile = uaLooksMobile(navigator.userAgent);
    return { isMobile: (widthMobile || uaMobile), widthMobile, uaMobile };
  }

  // ---- Device Toast ----
  let toastTimer = null;
  function showDeviceToast(force){
    const t = document.getElementById("device-toast");
    if(!t) return;

    const icon = document.getElementById("device-toast-icon");
    const msg = document.getElementById("device-toast-msg");

    const modeLabel = window.isMobile ? "CELULAR" : "PC";
    const gpLabel = window.xsHasGamepad ? " + GAMEPAD" : "";

    if(icon) icon.textContent = window.isMobile ? "smartphone" : "computer";
    if(msg) msg.textContent = "MODO: " + modeLabel + gpLabel;

    // show
    t.classList.add("show");
    if(toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(()=> t.classList.remove("show"), force ? 2600 : 1900);
  }

  // ---- Sysbar widgets ----
  function pad2(n){ return String(n).padStart(2,'0'); }
  function updateClock(){
    const el = document.getElementById("xsClock");
    if(!el) return;
    const d = new Date();
    el.textContent = pad2(d.getHours()) + ":" + pad2(d.getMinutes()) + ":" + pad2(d.getSeconds());
  }

  // Battery
  let bat = null;
  function renderBattery(){
    const el = document.getElementById("xsBat");
    const ic = document.getElementById("xsBatIcon");
    if(!el) return;

    if(!bat){
      el.textContent = "--%";
      if(ic) ic.textContent = "battery_unknown";
      return;
    }

    const pct = Math.round((bat.level || 0) * 100);
    el.textContent = pct + "%";

    if(ic){
      if(bat.charging) ic.textContent = "battery_charging_full";
      else if(pct <= 15) ic.textContent = "battery_alert";
      else if(pct <= 35) ic.textContent = "battery_3_bar";
      else if(pct <= 60) ic.textContent = "battery_5_bar";
      else if(pct <= 85) ic.textContent = "battery_6_bar";
      else ic.textContent = "battery_full";
    }
  }

  async function initBattery(){
    try{
      if(!navigator.getBattery) return;
      bat = await navigator.getBattery();
      renderBattery();
      bat.addEventListener("levelchange", renderBattery);
      bat.addEventListener("chargingchange", renderBattery);
    }catch(e){}
  }

  // XP (best-effort)
  function getXPValue(){
    try{
      // Prefer profile XP if exists
      const au = window.activeUser;
      const profiles = window.profiles;
      if(typeof au === "number" && Array.isArray(profiles) && profiles[au] && typeof profiles[au].xp === "number"){
        return profiles[au].xp;
      }
    }catch(e){}
    try{
      // fallback: use coins as "progress"
      if(typeof window.userCoins === "number") return window.userCoins;
    }catch(e){}
    return null;
  }

  function updateXP(){
    const el = document.getElementById("xsXP");
    if(!el) return;
    const v = getXPValue();
    el.textContent = (v === null || v === undefined) ? "--" : String(v);
  }

  // Radio status (Ouvirmusica window or any running iframe)
  function isMusicBrowserAlive(){
    const wrap = document.getElementById("xs-music-browser");
    if(!wrap) return false;
    const iframe = wrap.querySelector("iframe");
    const alive = !!iframe && (wrap.style.display !== "none" || wrap.classList.contains("minimized"));
    return alive;
  }

  function updateRadio(){
    const el = document.getElementById("xsRadio");
    const ic = document.getElementById("xsRadioIcon");
    if(!el) return;

    const on = isMusicBrowserAlive();
    el.textContent = on ? "ON" : "OFF";
    if(ic) ic.textContent = on ? "radio" : "radio_button_off";
  }

  function updateSysbarAll(){
    updateClock();
    renderBattery();
    updateXP();
    updateRadio();
  }

  // ---- Dino hint ----
  function updateDinoHint(){
    const hint = document.getElementById("dino-kbd-hint");
    const cont = document.getElementById("dino-game-container");
    if(!hint || !cont) return;

    const visible = cont.style.display !== "none";
    if(!visible){
      hint.classList.remove("show");
      return;
    }
    if(window.isMobile) hint.classList.remove("show");
    else hint.classList.add("show");
  }
  window.xsUpdateDinoControlHint = updateDinoHint;

  // ---- Apply state ----
  let lastMode = null;
  function applyDeviceState(opts){
    const st = computeIsMobile();
    window.isMobile = !!st.isMobile;

    root.classList.toggle("xs-mobile", window.isMobile);
    root.classList.toggle("xs-desktop", !window.isMobile);

    const mode = window.isMobile ? "mobile" : "desktop";
    const changed = (mode !== lastMode);
    lastMode = mode;

    // best-effort UI updates
    updateSysbarAll();
    updateDinoHint();

    if(changed || (opts && opts.forceToast)) showDeviceToast(!!(opts && opts.forceToast));
  }

  // Resize watchdog (debounced)
  let rz = null;
  function onResize(){
    if(rz) clearTimeout(rz);
    rz = setTimeout(()=> applyDeviceState({}), 120);
  }
  window.addEventListener("resize", onResize, { passive: true });
  window.addEventListener("orientationchange", ()=> applyDeviceState({ forceToast: true }), { passive: true });

  // ---- Gamepad detection ----
  function pollGamepad(){
    let has = false;
    try{
      const gps = navigator.getGamepads ? navigator.getGamepads() : [];
      for(let i=0;i<gps.length;i++){
        const gp = gps[i];
        if(gp && gp.connected){ has = true; break; }
      }
    }catch(e){}
    if(has !== window.xsHasGamepad){
      window.xsHasGamepad = has;
      root.classList.toggle("xs-gamepad", has);
      // If gamepad connects, toast + update hint/controls
      showDeviceToast(true);
    }
  }
  window.addEventListener("gamepadconnected", pollGamepad);
  window.addEventListener("gamepaddisconnected", pollGamepad);
  setInterval(pollGamepad, 1000);

  // ---- Boot ----
  applyDeviceState({ forceToast: true });
  initBattery();
  // XS PERF: ticker sem sobreposição; reduz impacto durante jogos/roleta
  try { if (window.__xsSysbarTimer) clearTimeout(window.__xsSysbarTimer); } catch(e){}
  window.__xsSysbarTimer = 0;
  (function __xsSysbarTick(){
    // 'heavy' quando jogo/roleta está rodando (evita micro travadas)
    const heavy = (() => {
      try {
        const gr = document.getElementById('game-runtime');
        const gameOn = gr && gr.style.display === 'block';
        const rouletteOn = !!window.__rouletteSpinning;
        return !!(gameOn || rouletteOn);
      } catch(e){ return false; }
    })();

    try { updateClock(); } catch(e){}
    if (!heavy) {
      try { renderBattery(); } catch(e){}
      try { updateXP(); } catch(e){}
      try { updateRadio(); } catch(e){}
    }

    const next = heavy ? 1500 : 1000;
    window.__xsSysbarTimer = setTimeout(__xsSysbarTick, next);
  })();

  // Keep hint updated when dino starts (any style)
  const dinoCont = document.getElementById("dino-game-container");
  if(dinoCont){
    const obs = new MutationObserver(()=> updateDinoHint());
    obs.observe(dinoCont, { attributes:true, attributeFilter:["style","class"] });
  }

})();
</script>


<script>
/* =========================
   XUXUBISTATION XS v8.2.1 - Avatar Tabs Hotfix
   - Corrige: abas (ROSTO/CABELO/ESTILO/EXTRA) não trocando conteúdo
   - Motivo comum: switchAvatarTab não estar definido no escopo global / conflitos de listeners.
   ========================= */
(function(){
  // Garantir globals
  if (typeof window.currentAvTab === "undefined" || !window.currentAvTab) window.currentAvTab = "face";

  // Remoção/reciclagem de listeners sem acumular
  let __avTabsAbort = null;

  window.switchAvatarTab = function(tabId){
    if (!tabId) return;
    if (!window.currentAvTab) window.currentAvTab = "face";
    if (tabId === window.currentAvTab) return;

    try { if (typeof playSysSound === "function") playSysSound(520, "sine", 0.08); } catch(e) {}

    const modal = document.getElementById("profile-modal");
    if (!modal) { window.currentAvTab = tabId; return; }

    // Tabs
    modal.querySelectorAll(".xsav-tab").forEach(btn=>{
      btn.classList.toggle("is-active", btn.dataset.tab === tabId);
    });

    // Panels
    modal.querySelectorAll(".xsav-panel").forEach(panel=>{
      panel.classList.toggle("is-active", panel.dataset.tab === tabId);
    });

    window.currentAvTab = tabId;
  };

  window.__xsRebindAvatarTabs = function(){
    const modal = document.getElementById("profile-modal");
    if (!modal) return;

    // Evitar duplicação de listeners em re-render
    if (__avTabsAbort) __avTabsAbort.abort();
    __avTabsAbort = new AbortController();
    const { signal } = __avTabsAbort;

    // Bind direto nos botões (mais simples e confiável)
    modal.querySelectorAll(".xsav-tab").forEach(btn=>{
      btn.addEventListener("click", (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        window.switchAvatarTab(btn.dataset.tab);
      }, { signal });
    });

    // (Opcional) clique nos painéis não deve travar a UI
    modal.querySelectorAll(".xsav-panel").forEach(panel=>{
      panel.addEventListener("click", ()=>{}, { signal });
    });
  };

  // Hook: após render do customizador, rebind garantido
  const _render = window.__renderCustomizerUI;
  if (typeof _render === "function"){
    window.__renderCustomizerUI = function(){
      const r = _render.apply(this, arguments);
      try { window.__xsRebindAvatarTabs(); } catch(e) {}
      return r;
    };
  }

  // Hook: ao abrir editor, rebind garantido
  const _open = window.openProfileEditor;
  if (typeof _open === "function"){
    window.openProfileEditor = function(){
      const r = _open.apply(this, arguments);
      // Caso a UI já exista, rebind. Caso não exista, tenta renderizar.
      try {
        if (typeof window.__renderCustomizerUI === "function") window.__renderCustomizerUI();
        window.__xsRebindAvatarTabs();
      } catch(e) {}
      return r;
    };
  }

  // Se o modal já estiver aberto por algum motivo, aplica
  try { window.__xsRebindAvatarTabs(); } catch(e) {}
})();


/* =========================================================
   GUIA DO CONSOLE (HUB) - Neon Guide v1.0
   - Substitui o "tutorial" antigo por um HUB de capítulos
   - Inclui tutorial completo do Bixin Explorador (farm de XC)
   ========================================================= */

(function(){
  const $ = (id)=>{ try{return document.getElementById(id);}catch(e){return null;} };

  // --------- Gerador de "imagens do jogo" (shots) ----------
// Gera screenshots ilustrativos (estilo neon) do Bixin Explorador.
// Motivo: evita imagens quebradas e funciona offline, sem dependências externas.

function __xsGenBixinShot(scene){
  try{
    const w = 960, h = 540;
    const c = document.createElement("canvas");
    c.width = w; c.height = h;
    const ctx = c.getContext("2d");

    // background
    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0, "#07101a");
    g.addColorStop(1, "#071a33");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // vignette
    const vg = ctx.createRadialGradient(w*0.55,h*0.45, 40, w*0.55,h*0.45, w*0.75);
    vg.addColorStop(0, "rgba(0,0,0,0)");
    vg.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);

    // helpers
    
function rr(x,y,ww,hh,r){
  // Rounded-rect path helper (compatível com browsers sem ctx.roundRect)
  r = Math.max(0, Math.min(r, Math.min(ww,hh)/2));
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+ww, y, x+ww, y+hh, r);
  ctx.arcTo(x+ww, y+hh, x, y+hh, r);
  ctx.arcTo(x, y+hh, x, y, r);
  ctx.arcTo(x, y, x+ww, y, r);
  ctx.closePath();
}
function glowRect(x,y,ww,hh,fill,stroke){
      ctx.save();
      ctx.fillStyle = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 3;
      ctx.shadowColor = stroke;
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.roundRect(x,y,ww,hh, 12);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.stroke();
      ctx.restore();
    }
    function label(txt){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(24, 24, w-48, 64, 14);
      ctx.fill(); ctx.stroke();
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "700 24px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillText(txt, 44, 66);
      ctx.restore();
    }
    function drawShot(x1,y1,x2,y2){
      ctx.save();
      ctx.strokeStyle="rgba(255,215,0,0.88)";
      ctx.shadowColor="rgba(255,215,0,1)";
      ctx.shadowBlur=18;
      ctx.lineWidth=5;
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.beginPath(); ctx.arc(x2,y2,7,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // ground
    const groundY = 420;
    ctx.save();
    ctx.strokeStyle = "rgba(0,210,255,0.20)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, groundY);
    ctx.lineTo(w, groundY);
    ctx.stroke();
    ctx.restore();

    // player (carrinho)
    function drawPlayer(px, py){
      glowRect(px, py, 74, 50, "rgba(0,210,255,0.22)", "rgba(0,210,255,0.55)");
      glowRect(px+10, py+10, 54, 22, "rgba(255,255,255,0.10)", "rgba(255,255,255,0.20)");
      // rodas
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.55)";
      ctx.beginPath(); ctx.arc(px+18, py+56, 10, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+56, py+56, 10, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,0.25)";
      ctx.beginPath(); ctx.arc(px+18, py+56, 3, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px+56, py+56, 3, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // blocks / enemies
    function redBlock(x,y,cracked){
      glowRect(x,y, 140, 92, "rgba(255,43,94,0.70)", "rgba(255,43,94,0.78)");
      if(cracked){
        ctx.save();
        ctx.strokeStyle="rgba(255,255,255,0.35)";
        ctx.lineWidth=4;
        ctx.beginPath();
        ctx.moveTo(x+35,y+18);
        ctx.lineTo(x+70,y+45);
        ctx.lineTo(x+48,y+72);
        ctx.stroke();
        ctx.restore();
      }
    }
    function grayBlock(x,y){
      glowRect(x,y, 140, 100, "rgba(200,200,200,0.70)", "rgba(200,200,200,0.42)");
    }
    function groundEnemy(x){
      glowRect(x, groundY-52, 52, 52, "rgba(255,110,0,0.88)", "rgba(255,110,0,0.78)");
    }
    function flyEnemy(x,y){
      glowRect(x, y, 56, 56, "rgba(255,45,110,0.72)", "rgba(255,45,110,0.78)");
      ctx.save();
      ctx.fillStyle="rgba(255,255,255,0.85)";
      ctx.fillRect(x+14,y+20,8,6);
      ctx.fillRect(x+34,y+20,8,6);
      ctx.restore();
    }

    // default placement
    const px = 180, py = groundY-64;
    const bx = 600, by = groundY-92;

    // scenes
    if(scene === "jump_red"){
      drawPlayer(px, py-120);
      redBlock(bx, by, false);
      label("Pular sobre o bloco vermelho (plataforma)");
    } else if(scene === "red_dash"){
      drawPlayer(px+20, py-180);
      redBlock(bx, by, false);
      ctx.save();
      ctx.strokeStyle="rgba(0,210,255,0.35)";
      ctx.lineWidth=7;
      ctx.shadowColor="rgba(0,210,255,0.7)";
      ctx.shadowBlur=18;
      ctx.beginPath();
      ctx.moveTo(px+60, py-80);
      ctx.quadraticCurveTo(420, 120, bx+30, by-40);
      ctx.stroke();
      ctx.restore();
      label("RED DASH: cair forte + pular no timing");
    } else if(scene === "shoot_red_1"){
      drawPlayer(px, py);
      redBlock(bx, by, true);
      drawShot(px+80, py+10, bx+40, by+40);
      label("Tiro 1/2 no bloco vermelho: rachou");
    } else if(scene === "shoot_red_2"){
      drawPlayer(px, py);
      drawShot(px+80, py+10, bx+40, by+40);
      ctx.save();
      ctx.globalAlpha=0.85;
      ctx.fillStyle="rgba(255,43,94,0.85)";
      for(let i=0;i<32;i++){
        const a=i*(Math.PI*2/32);
        ctx.fillRect(bx+70+Math.cos(a)*26, by+46+Math.sin(a)*18, 5, 5);
      }
      ctx.restore();
      label("Tiro 2/2 no bloco vermelho: quebrou");
    } else if(scene === "penalty"){
      drawPlayer(px, py);
      redBlock(bx, by, true);
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle="rgba(255,255,255,0.92)";
      ctx.font="900 40px system-ui, sans-serif";
      ctx.fillText("PENALIDADE", 340, 220);
      ctx.fillStyle="rgba(255,43,94,0.92)";
      ctx.font="800 26px system-ui, sans-serif";
      ctx.fillText("MULT x1", 415, 260);
      ctx.restore();
      label("2 batidas laterais no bloco vermelho = reset do MULT");
    } else if(scene === "stomp_ground"){
      drawPlayer(px+20, py-140);
      groundEnemy(bx+10);
      label("Monstro terrestre: pise em cima pra destruir");
    } else if(scene === "shoot_fly"){
      drawPlayer(px, py);
      flyEnemy(bx+20, 170);
      drawShot(px+80, py+10, bx+50, 200);
      label("Monstro vermelho (voador): elimine com tiro");
    } else if(scene === "jump_over_fly"){
      drawPlayer(px+10, py-150);
      flyEnemy(bx+20, 170);
      label("Pular por cima do monstro vermelho (sem encostar)");
    } else if(scene === "death_gray"){
      drawPlayer(px, py);
      grayBlock(bx, groundY-100);
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.60)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle="rgba(255,43,94,0.92)";
      ctx.font="900 52px system-ui, sans-serif";
      ctx.fillText("GAME OVER", 320, 250);
      ctx.restore();
      label("Bloco cinza: lado/baixo = morte (em cima é seguro)");
    } else {
      drawPlayer(px, py);
      redBlock(bx, by, false);
      label("Bixin Explorador");
    }

    return c.toDataURL("image/png");
  }catch(e){
    return "";
  }
}

function __xsGetBixinShots(){
  try{
    if (window.__GUIDE__ && window.__GUIDE__.bixinShots) return window.__GUIDE__.bixinShots;
  }catch(e){}
  const shots = {
    jump_red: __xsGenBixinShot("jump_red"),
    red_dash: __xsGenBixinShot("red_dash"),
    shoot_red_1: __xsGenBixinShot("shoot_red_1"),
    shoot_red_2: __xsGenBixinShot("shoot_red_2"),
    penalty: __xsGenBixinShot("penalty"),
    stomp_ground: __xsGenBixinShot("stomp_ground"),
    shoot_fly: __xsGenBixinShot("shoot_fly"),
    jump_over_fly: __xsGenBixinShot("jump_over_fly"),
    death_gray: __xsGenBixinShot("death_gray")
  };
  if (!window.__GUIDE__) window.__GUIDE__ = {};
  window.__GUIDE__.bixinShots = shots;
  return shots;
}


// --------- Conteúdo do guia ----------
  function callout(txt){ return `<div class="guide-callout">${txt}</div>`; }
  function ul(items){ return `<ul>${items.map(i=>`<li>${i}</li>`).join("")}</ul>`; }
  function fig(key, cap){
    return `<div class="guide-figure"><img class="guide-shot" data-bixin-shot="${key}" alt="${cap}"><div class="guide-figcap">${cap}</div></div>`;
  }

  const CHAPTERS = [
    {
      id: "start",
      label: "Começando",
      icon: { type:"mi", value:"auto_stories" },
      subtitle: "Como usar o console do zero (perfil, menu, abrir/fechar jogos).",
      pages: [
        {
          title: "Primeiros passos",
          html:
            `<h4>Primeiros passos</h4>
             <p>O XUXUBISTATION XS salva seu progresso automaticamente no navegador (perfil, moedas, compras, conquistas e configurações).</p>
             ${callout("Se você fechar e abrir de novo, suas coisas continuam.")}
             ${ul([
               "<b>1)</b> Escolha seu <b>perfil</b> na tela inicial.",
               "<b>2)</b> No menu principal, use a esteira de capas e selecione um jogo/app.",
               "<b>3)</b> Aperte <b>OK / Enter / A</b> (ou toque) pra abrir.",
               "<b>4)</b> Use o botão de <b>fechar</b> dentro do jogo pra voltar ao console."
             ])}`
        },
        {
          title: "Abrir e fechar jogos sem bug",
          html:
            `<h4>Abrir e fechar jogos sem bug</h4>
             <p>Quando você abre um jogo, o console entra em modo <b>Runtime</b> (iframe) e faz reset seguro do estado anterior.</p>
             ${ul([
               "Se um jogo ficar <b>tela preta</b>: feche e abra de novo (o runtime é resetado).",
               "Alguns sites bloqueiam iframe — nesses casos o console pode abrir fora (quando configurado).",
               "Sempre feche o jogo antes de abrir outro, pra evitar tela congelada."
             ])}
             ${callout("Dica: se algo travar, vá em <b>Configurações → Limpar Cache</b> (pede confirmação).")}`
        }
      ]
    },

    {
      id: "economy",
      label: "Economia & Config",
      icon: { type:"mi", value:"settings" },
      subtitle: "XC, Loja, Roleta e todas as configurações importantes.",
      pages: [
        {
          title: "Moedas XC (o básico)",
          html:
            `<h4>Moedas XC</h4>
             <p><b>XC</b> é a moeda do sistema. Você usa pra personalizar o console e comprar recursos (ex.: giros bônus na roleta).</p>
             ${ul([
               "Seu saldo aparece no topo do console.",
               "Você ganha XC jogando e completando conquistas.",
               "<b>Bixin Explorador</b> é uma fonte rápida de XC (capítulo dedicado aqui no guia)."
             ])}`
        },
        {
          title: "Loja & Personalização",
          html:
            `<h4>Loja & Personalização</h4>
             <p>Na Loja você compra e equipa temas, efeitos, estilos de card e outros visuais.</p>
             ${ul([
               "Clicou em um item bloqueado → tenta comprar.",
               "Se já for seu → equipa na hora.",
               "Se faltar XC → aparece aviso de saldo insuficiente."
             ])}`
        },
        {
          title: "Roleta XC",
          html:
            `<h4>Roleta XC</h4>
             <p>A roleta tem giros diários + giros bônus.</p>
             ${ul([
               "Giros diários resetam com o tempo do sistema.",
               "Você pode comprar <b>giro bônus</b> (custa XC).",
               "Tudo que você ganha vai pro <b>Inventário</b> da roleta."
             ])}
             ${callout("Se você quiser algo específico, gire mais vezes: o sistema tem progressão e chances melhores com o tempo (pity).")}`
        },
        {
          title: "Configurações que importam",
          html:
            `<h4>Configurações</h4>
             ${ul([
               "<b>Brilho</b>: controla o dimmer (bom pra noite).",
               "<b>Volume</b>: salva automaticamente.",
               "<b>Overclock</b>: modo turbo (pode aquecer / avisos).",
               "<b>Limpar Cache</b>: pede confirmação e preserva itens essenciais."
             ])}`
        }
      ]
    },

    {
      id: "files",
      label: "Arquivos & Apps",
      icon: { type:"mi", value:"folder_open" },
      subtitle: "XS Drive, pasta de jogos, sideload, jukebox e apps do console.",
      pages: [
        {
          title: "XS Drive (arquivos)",
          html:
            `<h4>XS Drive</h4>
             <p>Seu gerenciador de arquivos do console: crie, salve, renomeie, baixe e delete.</p>
             ${ul([
               "Use <b>Novo</b> para criar um arquivo.",
               "<b>Salvar</b> atualiza sem perder o conteúdo.",
               "<b>Baixar</b> exporta pro seu aparelho.",
               "<b>Deletar</b> remove do console."
             ])}`
        },
        {
          title: "Sideload (adicionar jogo por link)",
          html:
            `<h4>Sideload</h4>
             <p>Adicione jogos por URL diretamente no console.</p>
             ${ul([
               "Abra a opção de <b>Adicionar por URL</b>.",
               "Cole a URL e dê um nome.",
               "O jogo aparece na <b>Pasta de Jogos</b> (e dá pra apagar por lá)."
             ])}
             ${callout("Dica: se um site bloquear iframe, pode dar tela preta. Teste outros jogos/links.")}`
        },
        {
          title: "Jukebox (música)",
          html:
            `<h4>Jukebox</h4>
             <p>Player de música do console.</p>
             ${ul([
               "Você pode <b>minimizar</b> e deixar tocando enquanto navega.",
               "Fechar a jukebox para o som."
             ])}`
        }
      ]
    },

    {
      id: "controls",
      label: "Controles",
      icon: { type:"mi", value:"sports_esports" },
      subtitle: "Touch, teclado e gamepad — como o console se adapta.",
      pages: [
        {
          title: "Touch / Teclado / Mouse",
          html:
            `<h4>Controles básicos</h4>
             ${ul([
               "<b>Touch</b>: toque nos cards e botões do sistema.",
               "<b>Mouse</b>: clique para selecionar e abrir.",
               "<b>Teclado</b>: Enter/OK abre; ESC volta (quando disponível)."
             ])}`
        },
        {
          title: "Gamepad",
          html:
            `<h4>Gamepad</h4>
             <p>Quando um controle é detectado, o console troca pro modo gamepad e pode esconder botões touch pra ficar limpo.</p>
             ${ul([
               "Use direcional/analógico pra navegar.",
               "Use <b>A/OK</b> pra abrir.",
               "Se o touch sumir, é porque o gamepad foi detectado."
             ])}`
        }
      ]
    },

    {
      id: "bixin",
      label: "Bixin Explorador",
      icon: { type:"mi", value:"directions_run" },
      subtitle: "Mini game oficial pra ganhar XC — com regras, penalidades e dicas.",
      pages: [
        {
          title: "Bixin Explorador é farm de XC",
          html:
            `<h4>Bixin Explorador (ganhar XC)</h4>
             <p>Esse minigame é uma <b>fonte real de XC</b>. Você joga, acumula moedas dentro da run e o console converte em XC no <b>Game Over</b>.</p>
             ${ul([
               "Quanto mais tempo vivo, mais XC no final.",
               "Coletar moedas e matar inimigos ajuda no ganho.",
               "A conversão acontece quando você morre (tela de Game Over)."
             ])}
             ${callout("Meta de farm: foque em consistência (sobrevivência) + boas decisões com blocos e tiros.")}`
        },

        {
          title: "Controles do Bixin",
          html:
            `<h4>Controles</h4>
             ${ul([
               "<b>PULO</b>: toque/clique / Espaço / (A).",
               "<b>TIRO</b>: botão de tiro no touch / (X) / tecla dedicada (se disponível no seu layout).",
               "No touch, os botões aparecem na tela durante o minigame."
             ])}
             ${callout("Dica: o tiro é inteligente — se tiver inimigo no alcance ele mira e elimina. Se não tiver inimigo, ele tenta quebrar bloco vermelho.")}`
        },

        {
          title: "Bloco Cinza",
          html:
            `<h4>Bloco Cinza (SÓLIDO)</h4>
             <p>O bloco cinza funciona como plataforma, mas tem uma regra fatal:</p>
             ${ul([
               "✅ <b>Em cima</b> dele: seguro (plataforma).",
               "❌ <b>Lado ou por baixo</b>: MORTE instantânea."
             ])}
             <div class="guide-grid">
               ${fig("death_gray","Bloco cinza: bater lateral/por baixo = morte.")}
             </div>`
        },

        {
          title: "Bloco Vermelho",
          html:
            `<h4>Bloco Vermelho (QUEBRÁVEL)</h4>
             ${ul([
               "Pode ser usado como plataforma (pular em cima).",
               "Se bater sem cair certinho, ele <b>quebra</b> e te dá <b>lentidão</b>.",
               "Você pode quebrar com <b>TIRO</b>: são <b>2 tiros</b> (racha → quebra)."
             ])}
             <div class="guide-grid">
               ${fig("jump_red","Pular sobre o bloco vermelho (plataforma).")}
               ${fig("shoot_red_1","Tiro 1/2: bloco vermelho rachou.")}
               ${fig("shoot_red_2","Tiro 2/2: bloco vermelho quebrou.")}
             </div>`
        },

        {
          title: "Penalidade do Bloco Vermelho",
          html:
            `<h4>Penalidade (grave)</h4>
             <p>Se você der <b>2 batidas laterais</b> no bloco vermelho (não vindo de cima), você toma penalidade:</p>
             ${ul([
               "Perde 1 moeda coletada (se tiver).",
               "Seu <b>MULT</b> volta para <b>x1</b>.",
               "O console mostra aviso de penalidade."
             ])}
             <div class="guide-grid">
               ${fig("penalty","2 batidas laterais no bloco vermelho = MULT reset (x1).")}
             </div>
             ${callout("Dica: em bloco vermelho, procure cair por cima. Se estiver sem saída, use TIRO pra remover.")}`
        },

        {
          title: "RED DASH (a mecânica mais forte)",
          html:
            `<h4>RED DASH</h4>
             <p>Essa é a mecânica de “super pulo” do Bixin:</p>
             ${ul([
               "Você precisa estar <b>caindo rápido</b> (queda forte).",
               "Pressione <b>PULO no timing</b> ao encostar por cima no bloco vermelho.",
               "Resultado: você destrói o bloco, ganha boost e aumenta o MULT."
             ])}
             <div class="guide-grid">
               ${fig("red_dash","RED DASH: queda + pulo no timing → super pulo + MULT.")}
             </div>
             ${callout("Treino: tente repetir o timing em blocos vermelhos seguidos pra subir o MULT.")}`
        },

        {
          title: "Monstro Terrestre",
          html:
            `<h4>Monstro Terrestre (chão)</h4>
             <p>Ele fica no chão e te mata no contato direto. Como lidar:</p>
             ${ul([
               "✅ Pise em cima pra destruir (pulo de cima).",
               "✅ Também dá pra usar RED DASH nele (mais difícil).",
               "❌ Encostar de lado = MORTE."
             ])}
             <div class="guide-grid">
               ${fig("stomp_ground","Pular em cima do monstro terrestre destrói ele.")}
             </div>`
        },

        {
          title: "Monstro Vermelho (voador)",
          html:
            `<h4>Monstro Vermelho (voador)</h4>
             <p>Esse é o inimigo mais perigoso: encostou, morreu.</p>
             ${ul([
               "✅ Use <b>TIRO</b> antes de ele chegar (mais seguro).",
               "✅ Também dá pra <b>pular por cima</b> sem encostar.",
               "❌ Encostar em qualquer parte = MORTE."
             ])}
             <div class="guide-grid">
               ${fig("shoot_fly","Tiro elimina o monstro vermelho antes do contato.")}
               ${fig("jump_over_fly","Pular por cima funciona, mas é arriscado se você encostar.")}
             </div>
             ${callout("Dica de ouro: se estiver na dúvida, atire. O tiro prioriza inimigos quando eles estão no alcance.")}`
        }
      ]
    },

    {
      id: "emu",
      label: "Emuladores",
      icon: { type:"img", value:"https://pngimg.com/uploads/sony_playstation/sony_playstation_PNG17545.png" },
      subtitle: "Como abrir e usar emuladores/pastas externas dentro do console.",
      pages: [
        {
          title: "Emuladores (PS1 / SNES / Arcade)",
          html:
            `<h4>Emuladores</h4>
             <p>Os emuladores abrem como “pasta/app” e podem carregar um catálogo externo.</p>
             ${ul([
               "Abra o emulador pelo menu.",
               "Use o botão <b>ABRIR EMULADOR</b> dentro da tela do emulador.",
               "Use <b>VOLTAR</b> pra retornar ao console."
             ])}
             ${callout("Se algum emulador ficar em branco: feche e abra de novo (ou teste outro navegador).")}`
        }
      ]
    }
  ];

  // Estado do guia
  if (!window.__GUIDE__) window.__GUIDE__ = {};
  const G = window.__GUIDE__;
  G.chapters = CHAPTERS;
  G.sel = G.sel ?? 0;
  G.page = G.page ?? 0;
  G.inited = G.inited ?? false;

  function _renderHub(){
    const track = $("guide-track");
    if (!track) return;

    track.innerHTML = "";
    CHAPTERS.forEach((ch, idx)=>{
      const card = document.createElement("div");
      card.className = "guide-card" + (idx === G.sel ? " selected" : "");
      card.setAttribute("data-idx", String(idx));

      const icon = document.createElement("div");
      icon.className = "gicon";
      if (ch.icon.type === "mi"){
        const s = document.createElement("span");
        s.className = "material-icons";
        s.textContent = ch.icon.value;
        icon.appendChild(s);
      } else {
        const im = document.createElement("img");
        im.src = ch.icon.value;
        im.alt = ch.label;
        icon.appendChild(im);
      }

      const lbl = document.createElement("div");
      lbl.className = "glabel";
      lbl.textContent = ch.label;

      card.appendChild(icon);
      card.appendChild(lbl);

      card.onclick = ()=>{
        G.sel = idx;
        _renderHub();
        try{ playSysSound(460, "sine", 0.05); }catch(e){}
        try{ card.scrollIntoView({behavior:"smooth", inline:"center", block:"nearest"}); }catch(e){}
      };

      track.appendChild(card);
    });

    // tenta centralizar o selecionado
    try{
      const selEl = track.querySelector(".guide-card.selected");
      if (selEl) selEl.scrollIntoView({behavior:"auto", inline:"center", block:"nearest"});
    }catch(e){}
  }

  function _applyShots(container){
    if (!container) return;
    const shots = __xsGetBixinShots();
    container.querySelectorAll("img[data-bixin-shot]").forEach(img=>{
      const key = img.getAttribute("data-bixin-shot");
      if (key && shots[key]) img.src = shots[key];
    });
  }

  function _renderPage(){
    const ch = CHAPTERS[G.sel];
    const page = ch.pages[G.page];
    const titleEl = $("guide-chapter-title");
    const subEl = $("guide-chapter-sub");
    const pageEl = $("guide-page");
    const pn = $("guide-page-num");
    const pt = $("guide-page-total");

    if (titleEl) titleEl.textContent = ch.label;
    if (subEl) subEl.textContent = ch.subtitle || "";
    if (pageEl) pageEl.innerHTML = page.html || "";
    if (pn) pn.textContent = String(G.page + 1);
    if (pt) pt.textContent = String(ch.pages.length);

    _applyShots(pageEl);

    // SFX suave
    try{ playSysSound(520, "sine", 0.05); }catch(e){}
  }

  // API global
  window.guideInit = function(force){
    if (G.inited && !force) return;
    G.inited = true;
    _renderHub();
    // sempre volta pro hub ao abrir
    const hub = $("guide-hub");
    const reader = $("guide-reader");
    if (hub && reader){
      hub.style.display = "block";
      reader.style.display = "none";
    }
  };

  window.guideHubPrev = function(){
    G.sel = (G.sel - 1 + CHAPTERS.length) % CHAPTERS.length;
    _renderHub();
    // scroll para seleção
    try{
      const track = $("guide-track");
      const selEl = track ? track.querySelector(".guide-card.selected") : null;
      if (selEl) selEl.scrollIntoView({behavior:"smooth", inline:"center", block:"nearest"});
    }catch(e){}
  };

  window.guideHubNext = function(){
    G.sel = (G.sel + 1) % CHAPTERS.length;
    _renderHub();
    try{
      const track = $("guide-track");
      const selEl = track ? track.querySelector(".guide-card.selected") : null;
      if (selEl) selEl.scrollIntoView({behavior:"smooth", inline:"center", block:"nearest"});
    }catch(e){}
  };

  window.guideOpenSelected = function(){
    const hub = $("guide-hub");
    const reader = $("guide-reader");
    if (!hub || !reader) return;
    hub.style.display = "none";
    reader.style.display = "block";
    G.page = 0;
    _renderPage();
  };

  window.guideBackToHub = function(){
    const hub = $("guide-hub");
    const reader = $("guide-reader");
    if (!hub || !reader) return;
    reader.style.display = "none";
    hub.style.display = "block";
    // feedback
    try{ playSysSound(380, "triangle", 0.05); }catch(e){}
  };

  window.guidePrevPage = function(){
    const ch = CHAPTERS[G.sel];
    G.page = (G.page - 1 + ch.pages.length) % ch.pages.length;
    _renderPage();
  };

  window.guideNextPage = function(){
    const ch = CHAPTERS[G.sel];
    G.page = (G.page + 1) % ch.pages.length;
    _renderPage();
  };

  window.closeGuide = function(){
    // volta sempre pro hub na próxima abertura
    try{
      const hub = $("guide-hub");
      const reader = $("guide-reader");
      if (hub && reader){
        reader.style.display = "none";
        hub.style.display = "block";
      }
    }catch(e){}
    try{ closeModal("tutorial-modal"); }catch(e){}
  };

  // Garante init ao abrir o modal
  try{
    const __oldOpenModal = window.openModal;
    window.openModal = function(id){
      try{ if (typeof __oldOpenModal === "function") __oldOpenModal(id); else { const el=$(id); if(el) el.style.display="flex"; } }catch(e){}
      if (id === "tutorial-modal"){
        try{ window.guideInit(true); }catch(e){}
      }
    };
  }catch(e){}

})();

</script>
</body>
</html>